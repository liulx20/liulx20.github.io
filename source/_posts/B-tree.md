---
title: B-tree
date: 2021-05-31 22:14:02
tags: 数据结构
---

### 删除元素

给定key,要求从树中删除key指定的元素

1. 首先找到K的位置，如果没有找到，error

2. 如果K在内部节点内（非叶子），找到当前节点的左子树C,将K换为C中最大的元素$K_{new}$，然后在子树中递归删除$K_{new}$

3. 重复步骤2,直到删到到叶子节点,此时删除$K'$ ,若叶子节点的key数量仍然满足最小要求，删除完成

4. 删除后，叶子节点可能少于最低要求，假设目标节点在父节点中位于$K_{left}$与$K_{right}$之间，首先检查它的左兄弟的键数量是否大于最低要求。

   * 如果是，把$K_{left}$移到当前节点，用左兄弟中的最大的key$K_{leftchild}$取代$K_{left}$
   * 否则，检查右兄弟，如果右兄弟key数量大于最低要求，把右兄弟中最小的key$K_{rightchild}$取代$K_{right}$,$K_{right}$移到当前节点
   * 如果当前节点是最左、最右子树，忽略检查不存在的兄弟
   * 如果没有找到合适的兄弟节点，执行step 6

5.  对于非叶子节点，如果左兄弟有多于最低要求的keys,记$C_{left}$为左兄弟中最大的儿子,将$K_{left}$换为$K_{leftchild}$，将$K_{left}$挪到目标位置，同时把$C_{left}$也挪过来接到$K_{left}$左边。右兄弟类似

6. 如果当前节点没有兄弟有多于最低要求的keys, 将目标节点与一个兄弟节点合并，如果左兄弟存在，合并左兄弟，否则合并右兄弟，同时也把父节点对应key移下来，（如果合并的是左兄弟，则为$K_{left}$,否则为$K_{right}$,父节点此时少了一个key,如果key数量不满足要求

   递归执行4-6，如果满足了key的最低数量要求，算法完成

7. 如果到达了根节点，且key的数量少于最低要求，删除根节点，合并孩子节点，树高减1
