---
title: 网络编程
date: 2021-10-09 15:02:03
tags:
---

C/S模型：缓存大量数据，协议选择灵活,速度快，缺点：安全性

B/S模型：安全、跨平台，开发工作量小 缺点：不能缓存大量数据，严格遵守HTTP

### Socket编程

网络套接字：socket

一个文件描述符指向一个套接字，该套接字内部由内核借助两个缓存区实现

在通信过程中。套接字一定是成对出现的

* 网络字节序：

  大端法：低地址高字节

  网络字节序和主机字节序转换

  ```c
  #include <arpa/inet.h>
  uint32_t htonl(uint32_t hostlong);//本地->网络
  uint16_t htons(uint16_t hostshort);
  uint32_t ntohl(uint32_t netlong);//网络转本地
  uint16_t ntohs(uint16_t netlong);
  //IP地址转换函数
  int inet_pton(int af,const char *src,void *dest);本地字节序（string ip)->网络字节序
  af:AF_INET
     AF_INET6
  src:传入参数 IP地址，点分十进制
  dest：传出参数，网络字节序的IP地址
  成功返回1，异常0src不是有效ip地址，失败-1
  const char *inet_ntop(int af,const void*src,char *dst,socklen_t size);网络字节序->本地字节序（string ip)
  src:网络字节序ip地址
  dst:本地字节序（string ip)
  size dst大小
  返回值 成功src
        失败NULL
  ```

  man 7 ip

* sockaddr地址结构

  ```c
  struct sockaddr_in addr;
  struct sockaddr_in {
                 sa_family_t    sin_family; /* address family: AF_INET */
                 in_port_t      sin_port;   /* port in network byte order */
                 struct in_addr sin_addr;   /* internet address */
  };
  struct in_addr {
                 uint32_t       s_addr;     /* address in network byte order */
  };
  addr.sin_family = AF_INET;
  addr.sin_port = hton(9527);
  int dest;
  addr.sin_addr.s_addr = inet_pton(AF_INET,"192.152.22.35",(void *)&dst);
  addr.sin_addr.s_addr = htonl(INADDR_ANY）;//取出系统中任意有效地址，二进制类型
  bind(fd,(struct sockaddr*)&addr,len);
  ```

  服务器

  socket()创建套接字

  bind(）绑定IP+Port

  listen()设置同时监听上限

  accept()阻塞监听客户端连接

  close()

  客户端

  socket()创建套接字

  connect()绑定IP和端口

  close()

  ```c
  #include <sys/socket.h>
  int socket(int domain, int type, int protocol);//创建一个套接字
  domain: AF_INET AF_INET6 AF_UNIX（本地）
  type:SOCK_STREAM,SOCK_DGRAM
  protocol:0
  成功返回新套接字对应的文件描述符
  失败-1,perror
      socket(AF_INET,SOCK_STREAM,0);
  #include <arpa/inet.h>
  int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);//给socket绑定一个地址结构（IP+port)
  sockfd:socket函数返回值
      struct socket_addr_in addr;
      addr.sin_family = AF_INET;//要与sock传递的一致
      
  addr:&addr
  addrlen:sizeof(addr)
  成功0
  失败-1
  
  int listen(int sockfd, int backlog);//设置同时与服务器建立连接的上限数
  backlog:上限数值，最大128
  成功0
  失败-1
  
      
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);//阻塞等待客户端建立连接，成功的话返回一个与客户端成功连接的socket文件描述符
  sockfd:socket 返回值
  addr:传出参数，成功与服务器建立连接的客户端地址结构
      socklen_t addr_len = sizeof(addr);
      传入&addr_len
  addrlen:传入传出参数，入：addr大小，出：客户端addr实际大小
  成功返回能与客户端进行数据通信的socket对应的文件描述符
      
  int connect(int sockfd,const struct sockaddr*addr,socklen_t addrlen);
  //addr：传入参数，服务器的地址结构
  //addrlen:服务器的地址结构大小
  返回值：
      成功0
      失败-1errno
  如果不使用bind绑定客户端地址结构，采用隐式绑定
  ```

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include<string.h>
  #include <sys/socket.h>
  #include <ctype.h>
  #include <arpa/inet.h>
  #include <unistd.h>
  #include <errno.h>
  #include <pthread.h>
  #define SERV_PORT 9527
  
  void sys_err(const char * str){
      perror(str);
      exit(1);
  }
  int main(int argc,char **argv){
      int lfd = 0,cfd = 0;
      char buf[BUFSIZ],CLIENT_IP[1024];
      lfd = socket(AF_INET,SOCK_STREAM,0);
      struct sockaddr_in serv_addr,client_addr;
      socklen_t client_len;
      int ret;
      serv_addr.sin_family = AF_INET;
      serv_addr.sin_port = htons(SERV_PORT);
      serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
      if(lfd == -1){
          sys_err("socket error");
      }
      bind(lfd,(struct sockaddr*)(&serv_addr),sizeof(serv_addr));
      listen(lfd,128);
      client_len = sizeof(client_addr);
      cfd = accept(lfd,(struct sockaddr*)(&client_addr),&client_len);
      if(cfd == -1){
          sys_err("accept error");
      }
      printf("client ip:%s port:%d\n",inet_ntop(AF_INET,&client_addr.sin_addr.s_addr,CLIENT_IP,sizeof(CLIENT_IP)),ntohs(client_addr.sin_port));
      int i;
      while(1){
          ret = read(cfd,buf,sizeof(buf));
          for(i = 0; i < ret; i++){
              buf[i] = toupper(buf[i]);
          }
          write(cfd,buf,ret);
      }
      close(cfd);
      close(lfd);
      return 0;
  }
  ```

  ```
  nc 127.0.0.1 9527
  ```

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include<string.h>
  #include <sys/socket.h>
  #include <ctype.h>
  #include <arpa/inet.h>
  #include <unistd.h>
  #include <errno.h>
  #include <pthread.h>
  
  #define SERV_PORT 9527
  
  void sys_err(const char *str) {
      perror(str);
      exit(1);
  }
  
  int main(int argc, char **argv) {
      int cfd;
      int counter = 10;
      char buf[BUFSIZ];
  
      struct sockaddr_in serv_addr;
      serv_addr.sin_family = AF_INET;
      serv_addr.sin_port = htons(SERV_PORT);
      inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr.s_addr);
      cfd = socket(AF_INET, SOCK_STREAM, 0);
      if (cfd == -1) {
          sys_err("socket error");
      }
      int ret;
      ret = connect(cfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
      if (ret != 0) {
          sys_err("connect error");
      }
      while (--counter) {
          write(cfd, "hello\n", 6);
          ret = read(cfd, buf, sizeof(buf));
          write(STDOUT_FILENO, buf, ret);
      }
      close(cfd);
      return 0;
  }
  ```

  

### 多进程并发服务器

* socket()创建监听套接字

* bind()绑定地址结构

* listen()

* while(1){

  cfd =accept()

  pid = fork();

  if(pid == 0){

  close(lfd)

  子进程read(cfd)->小->大 write(cfd)

  }else if(pid > 0){

  close(cfd);//关闭用于客户端通信的套接字cfd

  continue;

  }

  }

* 子进程：

  close(lfd)

  read()

  小--大

  write()

* 父进程

  close(cfd)

  注册信号捕捉函数 SIGCHLD

  在回调函数中完成子进程回收

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/socket.h>
  #include <ctype.h>
  #include <arpa/inet.h>
  #include <unistd.h>
  #include <errno.h>
  #include <sys/wait.h>
  #include <pthread.h>
  #include <signal.h>
  
  #define SERV_PORT 9999
  
  void sigchld(int arg) {
      while (waitpid(0, NULL, WNOHANG) > 0) {
      }
      return;
  }
  
  int main(int argc, char **argv) {
      int lfd, cfd;
      lfd = socket(AF_INET, SOCK_STREAM, 0);
      struct sockaddr_in serv_addr;
      serv_addr.sin_family = AF_INET;
      serv_addr.sin_port = htons(SERV_PORT);
      serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
      bind(lfd, (struct sockaddr *) (&serv_addr), sizeof(serv_addr));
      listen(lfd, 128);
      struct sockaddr_in client_addr;
      int client_addr_len = sizeof(client_addr);
  
      while (1) {
          cfd = accept(lfd, (struct sockaddr *) &client_addr, &client_addr_len);
  
          if (fork() == 0) {
              char buf[BUFSIZ];
              int ret, i;
              close(lfd);
              while (1) {
                  ret = read(cfd,buf,sizeof(buf));
                  if (ret == 0) {//read函数返回0说明对端已经关闭
                      //read 返回-1出错
                      //errno = EAGIN or EWOULDBLOCK 设置非阻塞方式，没有数据到达
                      //errno = EINTR 慢速系统调用被中断
                      //其他异常
                      close(cfd);
                      exit(1);
                  }
                  for (i = 0; i < ret; i++) {
                      buf[i] = toupper(buf[i]);
                  }
                  write(cfd, buf, ret);
                  write(STDOUT_FILENO, buf, ret);
              }
  
              break;
  
          } else {
              signal(SIGCHLD, sigchld);
              close(cfd);
  
              continue;
          }
      }
      return 0;
  }
  ```

  

### 多线程并发服务器

* socket()创建监听套接字

* bind()绑定地址结构

* listen()

* while(1){

cfd = Accept(lfd,)

pthread_create(&tid,NULL,tfn,NULL);

pthread_detach(tid);//pthread_join(tid,void**);新线程--专门回收子线程

}

* 子线程

  void *tfn(void *arg){

  read()   

  小--大

     write()

  }

  

```
scp -r ./test[本地目录] 用户名@101.200.170.171：/home/用户名/socket_server[远程目录]
```

```bash
netstat -apn | grep 8000 //查看8000号端口网络连接状态
```



### TCP状态时序图

1.主动发起连接请求端 CLOSE-- 发送SYN -- SEND_SYN --接收ACK,SYN--SEND_SYN ---发送ACK -- ESTABLISHED（数据通信态）

2.主动关闭连接请求端 ESTABLISHED（数据通信态）--发送FIN--FIN_WAIT1--接收ACK--FIN_WAIT2(半关闭)--接收端发送FIN--FIN_WAIT2（半关闭）--回发ACK--TIME_WAIT(2MSL)(只有主动关闭连接方会经历该状态）--CLOSE

3.被动接受连接请求端 CLOSE--LISTEN --接收SYN--LISTEN--发送SYN,ACK--SYN_RCVD--接收ACK--ESTABLISHED

4.被动关闭连接请求端：ESTABLISHED--接收FIN，发送ACK -- CLOSE_WAIT (对端处于半关闭状态)-- 发送FIN--LAST_ACK--接收ACK--CLOSE

* 2MSL时长

  保证最后一个ACK能被对端接收，（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求）



### 设置端口复用

```c
在socket和bind之间插入
int opt = 1;//设置端口复用，0/1
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR/*SO_REUSEPORT*/,&opt,sizeof(opt));

int getsockopt(int sockfd, int level, int optname,
                      void *optval, socklen_t *optlen);

int setsockopt(int sockfd, int level, int optname,
                      const void *optval, socklen_t optlen);
```

半关闭：通信双方，只有一端关闭通信 FIN_WAIT_2

close(cfd);

```c
int shutdown(int sockfd,int how);
how:
SHUT_RD
SHUT_WR
SHUT_RDWR
shutdown在关闭多个文件描述符引用的文件时，采用全关闭方法，close只关闭一个
```

### select多路IO转接

阻塞

非阻塞忙轮询

响应式--多路IO转接

```c
 #include <sys/select.h>
int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);
/*
nfds：监听的所有文件描述符中最大的文件描述符+1

传入传出参数：
readfds 读文件描述符监听集合，文件描述符指针，指向文件描述符表位图
writefds 写文件描述符监听集合 NULL
exceptfds 异常文件描述符监听集合 NULL
timeout

返回监听集合中，满足对应事件的的总数
0：没有满足监听条件的文件描述符
-1：error
    
timeout:定阻塞时间
    NULL:永远等待
    设置timeval,等待固定时间
    设置timeval里时间均为0，检查描述字后立即返回，轮询
*/
void FD_CLR(int fd, fd_set *set);
 int  FD_ISSET(int fd, fd_set *set);
 void FD_SET(int fd, fd_set *set);
 void FD_ZERO(fd_set *set);
```

原理：借助内核，select来监听，客户端连接，数据通信事件

```c
fd_set rset;
FD_ZERO(rset);

FD_SET(3,&rset);
FD_SET(5,&rset);
FD_SET(6,&rset);
FD_SET(5,&rset);
```

```c
lfd = socket(); //创建套接字
bind();//绑定地址结构
listen();//设置监听上限
fd_set rset,allset;//创建r监听集合
FD_ZERO(allset);//将r监听集合清空
FD_SET(lfd,&allset);//将lfd添加至读集合
while(1){
rset = allset;//保存监听集合
ret = select(lfd+1,&rset,NULL,NULL,NULL);//监听文件描述符集合对应事件
if(ret > 0){//有监听的描述符满足对应事件
    if(FD_ISSET(lfd, &rset)){//1在 0不在
        cfd = accept(); //建立连接，返回用于通信的文件描述符
        FD_SET(cfd,&allset);//添加到监听通信描述符集合中
    }
    for(i = lfd+1; i <= 最大文件描述符; i++){
        FD_ISSET(i,&rset);//有read,write事件
        read();
        小-->大
        write();
    }
}
}
```



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <pthread.h>
#include <signal.h>
#include <sys/select.h>

#define SERV_PORT 9999

int main(int argc, char **argv) {
    int lfd, cfd;
    lfd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(SERV_PORT);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int opt = 1;
    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));

    bind(lfd, (struct sockaddr *) (&serv_addr), sizeof(serv_addr));
    listen(lfd, 128);
    fd_set rset,allset;
    FD_ZERO(&allset);
    FD_SET(lfd,&allset);
    int maxfd = lfd;
    int num;
    struct sockaddr_in client_addr;
    int client_addr_len;
    int i,j;
    int len;
    char buf[BUFSIZ];
    while(1){
        rset = allset;
        num = select(maxfd+1,&rset,NULL,NULL,NULL);
        if(num < 0){
            perror("select error");
            exit(-1);
        }
        if(FD_ISSET(lfd, &rset)){
            client_addr_len = sizeof(client_addr);
            cfd = accept(lfd,(struct sockaddr*)&client_addr,&client_addr_len);
            FD_SET(cfd,&allset);
            if(cfd > maxfd)maxfd = cfd;
            if(--num)continue;
        }
        for(i = lfd+1; i <= maxfd; i++){
            if(FD_ISSET(i,&rset)){
                len = read(i,buf,sizeof(buf));
                if(len == 0){
                    FD_CLR(i,&allset);
                    close(i);
                    continue;
                }
                for(j = 0; j < len; j++){
                    buf[j] = toupper(buf[j]);
                }
                write(i,buf,len);
                write(STDOUT_FILENO,buf,len);
            }
        }

    }
    close(lfd);
    return 0;
}
```



select优缺点：

文件描述符数量有限，1024

检测满足条件的fd,自己添加业务逻辑提高小，提高了编码难度

优点，跨平台。

###  poll

```c
 #include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
fds:监听的文件描述符数组
struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */POLLIN POLLOUT POLLERR
               short revents;    /* returned events */传入是，给0，如果满足对应事件，返回非0
};
nfds:监听数组的实际有效的监听个数
timeout:超时时长 milliseconds
    -1 阻塞等待
    0 立即返回，不阻塞进程
    >0等待指定毫秒数
返回值：返回满足对应监听事件的文件描述符总个数
    if(client[0].revents & POLLIN){/*lfd有读事件就绪*/
        
    }
```

* read函数返回0说明对端已经关闭
  read 返回-1出错
  errno = EAGIN or EWOULDBLOCK 设置非阻塞方式，没有数据到达
  errno = EINTR 慢速系统调用被中断

  errno = ECONNRESET说明连接被重置，需要close()移除监听序列

  其他异常

* 优点：自带数组结构，可以将监听事件、返回事件集合分离，拓展监听上限，超出1024限制

* 缺点：不能跨平台，Linux,无法直接定位满足监听事件的文件描述符，编码难度大

### epoll

```c
#include <sys/epoll.h>
int epoll_create(int size);
size:创建的红黑树监听结点数量(仅供参考)
返回值：指向新创建的红黑树根节点的fd
    失败-1，errno
    
 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    epfd:epoll_create函数返回值，epfd
    op：对红黑树的操作  EPOLL_CTL_ADD  EPOLL_CTL_MOD  EPOLL_CTL_DEL
    event:本质上是一个struct epoll_event结构体地址
        events:
                EPOLLIN EPOLLOUT  EPOLLERR
        data：联合体
              int fd;对应监听事件的fd
    成功0，失败-1 errno
    typedef union epoll_data {
               void        *ptr;
               int          fd;
               uint32_t     u32;//不用
               uint64_t     u64;
    } epoll_data_t;

    struct epoll_event {
               uint32_t     events;      /* Epoll events */
               epoll_data_t data;        /* User data variable */
     };

 int epoll_wait(int epfd, struct epoll_event *events,
                      int maxevents, int timeout);//阻塞监听
     epfd:epoll_create返回值，epfd
     events:数组，传出参数，传出满足监听条件的fd结构体
     maxevents:数组元素的总个数
     timeout:同poll
     返回值
         >0 满足监听的总个数，可用作循环上限
         0 没有fd满足监听事件
         失败-1 errno
```

```
cat /proc/sys/fs/file-max 当前计算机所能打开的最大文件个数，受硬件影响
ulimit -a 当前用户下进程默认打开文件描述符个数，缺省为1024
修改文件描述符上限
sudo vi /ect/security/limits.conf
修改：
 * soft nofile 65535-->设置默认值， 可以通过形如ulimit -n 20000命令修改
 * hard nofile 1000000--》命令修改上限
```

显著提高程序中大量并发连接中只有少量活跃的情况下的系统cpu利用率

Epoll事件模型

ET边沿触发，只有数据到来才触发，不管缓存区是否还有数据

LT水平触发，只要有数据都会触发--默认采用模式(缓存区剩余未读尽数据会导致epoll_wait返回)



```c
改边沿触发 event.events = EPOLLIN | EPOLLET;
```

LT是缺省的工作方式，同时支持block unblock socket,传统的select poll都是这种模型代表

ET是高速工作方式，仅支持no-block socket,忙轮询

```c
struct epoll_event event;
event.events = EPOLLIN | EPOLLET;
epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&event);
int flag = fcntl(cfd,F_GETFL);
flag |= O_NONBLOCK;
fcntl(cfd,F_SETFL,flag);
```

优点：高效，突破1024文件描述符,事件分离

缺点：不能跨平台Linux

### epoll反应堆模型

epoll ET 模式+非阻塞+void*ptr

不但要监听cfd的读事件，还要监听cfd的写事件



```c
__func__ 打印函数名
__LINE__行号
```

```c
/*
 *epoll基于非阻塞I/O事件驱动
 */
#include <stdio.h>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define MAX_EVENTS  1024                                    //监听上限数
#define BUFLEN 4096
#define SERV_PORT   8080

void recvdata(int fd, int events, void *arg);
void senddata(int fd, int events, void *arg);

/* 描述就绪文件描述符相关信息 */

struct myevent_s {
    int fd;                                                 //要监听的文件描述符
    int events;                                             //对应的监听事件
    void *arg;                                              //泛型参数
    void (*call_back)(int fd, int events, void *arg);       //回调函数
    int status;                                             //是否在监听:1->在红黑树上(监听), 0->不在(不监听)
    char buf[BUFLEN];
    int len;
    long last_active;                                       //记录每次加入红黑树 g_efd 的时间值
};

int g_efd;                                                  //全局变量, 保存epoll_create返回的文件描述符
struct myevent_s g_events[MAX_EVENTS+1];                    //自定义结构体类型数组. +1-->listen fd


/*将结构体 myevent_s 成员变量 初始化*/

void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)
{
    ev->fd = fd;
    ev->call_back = call_back;
    ev->events = 0;
    ev->arg = arg;
    ev->status = 0;
    memset(ev->buf, 0, sizeof(ev->buf));
    ev->len = 0;
    ev->last_active = time(NULL);                       //调用eventset函数的时间

    return;
}

/* 向 epoll监听的红黑树 添加一个 文件描述符 */

//eventadd(efd, EPOLLIN, &g_events[MAX_EVENTS]);
void eventadd(int efd, int events, struct myevent_s *ev)
{
    struct epoll_event epv = {0, {0}};
    int op;
    epv.data.ptr = ev;
    epv.events = ev->events = events;       //EPOLLIN 或 EPOLLOUT

    if (ev->status == 0) {                                          //已经在红黑树 g_efd 里
        op = EPOLL_CTL_ADD;                 //将其加入红黑树 g_efd, 并将status置1
        ev->status = 1;
    }

    if (epoll_ctl(efd, op, ev->fd, &epv) < 0)                       //实际添加/修改
        printf("event add failed [fd=%d], events[%d]\n", ev->fd, events);
    else
        printf("event add OK [fd=%d], op=%d, events[%0X]\n", ev->fd, op, events);

    return ;
}

/* 从epoll 监听的 红黑树中删除一个 文件描述符*/

void eventdel(int efd, struct myevent_s *ev)
{
    struct epoll_event epv = {0, {0}};

    if (ev->status != 1)                                        //不在红黑树上
        return ;

    //epv.data.ptr = ev;
    epv.data.ptr = NULL;
    ev->status = 0;                                             //修改状态
    epoll_ctl(efd, EPOLL_CTL_DEL, ev->fd, &epv);                //从红黑树 efd 上将 ev->fd 摘除

    return ;
}

/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */

void acceptconn(int lfd, int events, void *arg)
{
    struct sockaddr_in cin;
    socklen_t len = sizeof(cin);
    int cfd, i;

    if ((cfd = accept(lfd, (struct sockaddr *)&cin, &len)) == -1) {
        if (errno != EAGAIN && errno != EINTR) {
            /* 暂时不做出错处理 */
        }
        printf("%s: accept, %s\n", __func__, strerror(errno));
        return ;
    }

    do {
        for (i = 0; i < MAX_EVENTS; i++)                                //从全局数组g_events中找一个空闲元素
            if (g_events[i].status == 0)                                //类似于select中找值为-1的元素
                break;                                                  //跳出 for

        if (i == MAX_EVENTS) {
            printf("%s: max connect limit[%d]\n", __func__, MAX_EVENTS);
            break;                                                      //跳出do while(0) 不执行后续代码
        }

        int flag = 0;
        if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) < 0) {             //将cfd也设置为非阻塞
            printf("%s: fcntl nonblocking failed, %s\n", __func__, strerror(errno));
            break;
        }

        /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */
        eventset(&g_events[i], cfd, recvdata, &g_events[i]);   
        eventadd(g_efd, EPOLLIN, &g_events[i]);                         //将cfd添加到红黑树g_efd中,监听读事件

    } while(0);

    printf("new connect [%s:%d][time:%ld], pos[%d]\n", 
            inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);
    return ;
}

void recvdata(int fd, int events, void *arg)
{
    struct myevent_s *ev = (struct myevent_s *)arg;
    int len;

    len = recv(fd, ev->buf, sizeof(ev->buf), 0);            //读文件描述符, 数据存入myevent_s成员buf中

    eventdel(g_efd, ev);        //将该节点从红黑树上摘除

    if (len > 0) {

        ev->len = len;
        ev->buf[len] = '\0';                                //手动添加字符串结束标记
        printf("C[%d]:%s\n", fd, ev->buf);

        eventset(ev, fd, senddata, ev);                     //设置该 fd 对应的回调函数为 senddata
        eventadd(g_efd, EPOLLOUT, ev);                      //将fd加入红黑树g_efd中,监听其写事件

    } else if (len == 0) {
        close(ev->fd);
        /* ev-g_events 地址相减得到偏移元素位置 */
        printf("[fd=%d] pos[%ld], closed\n", fd, ev-g_events);
    } else {
        close(ev->fd);
        printf("recv[fd=%d] error[%d]:%s\n", fd, errno, strerror(errno));
    }

    return;
}

void senddata(int fd, int events, void *arg)
{
    struct myevent_s *ev = (struct myevent_s *)arg;
    int len;

    len = send(fd, ev->buf, ev->len, 0);                    //直接将数据 回写给客户端。未作处理

    eventdel(g_efd, ev);                                //从红黑树g_efd中移除

    if (len > 0) {

        printf("send[fd=%d], [%d]%s\n", fd, len, ev->buf);
        eventset(ev, fd, recvdata, ev);                     //将该fd的 回调函数改为 recvdata
        eventadd(g_efd, EPOLLIN, ev);                       //从新添加到红黑树上， 设为监听读事件

    } else {
        close(ev->fd);                                      //关闭链接
        printf("send[fd=%d] error %s\n", fd, strerror(errno));
    }

    return ;
}

/*创建 socket, 初始化lfd */

void initlistensocket(int efd, short port)
{
    struct sockaddr_in sin;

    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            //将socket设为非阻塞

	memset(&sin, 0, sizeof(sin));                                               //bzero(&sin, sizeof(sin))
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = htons(port);

	bind(lfd, (struct sockaddr *)&sin, sizeof(sin));

	listen(lfd, 20);

    /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */
    eventset(&g_events[MAX_EVENTS], lfd, acceptconn, &g_events[MAX_EVENTS]);

    /* void eventadd(int efd, int events, struct myevent_s *ev) */
    eventadd(efd, EPOLLIN, &g_events[MAX_EVENTS]);

    return ;
}

int main(int argc, char *argv[])
{
    unsigned short port = SERV_PORT;

    if (argc == 2)
        port = atoi(argv[1]);                           //使用用户指定端口.如未指定,用默认端口

    g_efd = epoll_create(MAX_EVENTS+1);                 //创建红黑树,返回给全局 g_efd 
    if (g_efd <= 0)
        printf("create efd in %s err %s\n", __func__, strerror(errno));

    initlistensocket(g_efd, port);                      //初始化监听socket

    struct epoll_event events[MAX_EVENTS+1];            //保存已经满足就绪事件的文件描述符数组 
	printf("server running:port[%d]\n", port);

    int checkpos = 0, i;
    while (1) {
        /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */

        long now = time(NULL);                          //当前时间
        for (i = 0; i < 100; i++, checkpos++) {         //一次循环检测100个。 使用checkpos控制检测对象
            if (checkpos == MAX_EVENTS)
                checkpos = 0;
            if (g_events[checkpos].status != 1)         //不在红黑树 g_efd 上
                continue;

            long duration = now - g_events[checkpos].last_active;       //客户端不活跃的世间

            if (duration >= 60) {
                close(g_events[checkpos].fd);                           //关闭与该客户端链接
                printf("[fd=%d] timeout\n", g_events[checkpos].fd);
                eventdel(g_efd, &g_events[checkpos]);                   //将该客户端 从红黑树 g_efd移除
            }
        }

        /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/
        int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);
        if (nfd < 0) {
            printf("epoll_wait error, exit\n");
            break;
        }

        for (i = 0; i < nfd; i++) {
            /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/
            struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;  

            if ((events[i].events & EPOLLIN) && (ev->events & EPOLLIN)) {           //读就绪事件
                ev->call_back(ev->fd, events[i].events, ev->arg);
                //lfd  EPOLLIN  
            }
            if ((events[i].events & EPOLLOUT) && (ev->events & EPOLLOUT)) {         //写就绪事件
                ev->call_back(ev->fd, events[i].events, ev->arg);
            }
        }
    }

    /* 退出前释放所有资源 */
    return 0;
}

```

```
ctags
ctags ./* -R
Ctrl + ] 光标置于调用函数上，跳转至函数定义位置
Ctrl + t 返回到此前跳转位置
Ctrl+ o 在屏幕左边列出文件列表，再次ctrl+o关闭
F4在屏幕右边列出文件列表，再次F4关闭
```

### 线程池

1.main()

   创建线程池

   向线程池添加任务，借助回调处理任务

   销毁线程池

2.pthreadpool_create()

   创建线程池结构体指针

   初始化线程池结构体

 创建N个任务线程

创建一个管理线程

失败时销毁开辟的所有空间（释放）

```c
typedef struct {
    void *(*function)(void *);          /* 函数指针，回调函数 */
    void *arg;                          /* 上面函数的参数 */
} threadpool_task_t;                    /* 各子线程任务结构体 */

/* 描述线程池相关信息 */

struct threadpool_t {
    pthread_mutex_t lock;               /* 用于锁住本结构体 */    
    pthread_mutex_t thread_counter;     /* 记录忙状态线程个数de琐 -- busy_thr_num */

    pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */
    pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */

    pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */
    pthread_t adjust_tid;               /* 存管理线程tid */
    threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */

    int min_thr_num;                    /* 线程池最小线程数 */
    int max_thr_num;                    /* 线程池最大线程数 */
    int live_thr_num;                   /* 当前存活线程个数 */
    int busy_thr_num;                   /* 忙状态线程个数 */
    int wait_exit_thr_num;              /* 要销毁的线程个数 */

    int queue_front;                    /* task_queue队头下标 */
    int queue_rear;                     /* task_queue队尾下标 */
    int queue_size;                     /* task_queue队中实际任务数 */
    int queue_max_size;                 /* task_queue队列可容纳任务数上限 */

    int shutdown;                       /* 标志位，线程池使用状态，true或false */
};

```

3.threadpool_thread()

进入子进程回调函数

接收参数 void *arg ->pool 结构体

加锁->lock->整个结构体锁

判断条件变量 wait 

4.adjust_thread()

循环10秒执行一次

进入管理者线程回调函数

接收参数 void *arg ->pool 结构体

加锁->lock->整个结构体锁

获取管理线程池需要的变量

根据既定算法，使用上述变量，判断是否应该创建、销毁线程池中指定步长的线程

5.threadpool_add()

模拟产生任务，num[20]

设置回调函数，处理任务

内部实现：

加锁

初始化任务队列结构体成员，回调函数function arg

利用环形队列机制，实现添加任务，借助队尾指针挪移实现

唤醒阻塞在条件变量上的线程

解锁

6.从3.中的wait之后继续执行，处理任务

加锁

获取任务处理回调函数，及参数

利用环形队列机制，实现处理任务，借助队头指针挪移%实现

唤醒阻塞在条件变量上的server

解锁

加锁

改忙线程数++

解锁

执行处理任务的线程

加锁

改忙线程数--

解锁

7.创建销毁线程

管理者线程 task_num,live_num,busy_num

根据既定算法，使用上述变量判断是否应该创建、销毁线程池中指定步长的线程

如果满足创建条件

pthread_create() 回调任务线程函数 live_num++

如果满足销毁条件

wait_exit_thr_num = 10;

signal给阻塞在条件变量上的线程发送假满足信号

阻塞线程会被假信号唤醒，wait_exit_thr_num pthread_exit()

### TCP UDP各自优缺点

TCP:面向连接的，可靠数据传输 对不稳定的网络层，采取完全弥补的通信方式，丢包重传

优点：稳定，数据流量稳定，速度稳定，顺序稳定

缺点：传输速度慢，效率低，开销大

使用场景：数据完整性要求较高，不追求效率

​                   大数据传输，文件传输

UDP:无连接，不可靠数据报传递 对于不稳定的网络层，采取完全不弥补的通信方式，默认还原网络状况

优点：传输速度快，效率高，开销低

缺点：不稳定

使用场景：对时效性要求较高，稳定性其次

游戏、视频会议，视频电话 应用层数据校验协议，弥补udp的不足

### UDP服务器

UDP实现的C/S模型

```c
accept(),connec()被舍弃
recv()/send()只能用于TCP通信，替代read/write
server:
        lfd =  socket(AF_INET,STREAM,0);SOCK_DGRAM报式协议
        bind()
        listen()可有可无
        while(1){
            read(cfd,buf,)被替换--recvfrom()
            小-大
            write()被替换--sendto()
        }
client:
       connfd = socket(AF_INET,SOCK_DGRAM,0)
       sendto('服务器地址结构'，地址结构大小)
       recvfrom()
       close()

```



```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
sockfd:套接字
buf:缓存区地址
len缓存区大小
flags:0默认值
src_addr：(struct sockaddr*)&addr;传出。对端地址结构
addrlen:传入传出
返回值：
    成功接收数据字节数，-1失败，0对端关闭

 ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
sockfd:套接字
buf:存储数据的缓存区地址
len 数据长度
flags:0默认值
src_addr：(struct sockaddr*)&addr;传出。目标地址结构
addrlen:地址结构长度
返回值：
    成功写出数据字节数，-1失败，0对端关闭
```

```c
server
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>

#define SERV_PORT 8000

int main(void)
{
    struct sockaddr_in serv_addr, clie_addr;
    socklen_t clie_addr_len;
    int sockfd;
    char buf[BUFSIZ];
    char str[INET_ADDRSTRLEN];
    int i, n;

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    bzero(&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(SERV_PORT);

    bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

    printf("Accepting connections ...\n");
    while (1) {
        clie_addr_len = sizeof(clie_addr);
        n = recvfrom(sockfd, buf, BUFSIZ,0, (struct sockaddr *)&clie_addr, &clie_addr_len);
        if (n == -1)
            perror("recvfrom error");

        printf("received from %s at PORT %d\n",
                inet_ntop(AF_INET, &clie_addr.sin_addr, str, sizeof(str)),
                ntohs(clie_addr.sin_port));

        for (i = 0; i < n; i++)
            buf[i] = toupper(buf[i]);

        n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&clie_addr, sizeof(clie_addr));
        if (n == -1)
            perror("sendto error");
    }

    close(sockfd);

    return 0;
}


```



```c
client
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>

#define SERV_PORT 8000

int main(int argc, char *argv[])
{
    struct sockaddr_in servaddr;
    int sockfd, n;
    char buf[BUFSIZ];

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr);
    servaddr.sin_port = htons(SERV_PORT);

    bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr));

    while (fgets(buf, BUFSIZ, stdin) != NULL) {
        n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&servaddr, sizeof(servaddr));
        if (n == -1)
            perror("sendto error");

        n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0);         //NULL:不关心对端信息
        if (n == -1)
            perror("recvfrom error");

        write(STDOUT_FILENO, buf, n);
    }

    close(sockfd);

    return 0;
}


```



### 本地套接字

（domain)

对比TCP C/S模型，注意

```c
1.int socket(int domain, int type, int protocol); domain AF_INET-->AF_UNIX/AF_LOCAL
                                                type SOCK_STREM/SOCK_DGRAM都可以
2.地址结构：sockaddr_in-->sockaddr_un
    
struct sockaddr_un addr;
struct sockaddr_un{
    __kernel_sa_family_t sum_family;
    char sun_path[UNIX_PATH_MAX];
};
addr.sun_family = AF_UNIX;
strcpy(addr.sun_path,"srv.socket");
3.bind();
bind(fd,(struct sockaddr*)&addr,offsetof(struct sockaddr_un,sun_path)+strlen("srv.socket"));
bind()函数调用成功会创建一个socket文件,因此为保证bind成功，通常我们再bind之前,可以使用unlink
4.客户端不能依赖隐式绑定，并且应该在通信建立过程中，创建并初始化2个地址结构
    client_addr bind()
    server_addr connect()
```



```c
server
#include <sys/un.h>
#include <stddef.h>

#include "wrap.h"

#define SERV_ADDR  "serv.socket"

int main(void)
{
    int lfd, cfd, len, size, i;
    struct sockaddr_un servaddr, cliaddr;
    char buf[4096];

    lfd = Socket(AF_UNIX, SOCK_STREAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sun_family = AF_UNIX;
    strcpy(servaddr.sun_path, SERV_ADDR);

    len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);     /* servaddr total len */

    unlink(SERV_ADDR);                              /* 确保bind之前serv.sock文件不存在,bind会创建该文件 */
    Bind(lfd, (struct sockaddr *)&servaddr, len);           /* 参3不能是sizeof(servaddr) */

    Listen(lfd, 20);

    printf("Accept ...\n");
    while (1) {
        len = sizeof(cliaddr);  //AF_UNIX大小+108B

        cfd = Accept(lfd, (struct sockaddr *)&cliaddr, (socklen_t *)&len);

        len -= offsetof(struct sockaddr_un, sun_path);      /* 得到文件名的长度 */
        cliaddr.sun_path[len] = '\0';                       /* 确保打印时,没有乱码出现 */

        printf("client bind filename %s\n", cliaddr.sun_path);

        while ((size = read(cfd, buf, sizeof(buf))) > 0) {
            for (i = 0; i < size; i++)
                buf[i] = toupper(buf[i]);
            write(cfd, buf, size);
        }
        close(cfd);
    }
    close(lfd);

    return 0;
}

```



```c
client.c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>         
#include <sys/socket.h>
#include <strings.h>
#include <string.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <stddef.h>

#include "wrap.h"

#define SERV_ADDR "serv.socket"
#define CLIE_ADDR "clie.socket"

int main(void)
{
    int  cfd, len;
    struct sockaddr_un servaddr, cliaddr;
    char buf[4096];

    cfd = Socket(AF_UNIX, SOCK_STREAM, 0);

    bzero(&cliaddr, sizeof(cliaddr));
    cliaddr.sun_family = AF_UNIX;
    strcpy(cliaddr.sun_path,CLIE_ADDR);

    len = offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path);     /* 计算客户端地址结构有效长度 */

    unlink(CLIE_ADDR);
    Bind(cfd, (struct sockaddr *)&cliaddr, len);                                 /* 客户端也需要bind, 不能依赖自动绑定*/

    
    bzero(&servaddr, sizeof(servaddr));                                          /* 构造server 地址 */
    servaddr.sun_family = AF_UNIX;
    strcpy(servaddr.sun_path, SERV_ADDR);

    len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);   /* 计算服务器端地址结构有效长度 */

    Connect(cfd, (struct sockaddr *)&servaddr, len);

    while (fgets(buf, sizeof(buf), stdin) != NULL) {
        write(cfd, buf, strlen(buf));
        len = read(cfd, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);
    }

    close(cfd);

    return 0;
}

```



对比本地套 和 网络套。
					网络套接字						本地套接字

	server：	lfd = socket(AF_INET, SOCK_STREAM, 0);			lfd = socket(AF_UNIX, SOCK_STREAM, 0);
		
			bzero() ---- struct sockaddr_in serv_addr;		 bzero() ---- struct sockaddr_un serv_addr, clie_addr;
	
			serv_addr.sin_family = AF_INET;				       serv_addr.sun_family = AF_UNIX;	
			serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
			serv_addr.sin_port = htons(8888);			       strcpy（serv_addr.sun_path, "套接字文件名"）
										                     len = offsetof(sockaddr_un, sun_path) + strlen();


​										
​	        bind(lfd, (struct sockaddr *)&serv_addr, sizeof()); 	unlink("套接字文件名");
​									                      	bind(lfd, (struct sockaddr *)&serv_addr, len);  创建新文件
​	
			Listen(lfd, 128);					           Listen(lfd, 128);
	
			cfd = Accept(lfd, ()&clie_addr, &len);			cfd = Accept(lfd, ()&clie_addr, &len);  


	client：		
			lfd = socket(AF_INET, SOCK_STREAM, 0);			lfd = socket(AF_UNIX, SOCK_STREAM, 0);
	
			" 隐式绑定 IP+port"					              bzero() ---- struct sockaddr_un clie_addr;
										                      clie_addr.sun_family = AF_UNIX;
										                    strcpy（clie_addr.sun_path, "client套接字文件名"）
										                     len = offsetof(sockaddr_un, sun_path) + strlen();
										                   unlink( "client套接字文件名");
										                   bind(lfd, (struct sockaddr *)&clie_addr, len);
	
			bzero() ---- struct sockaddr_in serv_addr;		bzero() ---- struct sockaddr_un serv_addr;
	
			serv_addr.sin_family = AF_INET;				          serv_addr.sun_family = AF_UNIX;
																	
			inet_pton(AF_INT, "服务器IP", &sin_addr.s_addr)							
										                     strcpy（serv_addr.sun_path, "server套接字文件名"）
			serv_addr.sin_port = htons("服务器端口");		
										
										                        len = offsetof(sockaddr_un, sun_path) + strlen();
	
			connect(lfd, &serv_addr, sizeof());			             connect(lfd, &serv_addr, len);

### libevent库

开源、精简、跨平台、专注于网络通信

源码包安装：

./configure 检查安装环境生成makefile

make 生成.o文件和可执行文件

sudo make install 将必要的资源cp至系统指定目录

进入sample 目录，运行demo

编译使用库的.c文件时，需要加-levent

库名 libevent.so  /usr/local/lib `ll libevent*`

#### libevent框架

创建event_base

```c
struct event_base*event_base_new(void);
struct event_base*base = event_base_new();
```



创建事件event

​        常规事件 `event_new();`

​        bufferevent `bufferevent_socket_new();`

将事件添加到base上

 ```c
 int event_add(struct event*ev,const struct timeval *tv);
 ```



循环监听事件满足

```c
int event_base_dispatch(struct event_base * base);
```



释放event_base

```c
event_base_free(base);
```

特性：基于`事件`的异步通信模型--回调

* 启动循环

  ```c
  int event_base_dispatch(struct event_base * base);
  只有event_new指定了EV_PERSIST才持续触发，否则只触发一次就跳出循环
  EV_WRITE|EV_PERSIST、 EV_READ|EV_PERSIST
  ```

* 其他循环：

  ```c
  int event_base_loopexit(struct event_base*base,const struct timeval *tv);
  在指定时间后停止循环
     
      
  int event_base_loopbreak(struct event_base*base);
  立即停止循环
  ```

* 查看支持哪些多路IO

  ```c
  const char **event_get_supported_methods(void);
  ```

* 查看当前用的多路IO

  ```c
  const char * event_base_get_method(const struct event_base*base);
  ```

* 查看fork后子进程使用的event_base

  ```c
  int event_reinit(struct event_base *base);
  ```

  使用该函数后，父进程创建的base才能在子进程中使用





#### 常规事件

创建事件

```c
struct event *event_new(struct event_base*base,evutil_socket_t fd,short what,event_callback_fn cb,void*arg);
base :event_base_new()返回值
   fd:绑定到event上的文件描述符
 what:对应的事件（读、写、异常）
     EV_READ
     EV_WRITE
     EV_PERSIST持续触发，结合event_base_dispatch函数使用，生效
 cb:一旦事件满足监听条件，回调的函数
 arg:回调函数的参数
 返回值：成功创建的event
     
 typedef void (*event_callback_fn)(evutil_socket_t fd,short,void *);
```

添加事件到event_base

```c
int event_add(struct event * ev, const struct timeval *tv);
tv：NULL,添加的事件不会超时
    否则，tv以秒和微秒指定超时值
```

从event_base摘下事件

```c
int event_del(struct event *ev);
```



销毁事件

```c
int event_free(struct event *ev);
```

* 未决和非未决

  未决：有资格被处理，但还没有处理

  非未决：没有资格被处理

#### bufferevent

```c
#include <event2/bufferevent.h>
```

带buf的事件对象

原理：bufferevent有两个缓存区，也是队列实现。先进先出，只能读一次

读：有数据-->读回调函数被调用-->使用bufferevent_read()读数据

写：使用bufferevent_write()-->向缓冲区写数据-->该缓存区有数据自动写出-->写完，回调函数被调用，通知写数据完成

用bufferevent_read()来从读缓存中读数据。替代read()功能

* 创建bufferevent

```c
struct bufferevent* bufferevent_socket_new(struct event_base*base,evutil_socket_t fd,enum bufferevent_options);
fd:跟bufferevent绑定的文件描述符
options:BEV_OPT_CLOSE_ON_FREE  
返回：成功创建的bufferevent事件对象
```

* 释放

  ```c
  void bufferevent_free(struct bufferevent *bev);
  ```

* 给bufferevent设置回调

  ```c
  void bufferevent_setcb(struct bufferevent *bufev,bufferevent_data_cb readcb,bufferevent_data_cb writecb,bufferevent_event_cb eventcb,void *cbarg);
  readcb：设置读缓冲回调 read_cb{bufferevent_read()读数据}
  writecb:设置写缓冲回调，发送写成功通知 给调用者 可以为NULL
  typedef void (*bufferevent_event_cb)(struct bufferevent*bev,short events,void *ctx);
  
  events:BEV_EVENT_CONNECTED请求的连接过程已经完成，实现客户端可用
  eventcb:设置事件回调，也可传NULL
  cbarg:上述回调函数参数
      
  typedef void (*bufferevent_data_cb)(struct bufferevent *bev,void * ctx);
  
  size_t bufferevent_read(struct bufferevent * bev,void * buf,size_t bufsize);
  
  size_t bufferevent_write(struct bufferevent * bev,const void * buf,size_t bufsize);
  
  ```

* 禁用、启用缓冲区

  默认：新建bufferevent写缓冲是enable的，而读缓冲是disable的

```c
void bufferevent_enable(struct bufferevent * bufev,short events);//启用缓冲区
void bufferevent_disable(struct bufferevent * bufev,short events);//禁用
events: EV_READ EV_WRITE EV_READ|EV_WRITE
short bufferevent_get_enable(struct bufferevent * bufev);//获取缓冲区禁用状态
```

客户端

socket() connect()

```c
int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address,int addrlen);
address、len connect()第2，3个参数
```



监听服务器：

socket() bind()listen()accept()

```c
struct evconnlistener *evconnlistener_new(
    struct event_base * base;
    evconnlistener_cb cb,
    void *ptr,
    unsigned flags,
    int backlog,
    evutil_socket_t fd
);
struct evconnlistener *evconnlistener_new_bind(
    struct event_base * base;
     evconnlistener_cb cb,
    void *ptr,
    unsigned flags,
    int backlog,
    const struct sockaddr *sa,
    int socklen
);
flags:可识别的标志
    LEV_OPT_CLOSE_ON_FREE：释放bufferevent时关闭底层传输端口，这将关闭底层套接字，释放底层bufferevent等
    LEV_OPT_REUSEABLE端口复用，可以用|
backlog:listen第2个参数，传-1：表默认最大值
sa:服务器自己的地址结构IP+Port
socklen:sa的长度
socket bind listen accept
返回值：成功创建的监听器

typedef void (*evconnlistener_cb)(
    struct evconnlistener *listener,
    evutil_socket_t sock,
    struct sockaddr *addr,
    int len,
    void*ptr
);
listener:evconnlistener_new_bind返回值
sock:用于通信的文件描述符
addr:客户端IP+addr
len:addr的len
ptr:外部ptr传递进来值

```

释放监听服务器：

```c
void evconnlistener_free(struct evconnlistener*lev);
```

服务器

1.创建一个event_base

2.创建一个bufferevent事件对象 bufferevent_socket_new();

3.使用bufferevent_setcb()给read,write,event设置回调，

4.当监听的事件满足时，read_cb会被调用，在其内部bufferevent_read()读

5.创建一个监听服务器evconnlistener_new_bind(),设置其回调函数，当有客户端成功连接时，这个回调函数会被调用

6.listener_cb()在函数内部完成与客户端通信

7.设置bufferevent的读写缓冲区enable、disable

8.启动循环，event_base_dispatch

9.释放资源

客户端

1.创建event_base

2.使用bufferevent_socket_new()创建一个用于跟服务器通信的bufferevent事件对象

3.使用bufferevent_socket_connect()连接服务器

4.使用buffer_setcb()给bufferevent对象的readcb,writecb,eventcb设置回调

5.设置bufferevent对象的读写缓冲区

6.接收、发送数据 bufferevent_read() bufferevent_write()

7.启动循环监听event_base_dispath()

8.释放资源



### HTTP协议

#### 请求消息

* 请求行
* 请求头
* 空行（必须要有）
* 请求数据

GET:

请求指定页面信息，并返回实体主体

POST:

向指定资源提交数据进行处理请求，数据被包含在请求体中。POST请求可能导致新的资源建立或已有资源修改

```
GET  /hello.c HTTP/1.1

```

### 应答消息

* 状态行：包括协议版本号，状态码，状态信息
* 消息报头
* 空行：必须要有
* 响应正文



`telnet`调试

`telnet 127.0.0.1 9999`

GET /hello.c HTTP/1.1
