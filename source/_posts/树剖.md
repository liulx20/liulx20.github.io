---
title: 树剖
date: 2021-07-01 17:02:10
tags:
---

### [POJ 2763](http://poj.org/problem?id=2763)

* 题意

  给一棵边带权树，给定一个初始位置`s`

  有两种操作：

  a. 从位置s转移到位置u,输出s->u距离

  b.修改某一条边的权重

* 树剖，将树序列化

  将边权转移到点上
  
  树状数组支持单点修改
  
  区间查询

```c++
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <iostream>
#include <map>

using namespace std;
int dist[100005];
int sz[100004];
int son[100004];
int fa[100005];
int dep[100005];
vector<pair<int,int> >G[100004];
int n,q,s;

void dfs(int x,int f,int d)
{
    dist[x] = d;
    fa[x] = f;
    sz[x] = 1;
    dep[x] = (f <0 ? 0:dep[f]+1);
    son[x] = -1;
    for(int i = 0; i < G[x].size(); i++)
    {
        pair<int,int> a = G[x][i];
        if(a.first != f)
        {
            dfs(a.first,x,d+a.second);
            sz[x] += sz[a.first];
            if(son[x] == -1 || sz[son[x]] < sz[a.first])
            {
                son[x] = a.first;
            }
        }
    }
}
int top[100003];
int id[100004];
int rev[100003];
int w[100003];
void add(int i,int x)
{
    for(; i <= 100000; i+= (i&-i))
    {
        w[i] += x;
    }
}
int ask(int i)
{
    int ans = 0;
    for(; i > 0; i -= (i&-i))
    {
        ans += w[i];
    }
    return ans;
}
int k = 1;
void dfs1(int x,int f)
{
    top[x] = (f < 0 ? x:(son[f] == x ? top[f]:x));
    id[x] = k;
    rev[k++] = x;
    if(son[x] > 0)
    {
        dfs1(son[x],x);
        add(id[son[x]],dist[son[x]] - dist[x]);
    }
    for(int i = 0; i < G[x].size(); i++)
    {
         pair<int,int> a = G[x][i];
        if(a.first != f && a.first != son[x])
        {
            dfs1(a.first,x);
            add(id[a.first],a.second);
        }
    }
}
map<int,pair<pair<int,int>,int> > mp;
int main()
{
    int x,y,v,w;
    scanf("%d%d%d",&n,&q,&s);
    for(int i = 1; i < n; i++)
    {
        scanf("%d%d%d",&x,&y,&v);
        G[x].push_back(make_pair(y,v));
        G[y].push_back(make_pair(x,v));
        mp[i] = make_pair(make_pair(x,y),v);
    }
    dfs(s,-1,0);
    dfs1(s,-1);
    while(q--)
    {
        scanf("%d",&x);
        if(x == 1)
        {
            scanf("%d%d",&y,&v);
            pair<int,int> u = mp[y].first;
            int g = mp[y].second;
            int o;
            if(dep[u.first] > dep[u.second]){
                o = u.first;
            }else o = u.second;

            add(id[o],-mp[y].second);
            mp[y].second = v;
            add(id[o],v);

        }
        else
        {
            scanf("%d",&y);
            int nxt = y;
            int ans = 0;
            while(true)
            {
                
                if(top[s] == top[y])
                {
                    if(dep[s] < dep[y])
                    {
                        ans += ask(id[y]) - ask(id[s]);
                        cout << ans << '\n';
                    }
                    else
                    {
                        ans += ask(id[s]) - ask(id[y]);
                        cout << ans << '\n';
                    }
                    break;
                }
                //比较的是top[x] top[y]的深度
                if(dep[top[s]] < dep[top[y]]){
                    ans += ask(id[y])- ask(id[top[y]]-1);
                    y = fa[top[y]];
                
                }else{
                    ans += ask(id[s]) - ask(id[top[s]]-1);
                    s = fa[top[s]];
                }
            }
            s = nxt;
        }
    }
}
/**
5 100 1
1 2 5
1 3 2
3 4 5
3 5 4
0 3
0 2
**/

```



### [POJ 3237](http://poj.org/problem?id=3237)

* 给一棵带权树，实现三种操作
  * 修改某一条边的权值
  * 将路径u->v上所有边的权值取相反数
  * 查询路径u->v上权值最大的边
* 树链剖分
* 线段树维护单点修改，区间取反
* 注意懒标下传、上传

```C++
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <iostream>
#include <map>
using namespace std;
int dist[10005];
int sz[10004];
int son[10004];
int fa[10005];
int dep[10005];
vector<pair<int,int> >G[10004];
int n;

void dfs(int x,int f,int d)
{
    dist[x] = d;
    fa[x] = f;
    sz[x] = 1;
    dep[x] = (f <0 ? 0:dep[f]+1);
    son[x] = -1;
    for(int i = 0; i < G[x].size(); i++)
    {
        pair<int,int> a = G[x][i];
        if(a.first != f)
        {
            dfs(a.first,x,a.second);
            sz[x] += sz[a.first];
            if(son[x] == -1 || sz[son[x]] < sz[a.first])
            {
                son[x] = a.first;
            }
        }
    }
}
int top[10003];
int id[10004];
int rev[10003];

bool f[40005];
pair<int,int> P[40005];

void build(int x,int l,int r)
{
    f[x] = 0;
    if(l == r)
    {

        P[x].first = P[x].second = dist[rev[l]];
        return;
    }
    int mid = (l+r)>>1;
    build(2*x,l,mid);
    build(2*x+1,mid+1,r);
    P[x].first = min(P[2*x].first,P[2*x+1].first);
    P[x].second = max(P[2*x].second, P[2*x+1].second);
}

void modify(int x,int y,int l,int r,int v)
{


    if(l == r)
    {
        f[x] = 0;
        P[x].first = P[x].second = v;

        return;
    }
    if(f[x])
    {
        swap(P[2*x].first,P[2*x].second);
        P[2*x].first *=-1;
        P[2*x].second *= -1;
        swap(P[2*x+1].first,P[2*x+1].second);
        P[2*x+1].first *= -1;
        P[2*x+1].second *= -1;

        f[2*x] ^= f[x];
        f[2*x+1]^= f[x];
        f[x] = 0;
    }

    int mid = (l+r)/2;
    if(y <= mid)
    {
        modify(2*x, y,l,mid,v);
    }
    else modify(2*x+1,y,mid+1,r,v);
    P[x].first = min(P[2*x].first,P[2*x+1].first);
    P[x].second = max(P[2*x].second, P[2*x+1].second);
}
void neg(int x,int a,int b,int l,int r)
{
    if(a > b)return;

    if(a <= l && b >= r)
    {
        f[x] ^= 1;
        swap(P[x].first,P[x].second);
        P[x].first *=-1;
        P[x].second *= -1;

        return;
    }
    if(f[x])
    {
        swap(P[2*x].first,P[2*x].second);
        P[2*x].first *=-1;
        P[2*x].second *= -1;
        swap(P[2*x+1].first,P[2*x+1].second);
        P[2*x+1].first *= -1;
        P[2*x+1].second *= -1;

        f[2*x] ^= f[x];
        f[2*x+1]^= f[x];
        f[x] = 0;
    }
    int mid = (l+r)>>1;
    if(a <= mid)
    {
        neg(2*x,a,b,l,mid);
    }
    if(b > mid)
    {
        neg(2*x+1,a,b,mid+1,r);
    }
    P[x].first = min(P[2*x].first,P[2*x+1].first);
    P[x].second = max(P[2*x].second, P[2*x+1].second);
}
int ask(int x,int a,int b,int l,int r)
{
    if(a <= l && b >= r)
    {
        return P[x].second;
    }
    if(f[x])
    {
        swap(P[2*x].first,P[2*x].second);
        P[2*x].first *=-1;
        P[2*x].second *= -1;
        swap(P[2*x+1].first,P[2*x+1].second);
        P[2*x+1].first *= -1;
        P[2*x+1].second *= -1;

        f[2*x] ^= f[x];
        f[2*x+1]^= f[x];
        f[x] = 0;
    }
    int mid = (l+r)>>1;
    int ans = 0;
    if(b <= mid)
    {
        ans = ask(2*x,a,b,l,mid);
    }
    else if(a > mid)
    {
        ans = ask(2*x+1,a,b,mid+1,r);
    }
    else ans = max(ask(2*x,a,b,l,mid),ask(2*x+1,a,b,mid+1,r));
    P[x].first = min(P[2*x].first,P[2*x+1].first);
    P[x].second = max(P[2*x].second, P[2*x+1].second);
    return ans;

}
int k = 1;
void dfs1(int x,int f)
{
    top[x] = (f < 0 ? x:(son[f] == x ? top[f]:x));
    id[x] = k;
    rev[k++] = x;
    if(son[x] > 0)
    {
        dfs1(son[x],x);
    }
    for(int i = 0; i < G[x].size(); i++)
    {
        pair<int,int> a = G[x][i];
        if(a.first != f && a.first != son[x])
        {
            dfs1(a.first,x);
        }
    }
}
map<int,pair<int,int> > mp;
char s[50];
int main()
{
    int x,y,v,w;
    int T;
    scanf("%d",&T);
    while(T--)
    {
        k = 1;
        scanf("%d",&n);
        mp.clear();
        for(int i = 1; i <= n; i++)
        {
            G[i].clear();
        }
        for(int i = 1; i < n; i++)
        {
            scanf("%d%d%d",&x,&y,&v);
            G[x].push_back(make_pair(y,v));
            G[y].push_back(make_pair(x,v));
            mp[i] = make_pair(x,y);
        }
        dfs(1,-1,0);
        dfs1(1,-1);

        build(1,1,n);
        while(1)
        {
            scanf("%s",s);
            if(s[0] == 'C')
            {
                scanf("%d%d",&y,&v);
                pair<int,int> u = mp[y];

                int o;
                if(dep[u.first] > dep[u.second])
                {
                    o = u.first;
                }
                else o = u.second;

                modify(1,id[o],1,n,v);

            }
            else if(s[0] == 'Q')
            {
                scanf("%d%d",&x,&y);

                int ans = -2e9;
                while(true)
                {
                    if(top[x] == top[y])
                    {
                        if(dep[x] < dep[y])
                        {
                            ans = max(ans,ask(1,id[x]+1,id[y],1,n));
                            cout << ans << '\n';
                        }
                        else
                        {
                            if(x != y)
                                ans = max(ans,ask(1,id[y]+1,id[x],1,n));
                            cout << ans << '\n';
                        }
                        break;
                    }
                    //比较的是top[x] top[y]的深度
                    if(dep[top[x]] < dep[top[y]])
                    {
                        ans = max(ans,ask(1,id[top[y]],id[y],1,n));
                        y = fa[top[y]];

                    }
                    else
                    {

                        ans = max(ans,ask(1,id[top[x]],id[x],1,n));
                        x = fa[top[x]];
                    }
                }

            }
            else if(s[0] == 'N')
            {
                scanf("%d%d",&x,&y);
                while(true)
                {
                    if(top[x] == top[y])
                    {
                        if(dep[x] < dep[y])
                        {
                            neg(1,id[x]+1,id[y],1,n);
                        }
                        else if(dep[y] < dep[x])
                        {
                            neg(1,id[y]+1,id[x],1,n);
                        }
                        break;
                    }
                    if(dep[top[x]] < dep[top[y]])
                    {
                        neg(1,id[top[y]],id[y],1,n);
                        y = fa[top[y]];
                    }
                    else
                    {

                        neg(1,id[top[x]],id[x],1,n);
                        x = fa[top[x]];
                    }
                }
            }
            else
            {
                break;
            }
        }
    }
}
/**
1
10
1 2 0
1 3 2
1 4 3
2 5 4
2 6 5
3 7 3
7 8 3
2 9 0
4 10 2
N 4 8
C 2 -501
Q 9 4
Q 8 2
Q 1 6
D
**/

```



