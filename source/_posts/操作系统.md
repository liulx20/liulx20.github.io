---
title: 操作系统
date: 2021-05-26 10:53:24
tags: 操作系统
---

{%asset_img lake-5990540.jpg%}

<!--More-->

批处理操作系统

操作系统是一个简单的串行程序调度器和一系列库函数

操作系统中开始有设备文件任务，但只有一个独占计算机运行的程序。

* 并发（Concurrent)多个执行流可以不按照一个特定顺序执行
* 并行（Parallel)允许多个执行流同时执行（多个处理器

线程：多个执行流并发、并行执行，并且他们共享内存

* 两个执行流共享代码和所有全局变量（数据、堆区）(寄存器，堆栈独享)
* 线程之间指令执行顺序是不确定（non-deterministic）的
* 共享代码：所有线程的代码都来自当前进程的代码
* 共享数据：全局数据、堆区可以自由引用
* 独立堆栈：每个线程都有独立的堆栈

POSIX线程库（pthreads)

使用pthread_create创建并运行线程

使用pthread_join等待某个线程结束

```c
__thread int id; //thread-local variables
```

* 使用pmap可以查看到8192KiB内存映射区域和4KiB（一页的）guard（防止爆栈对其他线程造成影响

* 原子性（atomicity)

  一段代码不允许和其他代码并发

* 指令序列可以在任意时刻被中断，操作系统切换到其他线程

  * 即使是最简单的x++，也不能保证原子性

编译优化

* 允许源代码中内存访问指令不在按顺序甚至不再出现
* 编译器假设优化对象是单线程程序
* 假设程序是读写序列，编译器：
  * 在值能被确定的前提下，R(x)可能被删除
  * 在未来x一定被覆盖的前提下，W(x)可能被删除
  * x,y读写可以交换顺序
* for(int i = 0; i < n; i++)sum++

-O1 tmp = R(sum); for (int i = 0; i < n; i++); tmp += n; W(sum,tmp)

-O2 tmp = R(sum); tmp += n; W(sum,tmp);

* 可见性的丧失

  为了使CPU运行得更快，CPU可以不按顺序执行指令

* 现代处理器

  * 如果两条指令没有数据依赖关系，就能让他们并行执行
  * 乱序执行
    * 多处理器上执行的结果可以不等价指令按照某个顺序执行的结果

* C代码
  * 编译器优化->顺序丧失
  
* 二进制文件

* 处理器执行

  * 中断、并行->原子性丧失
  * 乱序执行->可见性丧失

* 共享内存并发程序问题：

  内存访问不保证按代码书写顺序发生

  代码的原子性随时被破坏

  执行过的指令可能在多处理器之间不可见

* 保证顺序

  控制编译器行为、阻止编译优化：

  ```c
  void delay(){
     for(volatile int i = 0; i < DELAY_COUNT,i++);
  }
  ```

  保证内存访问（指令）顺序

  ```c
  extern int x;
  #define barrier() asm volatile("":::"memory")
  void foo(){
     x++;
     barrier();
     x++;//阻止x的访问被合并
     y++;//y的访问不能移到barrier之前
  }
  ```

  

有限状态机Finite State Machine(FSM)

* 有向图G(V,E)
  * 节点$v \in V$是状态
  * 边$e \in E$是状态的转换
  * 边上有label代表执行某个动作

程序=有限状态机

（操作系统上的）程序执行时，状态是有限的

* 寄存器（PC指针）
* 内存：代码，数据、堆栈

构造有限状态机：

* 每个不同的configuration(内存/寄存器)都是状态机的节点
  * $s = (M,R)\in V$,代表某个时刻程序内存/寄存器的快照
  * 16MiB内存就有$2^{2^{64}}$种不同状态
* $s = (M,R)$ 的下一个状态是执行$M[R[\%rip]]$处指令得到的$s' = (M',R')$
  * 取出PC指针处的指令、译码、执行、写回数据
  * $(s,s')\in E$

大部分状态s有唯一的后续状态（deterministic)

不确定（non-deterministic）指令可能有多种后续状态

* （时间）rdtsc/rdtscp

* (机器状态)rdrand

  处理器自身提供的真随机数指令

  ```c
  #include <stdio.h>
  #include <stdint.h>
  int main(){
     uint64_t val;
     asm volatile("rdrand %0": "=r"(val));
     printf("rdrand returns %016lx\n",val);
  }
  ```

* 系统调用（syscall)

  read(fd,buf,size)

* 不确定性的来源：程序运行在操作系统/计算机硬件上，他们有自己的状态

gdb:

info registers会列出所有的寄存器

/proc/[pid]/maps有内存映射信息

* 应用

  * 在计算机硬件上的应用：高性能处理器的实现

    超标量（superscalar)处理器

    * insight:允许在状态机上跳跃

  * 在计算机系统上的应用：程序分析技术

    * 静态分析：根据程序代码推导出状态机的性质
    * 动态分析：检查运行时观测到状态机的执行

* 程序执行能否在时间上后退？

  记录所有的$s_{i}$开销太大（$s_{i}$由内存+寄存器组成）

  但一条指令的side-effect通常有限

  * 只记录初始状态，和每条指令前后的diff

* 线程

  共享代码和数据

  拥有独立的寄存器和堆栈

  * 堆栈也位于同一地址空间中
  * 允许把局部变量的指针（&local_var)传递给另一线程

* Peterson算法

  ```c
  int turn = T1,x = 0, y = 0;
  void thread1(){
      x = 1; turn = T2;
      while(y && turn == T2);
      x = 0;
  }
  void thread2(){
      y = 1; turn = T1;
      while(x && turn == T1);
      y = 0;
  }
  ```

  假设：机器每次原子地（atomically)执行一行代码，内存访问立即可见

### 互斥

* 实现lock_t数据结构

  ```c
  typedef struct{
  ...
  }lock_t;
  void lock(lock_t *lk);//试图获得锁的独占访问，成功获得后返回
  void unlock(lock_t *lk);//释放锁的独占访问
  ```

  一把排他性的锁--对于锁对象lk

  * 在任何线程调度下

    * 若某个线程持有锁（lock(lk)返回未释放）
    * 则任何其他线程lock(lk)都不能返回

  * 在共享内存上，共享资源的访问太危险（原子性、顺序、可见性丧失），互斥用来阻止代码块之间的并发，实现串行化

    * lock/unlock保护区域成为一个原子的黑盒子
    * 黑盒子的代码不能随意并发
    * 且先完成的黑盒子的内存访问在之后的黑盒子中可见

  * 共享内存上实现互斥

    * 共享内存多线程：独立的寄存器、堆栈，共享内存
    * 支持的基本操作
      * 线程本地（thread-local）计算(寄存器、堆栈上的数值读写、修改)（其他线程不可见
      * load，读共享内存
      * store，写共享内存
      * 假设load,store是原子的
    * 困难在于：不能同时读写内存

  * 一条不可分割的指令

    * 一次共享内存的load
    * 向同一共享内存地址的store
    * 以及一些线程本地的计算

  * 原子操作保证：

    * 原子性：load/store不会被打断
    * 顺序：线程执行乱序不能越过原子操作
    * 多处理器之间的可见性：若原子操作A发生在B之前，在A之前的store对B之后的load可见

  * x86原子操作

    lock指令前缀

    ```C
    void do_sum(){
       for(int i = 0; i < 10000; i++){
       asm volatile("lock addq $1,%0":"=m"(sum));
       }
    }
    ```

    xchg

    ```c
    int xchg(volatile int * addr,int newval){
    int result;
    asm volatile("lock xchg %0, %1"
         : "+m"(*addr),//[%0] addr (内存、读写)
          "=a"(result)//[%1]result (%eax)
          :"1"(newval)//[%1]
          :"cc"
    );
    return result;
    }
    ```

    自旋锁

    ```C
    int table = KEY;
    void lock(){
    while(1){
    int got = xchg(&locked,NOTE);
    if(got == KEY)break;
    }
    }
    void unlock(){
    xchg(&table,KEY);
    }
    ```

    ```c
    int locked = 0;
    void lock(){
    while(xchg(&locked,1));
    }
    void unlock(){
    xchg(&locked,0);
    }
    ```

    RISC-V:另一种原子操作

    原子操作本质：

    load(x)

    设置处理器局部（寄存器）状态

    store(x)
    
  * 多处理器自旋锁：

    1. 线程获得锁后发生中断，此时锁没被释放，其他线程无法获得锁

       获得自旋锁的线程不应该被中断，否则将导致大量其他线程浪费在自旋上

       关闭中断后，处理器上的执行流完全确定了

  * 中断的原子性/顺序

    * 关闭中断后，操作系统上的程序
      * 独占处理器执行
      * 不会被打断
    * asm volatile汇编保证编译器不会调换指令顺序

  * 中断可见性

    * 硬件保证中断必发生在指令边界
    * 中断前的数据全部写入（缓存/内存

  * 关中断+自旋

    ```c
    void spin_lock(spinlock_t &lk){
    cli();
    while(atomic_xchg(&lk->locked,1));
    }
    void spin_unlock(spinlock_t &lk){
    atomic_xchg(&lk->locked,0);
    sti();
    }
    ```

    先关中断再自旋

    先释放锁再开中断

  * 在线程第一次lock时保存中断状态，关闭中断

  * 在线程最后一次unlock时恢复保存的中断状态

  关中断+自旋：用来保护一段较短的临界区

  * 持有锁期间，线程不能被中断

  * 其他等待锁的线程在关中断的前提下自旋

    无法等待、必须立即执行否则不能继续的场景

* 互斥锁

  * 持有锁线程
    * 允许处理器响应中断
    * 允许切换到其他线程执行
      * 访问磁盘的线程不能阻碍系统其他部分执行
  * 等待锁的线程
    * 不要占用处理器资源自旋

  ```c
  void mutex_lock(mutexlock_t *lk){
      int acquired = 0;
      spin_lock(&lk->spinlock);
      if(lk->locked != 0){
          enqueue(lk->wait_list,current);
          current->status = BLOCKED;
      }else{
          lk->locked = 1;
          acquired = 1;
      }
      spin_unlock(&lk->spinlock);
      if(!acquired) yield();//主动切换到其他线程执行
  }
  void metex_unlock(mutexlock_t *lk){
      spin_lock(&lk->spinlock);
      if(!empty(lk->wait_list)){
          struct task_t * task = dequeue(lk->wait_list);
          task->status = RUNNNABLE;//唤醒之前睡眠的线程
         
      }else{
          lk->locked = 0;
      }
      spin_unlock(&lk->spinlock);
  }
  ```



### 同步

（Synchronization）两个或两个以上随时间变化的量在变化过程中保持一定的相对关系

* 生产者消费者问题
  * 生产者（线程)生产资源（一个对象），生产时间不确定
  * 消费者（线程）消费资源（取走一个对象），消费时间也不确定

条件变量

* 同步的本质：当某个条件满足时，线程执行，否则等待

用一个对象来表示条件的满足/不满足

* 条件不满足，随时可以在这个对象上等待
* 另一线程发现条件满足，唤醒一个（或所有）正在等待的线程

对于一个条件变量cv:

* wait(cv)
  * 进入睡眠状态，等待cv上的事件的发生
* signal/notify(cv)
  * 报告cv上的事件发生
  * 如果有线程正在等待cv，则唤醒其中一个线程
* broadcast/notifyAll(cv)
  * 报告cv上的事件发生
  * 唤醒全部正在等待的cv线程

和互斥锁联合使用

```c
mutex_lock(&mutex);
//任意代码
wait(&cv,&mutex);
//任意代码
mutex_unlock(&mutex);
//signal不受互斥锁约束
```

* wait会立即释放锁并等待
* 被signal后恢复执行，会首先试图获得mutex

//错误代码

```c
void producer_thread(){
    while(1){
        mutex_lock(&mutex);
        if(count == n)wait(&cv,&mutex);
        printf("(");
        count++; signal(&cv);
        mutex_unlock(&mutex);
    }
}
void consumer_thread(){
    while(1){
        mutex_lock(&mutex);
        if(count == 0)wait(&cv,&mutex);
        printf(")");
        count--; signal(&cv);
        mutex_unlock(&mutex);
    }
}
```

* 一个条件变量无法解决

```c
void producer_thread(){
    while(1){
        mutex_lock(&mutex);
        while(count == n)wait(&empty,&mutex);
        printf("(");
        count++; signal(&fill);
        mutex_unlock(&mutex);
    }
}
void consumer_thread(){
    while(1){
        mutex_lock(&mutex);
        //if 改为while
        while(count == 0)wait(&fill,&mutex);
        
        printf(")");
        count--; signal(&empty);
        mutex_unlock(&mutex);
    }
}
```

* 上述代码保证了safety wait 结束后条件一定为真
* 如果需要liveness,只需再任何可能条件为真时broadcast唤醒所有人

信号量

信号量=互斥锁和条件变量的结合体

* 互斥锁
  * 仅有一个手环的情况
  * P=lock V=unlock
* 条件变量
  * 手环的数量作为等待的条件
  * P=wait V = signal

```c
void producer(){
P(&empty);
    printf("(");
    V(&fill);
}
void consumer(){
    P(&fill);
    printf(")");
    V(&empty);
}
```

* 死锁

  出现线程互相等待的情况

  ABBA类型死锁

  四个必要条件：

  互斥：一个资源每次只能被一个进程使用

  请求与保持：一个进程请求阻塞时，不释放已获得资源

  不剥夺：进程已获得的资源不能强行剥夺

  循环等待：若干线程之间形成头尾相接的循环资源等待关系

  * AA-Deadlock

    AA类型死锁容易检测，及早报告，及早修复

  * ABBA-Deadlock

    任意时刻系统中的锁是有限的

    严格按照固定顺序获得所有锁

    T1:A->B->C ;T2:B->C是安全

    * 在任意时刻总有一个线程（获得最靠后锁的）可以继续执行

互斥锁-原子性

条件变量-同步

* 忘记上锁-原子性违反
* 忘记同步-顺序违反

操作系统

操作系统是管理多个应用程序执行的软件

* 应用视角：一组系统调用API
* 硬件视角：就是个状态机（C程序）

状态机的虚拟化

* 操作系统模拟了其中所有进程的状态机
* 程序彷佛自己独占CPU执行，但它独占的只是CPU的一部分

进程：运行的程序

* 任意时刻、进程都可以看成是状态机的状态

操作系统在中断后，可以选择将进程（状态机）调度到CPU上执行

* 进程执行系统调用，会使用指令（syscall)等回到操作系统

* 操作系统是一个中断处理程序

  * 被动的中断：硬件
  * 主动的中断：系统调用

* 三类系统调用

  * 进程管理：

    fork,execve,exit-状态机的创建、改变、删除

  * 存储管理

    mmap-对进程虚拟地址空间的一部分进行映射

    brk-虚拟地址空间管理

  * 文件管理

    open、close文件访问管理

    read、write数据管理

    mkdir、link、unlink目录管理



创建状态机fork()

替换状态机execve(filename,argc,enpv)

* 执行名为filename的程序
* 分别传入参数argv(V)和环境变量envp(e)

`env`查看当前环境变量

PATH:可执行文件搜索路径

PWD:当前路径

HOME:home目录

DISPLAY:图形输出

PS1：shell提示符

* export:告诉shell在创建子进程时设置环境变量

终止状态机exit

* 销毁当前状态机，并允许有一个返回值
* 子进程终止会通知父进程



* 进程的地址空间

  进程的地址空间=内存中若干连续的段

  * 每一段是可访问的（读/写/执行）内存

    可能映射到某个文件/或在进程间共享

  管理进程地址空间的系统调用

  ```c
  void *mmap(void *addr,size_t length,int prot,int flags,int fd,off_t offset);
  
  int munmap(void *addr,size_t length);
  //修改映射权限
  int mprotect(void *addr,size_t length,int prot);
  ```

  

* vsyscall的例子

  * 时间：内核维护秒级的时间（所有进程映射同一个页面）
    * time(2)
  * getcpu per-CPU映射页面

  让内核和进程共享数据（内核可写，进程只读）

  * vvar:内核和进程共享的数据
  * vdso:系统调用代码实现

  系统调用不一定陷入内核态执行

* syscall batching

  如果系统调用很多，可以打包处理

* 让进程和内核共享内存

  * 有一个内核线程在spinning等待系统调用的到来
  * 系统调用准备好后，只需要一个memory store,系统调用立即开始执行
  * 进程spin等待系统调用完成

* mmap并不需要真的为进程分配任何页面

  只需要让操作系统知道这么映射就够了

  进程访问页面会发生缺页进入操作系统

  * 根据操作系统维护的进程地址空间信息分配页面

  * 如果访问合法，分配一页

    * 匿名内存->直接返回

    * 文件->执行read把文件数据读到内存

      所以即便映射整个磁盘，也只有touch的页面被访问

  * 如果访问非法，发送信号（SIGSEGV)

    段错误

* 通过/proc/[pid]/maps查看进程的内存映射（pmap [pid])

* 地址空间终究是属于进程（运行的程序）的

  

### 链接与加载
* 静态链接与加载

  允许引用其他文件里定义的符号

* 静态ELF加载器：加载a.out执行

  * 根据ELF program header,将文件中指定的部分移动到内存
  * 操作系统在execve时完成
    * 操作系统在内核态调用mmap
      * 进程还未准备好时，由内核直接执行系统调用

* 动态链接

  * 每个程序都静态链接，浪费空间很大
  * 最好整个系统只有一个libc的副本
    * 文件系统里只有一个副本
    * 内存里只有一个副本
  * 加载纯粹的代码

* 符号地址是运行时才能确定的

  * 必须在运行时解析符号地址
    * 查表（编译成call *table[foo])

* 进程创建

1） 为新进程分配一个进程标示号，并申请一个空白的PCB。

2） 为进程分配资源，为新进程的程序和数据，以及用户占分配必要的空间。

3） 初始化PCB，主要包括初始化标识信息、初始化处理器状态信息和初始化处理器控制信息，以及设置进程的空闲及。

4） 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。

* 操作系统终止进程的过程如下：（撤消原语）

  1） 根据被终止进程的标示符，检索PCB，从中读出该进程的状态。

  2） 若被终止进程处于执行状态，立即终止该进程的执行，将处理器资源分配给其他进程。

  3） 若该进程还有子进程，则应将其所有子进程终止。

  4） 将该进程所拥有的资源、或归还给父进程或归还给操作系统。

  5） 将该PCB从所在队列（链表）中删除。

* 进程切换

1） 保存处理器上下文，包括程序计数器和其他寄存器。

2） 更新PCB信息。

3） 把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列。

4） 选择另一个进程执行，并更新其PCB。更新内存管理的数据结构。

5） 恢复处理器的上下文。

- SIGKILL与SIGSTOP是两个唯一不能忽略也不能捕获的信号

-  SIGTSTP与SIGSTOP都是使进程暂停（都使用SIGCONT让进程重新激活）。唯一的区别是SIGSTOP不可以捕获。

  * 捕捉SIGTSTP后一般处理如下：用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号

    1）处理完额外的事

    2）恢复默认处理

    3）发送SIGTSTP信号给自己。（使进程进入suspend状态。）

    他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.

- SIGINT：程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。

-  SIGBUS：非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。

- SIGCHLD：子进程结束时, 父进程会收到这个信号。

       如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。

   ctrl-d 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。

注：在shell中，ctrl-d表示推出当前shell.

* 重新设置一个进程优先级

`renice -20 -p [pid]`



