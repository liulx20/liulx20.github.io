---
title: 决策树&&随机森林
date: 2020-12-19 13:05:39
tags: 机器学习
---
机器学习小作业。

本文实现了决策树和随机森林算法。

简单的、仅针对二分类问题实现。
<!-- More -->
## C4.5决策树
C++实现
```C++
#include<iostream>
#include<vector>
#include<string>
#include<fstream>
#include<cstdlib>
#include<algorithm>
#include<map>
#include<cmath>
#include<set>
std::vector<std::vector<int> > train;
//std::vector<int> train_Y;
std::vector<std::vector<int> > test_X;

std::vector<int> splitString(std::string str)
{
    std::vector<int> ans;
    int a = 0;
    for(char c : str){
        if(c == ','){
            ans.push_back(a);
            a = 0;
        }else{
            a = a*10 + c - '0';
        }
    }
    ans.push_back(a);
    return ans;
}

void read_train(std::string file)
{
    std::ifstream in(file);
    std::string str;
    in >> str;
    while(in >> str){
        std::vector<int> v = splitString(str);
        //train_Y.push_back(v[(size_t)(v.size()-1)]);
        //v.pop_back();
        train.push_back(v);
    }

}

void read_test(std::string file)
{
    std::ifstream in(file);
    std::string str;
    in >> str;
    while(in >> str){
        std::vector<int> v = splitString(str);
        test_X.push_back(v);
    }
}


struct Tree{
   int col;/*按照第几列进行划分*/
   int pos;/*该节点正样本个数*/
   int neg;
   std::vector<std::pair<int,struct Tree *> > subT;
   /*划分得到的子树*/
};
struct Tree * root;



std::vector<std::vector<int>> split(const std::vector<std::vector<int>>&vec,int col,int val)
{
    std::vector<std::vector<int>> ans;
    for(auto&  v : vec){
        if(v[col] == val){
            std::vector<int> t(v);
            t.erase(t.begin()+col);
            ans.push_back(t);
        }
    }
    return ans;

}

double Gini(const std::vector<std::vector<int>>& vec)
{
    if(vec.size() == 0)return 0;
    size_t y = vec[0].size() - 1;
    int a = 0;
    for(auto v : vec){
        if(v[y] == 1){
            a ++;
        }
    }
    size_t s = vec.size();
    double ans = (a*a + (s-a)*(s-a))*1./(s*s);
    return ans;
}

double nlog(double x)
{
    /*规定x == 0时,xlog2(x) 为0*/
    if(fabs(x) < 1e-9)return 0;
    return x*log2(x);
}

/*计算信息增益比*/
double G(const std::vector<std::vector<int>> & vec, int col)
{

    std::map<int,int> mp;
    std::map<int,int> p;
    int pos = 0;
    int D = (int)(vec.size());
    for(auto & v : vec){
        mp[v[col]] += 1;
        if(v[vec[0].size()-1])
            p[v[col]] += 1,pos += 1;
    }
    double x =  pos*1./D,ans,y = 0,z;

    double hd = -(nlog(x) + nlog(1-x));
    double ha = 0;
    for(auto a : mp){
        x = p[a.first]*1./a.second;


        z = a.second *1./D;
        y -= z*(nlog(x) + nlog(1-x));
        ha -= nlog(z);
    }
    hd -= y;
    return hd/ha;
}

/*建树*/
struct Tree* build(std::vector<std::vector<int>> train)
{
    struct Tree * root = new Tree();

    root->pos = 0;
    root->neg = (int)train.size();
    root->col = -1;
    size_t y = train[0].size() - 1;
    for(auto v:train){
        if(v[y] == 1){
            root->pos ++;
            root->neg --;
        }
    }
    if(train.size() == 1)return root;
    std::vector<int> vec;
    int col = -1;
    double mG = 0;
    /*取信息增益比最大的特征对子树进行划分*/
    for(size_t i = 0; i < train[0].size() -1; i++){
        double g = G(train,i);
        if(g > mG){
            mG = g;
            col = i;
        }
    }
    root->col = col;
    if(mG > 0.0000001){
        std::set<int> st;

        for(auto & v : train){
           st.insert(v[col]);
        }
        for(int a : st){
          root->subT.push_back({a,build(split(train,col,a))});
        }
    }
    return root;
}
#include <queue>
void bfs(struct Tree* root)
{
    std::queue<std::pair<struct Tree*,int>> q;
    q.push({root,0});
    int l = 0;
    while(!q.empty()){
        std::pair<struct Tree*,int> p = q.front();q.pop();
        if(l == p.second-1){std::cout << "\n";l+=1;}
        std::cout <<"("<< p.first->pos << "," << p.first->neg  << ")";
        for(auto&  a : p.first->subT){
            q.push({a.second,p.second+1});
        }
    }
}


double predict(const std::vector<int>& vec,struct Tree * root){
    if(root->subT.size() == 0)return root->pos*1./(root->pos+root->neg);
    std::vector<int> v(vec);
    size_t len = root->subT.size();
    if(root->subT[0].first >= v[root->col]){
        v.erase(v.begin()+root->col);
        return predict(v,root->subT[0].second);
    }else{
        for(size_t i = 1; i < len -1; i++){
            if(root->subT[i].first == v[root->col]){
               v.erase(v.begin()+root->col);
                return predict(v,root->subT[i].second);
            }
        }
        v.erase(v.begin()+root->col);
        return predict(v,root->subT[len - 1].second);
    }
}


int main()
{
    read_train("train.csv");
    std::vector<std::vector<int>> train_,test_;
    for(auto & v : train){
        int x = rand()%100;
        if(x < 30){
            test_.push_back(v);
        }else{
            train_.push_back(v);
        }
    }
    root = build(train);
    bfs(root);
    //std::cout << root->pos <<" "<< root->neg << std::endl;

    int a = 0;
    for(auto & v : test_){
        if(predict(v,root)>0.5 && v[v.size()-1] == 1){
            a++;
        }
        else if(predict(v,root)<0.5 && v[v.size()-1]==0){
            a++;
        }
    }
    std::cout << "accuracy:\n";
    std::cout << a*1./test_.size() << std::endl;
    read_test("test.csv");
    std::ofstream out("submission.txt");
    for(size_t i = 0; i < test_X.size();i++){
        out << predict(test_X[i],root) << '\n';
    }
}


```


## 随机森林
在上面实现的决策树基础上，根据bagging原理，实现了随机森林。

每次从容量为n的样本集中有放回抽取n个样本，从特征集合中抽取m个特征，建立决策树。

每个决策树预测的概率求和，取算术平均作为随机森林预测结果。
```C++
#include<iostream>
#include<vector>
#include<string>
#include<fstream>
#include<cstdlib>
#include<algorithm>
#include<map>
#include<cmath>
#include<set>

std::vector<std::vector<int> > train;
//std::vector<int> train_Y;
std::vector<std::vector<int> > test_X;

std::vector<int> splitString(const std::string &str) {
    std::vector<int> ans;
    int a = 0;
    for (char c : str) {
        if (c == ',') {
            ans.push_back(a);
            a = 0;
        } else {
            a = a * 10 + c - '0';
        }
    }
    ans.push_back(a);
    return ans;
}

void read_train(const std::string &file) {
    std::ifstream in(file);
    std::string str;
    in >> str;
    while (in >> str) {
        std::vector<int> v = splitString(str);
        //train_Y.push_back(v[(size_t)(v.size()-1)]);
        //v.pop_back();
        train.push_back(v);
    }

}

void read_test(const std::string &file) {
    std::ifstream in(file);
    std::string str;
    in >> str;
    while (in >> str) {
        std::vector<int> v = splitString(str);
        test_X.push_back(v);
    }
}


struct Tree {
    int col;
    int pos;
    int neg;
    std::vector<std::pair<int, struct Tree *> > subT;
};


std::vector<std::vector<int>> split(const std::vector<std::vector<int>> &vec, int col, int val) {
    std::vector<std::vector<int>> ans;
    for (auto &v : vec) {
        if (v[col] == val) {
            std::vector<int> t(v);
            t.erase(t.begin() + col);
            ans.push_back(t);
        }
    }
    return ans;

}

double nlog(double x) {
    if (fabs(x) < 1e-9)return 0;
    return x * log2(x);
}

double G(const std::vector<std::vector<int>> &vec, int col) {

    std::map<int, int> mp;
    std::map<int, int> p;
    int pos = 0;
    int D = (int) (vec.size());
    for (auto &v : vec) {
        mp[v[col]] += 1;
        if (v[vec[0].size() - 1])
            p[v[col]] += 1, pos += 1;
    }
    double x = pos * 1. / D, y = 0, z;

    double hd = -(nlog(x) + nlog(1 - x));
    double ha = 0;
    for (auto a : mp) {
        x = p[a.first] * 1. / a.second;


        z = a.second * 1. / D;
        y -= z * (nlog(x) + nlog(1 - x));
        ha -= nlog(z);
    }
    hd -= y;
    return hd / ha;
}

struct Tree *build(std::vector<std::vector<int>> train) {
    struct Tree *root = new Tree();

    root->pos = 0;
    root->neg = (int) train.size();
    root->col = -1;
    size_t y = train[0].size() - 1;
    for (auto v:train) {
        if (v[y] == 1) {
            root->pos++;
            root->neg--;
        }
    }
    if (train.size() == 1)return root;
    std::vector<int> vec;
    int col = -1;
    double mG = 0;
    for (size_t i = 0; i < train[0].size() - 1; i++) {
        double g = G(train, i);
        if (g > mG) {
            mG = g;
            col = i;
        }
    }
    root->col = col;
    if (mG > 0.000001) {
        std::set<int> st;
        for (auto &v : train) {
            st.insert(v[col]);
        }
        for (int a : st) {
            root->subT.push_back({a, build(split(train, col, a))});
        }
    }
    return root;
}


double predict(const std::vector<int> &vec, struct Tree *root) {
    if (root->subT.size() == 0)return root->pos * 1. / (root->pos + root->neg);
    std::vector<int> v(vec);
    size_t len = root->subT.size();
    if (root->subT[0].first >= v[root->col]) {
        v.erase(v.begin() + root->col);
        return predict(v, root->subT[0].second);
    } else {
        for (size_t i = 1; i < len - 1; i++) {
            if (root->subT[i].first == v[root->col]) {
                v.erase(v.begin() + root->col);
                return predict(v, root->subT[i].second);
            }
        }
        v.erase(v.begin() + root->col);
        return predict(v, root->subT[len - 1].second);
    }
}


std::vector<std::vector<int>> resampling(const std::vector<std::vector<int>> &train) {
    std::vector<std::vector<int>> ans;
    size_t n = train.size();
    for (size_t i = 0; i < n; i++) {
        ans.push_back(train[rand() % n]);
    }
    return ans;
}


std::pair<std::vector<std::vector<int>>, std::vector<int>> selectFeature(const std::vector<std::vector<int>> &train) {
    std::vector<std::vector<int>> ans;
    std::vector<int> col;
    std::vector<int> idx;
    for (size_t i = 0; i < train[0].size() - 1; i++) {
        col.push_back(rand() % 10000);
        idx.push_back(i);
    }
    sort(idx.begin(), idx.end(), [=](int a, int b) {
        return col[a] < col[b];
    });
    while (idx.size() > 28)idx.pop_back();
    for (auto &v : train) {
        std::vector<int> vec;
        for (auto &i : idx) {
            vec.push_back(v[i]);
        }
        vec.push_back(v[v.size() - 1]);
        ans.push_back(vec);
    }
    return {ans, idx};
}


std::vector<std::vector<int>> select(const std::vector<std::vector<int>> &test, const std::vector<int> &col) {
    std::vector<std::vector<int>> ans;
    for (auto &v : test) {
        std::vector<int> vec;
        for (auto &i : col) {
            vec.push_back(v[i]);
        }
        ans.push_back(vec);
    }
    return ans;
}

int main() {
    //33
    const int N = 33;
    read_train("train.csv");
    //std::cout <<train.size()<< std::endl;
    std::vector<std::vector<int>> train_;
    std::pair<std::vector<std::vector<int>>, std::vector<int>> p;
    /*for(auto & v : train){
        int x = rand()%100;
        if(x < 30){
            test_.push_back(v);
        }else{
            train_.push_back(v);
        }
    }*/

    std::vector<std::vector<int>> col;
    std::vector<struct Tree *> root;

    for (size_t i = 0; i < N; i++) {
        train_ = resampling(train);

        p = selectFeature(train_);
        train_ = p.first;
        col.push_back(p.second);
        root.push_back(build(train_));
        std::cout << "第" << i << "棵决策树生成完成" << std::endl;
    }
    read_test("test.csv");
    std::ofstream out("submission.txt");
    std::vector<double> ans(test_X.size());
    fill(ans.begin(), ans.end(), 0);
    for (size_t i = 0; i < N; i++) {
        std::vector<std::vector<int>> test = select(test_X, col[i]);
        for (auto &v :col[i]) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
        for (size_t j = 0; j < test.size(); j++) {
            ans[j] += predict(test[j], root[i]);
        }
        std::cout << root[i]->pos << " " << root[i]->neg << std::endl;
    }
    for (auto &x: ans) {
        out << x * 1. / N << '\n';
    }
    out.close();
}


```