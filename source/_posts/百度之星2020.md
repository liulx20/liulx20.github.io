---
title: 百度之星2020
date: 2020-08-09 22:26:44
tags: 题解
mathjax: true
---

[百度之星2020复赛](http://acm.hdu.edu.cn/search.php?field=problem&key=2020+%C4%EA%B0%D9%B6%C8%D6%AE%D0%C7%A1%A4%B3%CC%D0%F2%C9%E8%BC%C6%B4%F3%C8%FC+-+%B8%B4%C8%FC&source=1&searchmode=source)
<!--More-->
## Binary Addition

### 题面

你有两个无限长0101串$S$, $T$，分别记作$S_{0}S_{1}\cdots$…和$T_{0}T_{1}\cdots$
.其中$S$和$T$从$n$位之后都是0，也就是当$i \geq n$，有$S_{i}=T_{i}=0$
你可以对$S$串进行操作：
修改$S$串的某一位，从0变成1或者从1变成0。
将$S$当成二进制数加1，也就是记$s=\sum_{i\geq 0} S_{i}2^{i}$，将$S$变成$s+1$二进制表示的形式，其中低位在最前面。
问最少的步数将$S$变成$T$。

### 思路

答案必定是先将某一前缀修改为全1，然后再加上1，变成$0\cdots01$的形式，然后按位修改。
***注意最高位1的位置如果在原来$S$串中也是1，可以先将1变为0再变回1***，找了一晚上bug==

### 代码

```
#include <bits/stdc++.h>
using namespace std;



char s[100010],t[100010];
int b[100010];
void work()
{
    int n;
    scanf("%d",&n);
    scanf("%s",s);
    scanf("%s",t);
    int a = 0;
    n = strlen(s);
    b[n]=0;
    b[n+1] =0;
    s[n] = t[n] = '0';
    for(int i=n-1;i>=0;i--){
        b[i] = b[i+1]+(s[i]!=t[i]);
    }
    int ans = b[0];
    int  d = 0, c = 0;
    for(int i = 0;i < n;i++){
        if(s[i] == '0'){ d++;}
        if(t[i] == '1'){ c++;}
        if(s[i+1]=='0') {
            ans = min(ans, d + c + b[i + 2] + (t[i + 1] != '1') + 1);
        }else{
            ans = min(ans,d+c+1+b[i+2]+(t[i+1]!='1')+1);
        }
        if(d+c>ans){break;}
    }
    cout<<ans<<'\n';

}
signed main() {
    signed _;
    scanf("%d",&_);
    while(_--){
        work();
    }
    return 0;
}
/**
7
1110111
0000001
3?
*/
```

## Battle for Wosneth

### 题面

你在打游戏的时候碰到了如下问题：
​有两个人记作Alice和Bob，Bob的生命值为$m$，Alice的生命值很高，所以可以认为是无限的。两个人的攻击命中率分别为$p\%,q\%$。两个人轮流攻击对方。从Alice开始攻击，每次攻击的时候，如果Alice命中，那么能让对方的生命值减低1，同时自己的生命值能恢复1，如果Bob命中，那么能让对方的生命值减低1，注意Bob不会自己回血。
直到Bob的血量变为0，游戏结束。Alice想知道，游戏结束的时候，自己期望生命值变化是多少，对998244353取模。
注意这里的变化量不是绝对值，也就是如果50%的概率加一，50%的概率减一，那么期望的变化量就是0。

### 思路

Alice在杀掉Bob之前，即成功击中Bob$m$次之前，失败次数服从帕斯卡分布，期望值$m \times (1-p)/p$。所以留给Bob进攻的次数期望值为$m\times (1-p)/p+m-1$，击中次数期望
$(m\times (1-p)/p+m-1)\times q$，因而Alice生命值期望变化量
$m - (m\times (1-p)/p+m-1)\times q$。

### 关于帕斯卡分布
$X \sim NB(k;p)$，则$P(X=r) = C_{k+r-1}^{k-1}p^{k}(1-p)^{r}$,$r$为失败次数。
期望：
$EX = \sum_{r}rP(X=r) $ 
$= \sum_{r}r\frac{(r+k-1)!}{(k-1)!r!}p^{k}(1-p)^{r} $ 
$= k\frac{1-p}{p} \sum_{r-1} \frac{((r-1)+(k+1)-1)!}{(k-1)!r!}p^{k+1}(1-p)^{r-1}$
$= k\frac{1-p}{p}$. 
***最后一步是由$\sum_{r-1} \frac{((r-1)+(k+1)-1)!}{(k-1)!r!}p^{k+1}(1-p)^{r-1}$是帕斯卡分布概率求和，故为1得到***

{% asset_img 公式1.png %}

{% asset_img 公式2.png %}

### 代码
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define fi first
#define se second
#define endl '\n'
#define si signed
#define P pair<int,int>
#define sc(x) scanf("%lld",&x);
int mod = 998244353;
int qp(int x,int n)
{
    int ans = 1;
    while(n){
        if(n&1){
            ans = (ans*x)%mod;
        }
        n>>=1;
        x = (x*x)%mod;
    }
    return ans;
}
void work()
{
    int m,p,q;
    sc(m)sc(p)sc(q)
    int ans;
    int in = qp(100,mod-2);
    p = (p*in)%mod;
    q = (q*in)%mod;

    ans = (m-((m*(1-p+mod)%mod*(qp(p,mod-2))%mod)+m-1)%mod*q%mod+mod)%mod;
    cout<<ans<<'\n';
}
signed main() {
    si _;
    scanf("%d",&_);
    while(_--){
        work();
    }
    return 0;
}
```
