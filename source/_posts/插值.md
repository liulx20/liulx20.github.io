---
title: 插值
date: 2021-07-06 15:24:44
tags: 
---

### Lagrange插值法

给定一组n个函数点值$\{(x_{1},f(x_{1})),(x_{2},f(x_{2})),\cdots,(x_{n},f(x_{n}))\}$,用n-1次多项式拟合这n个点.

记$f(x) = l_{1}(x)f(x_{1}) + l_{2}(x)f(x_{2}) + \cdots + l_{n}(x)f(x_{n}) $

其中$l_{i}(x) = 0, x \neq x_{i}$

​       $l_{i}(x) =1,x = x_{i}$

可以将$l_{i}(x)$构造成

$l_{i}(x) = \frac{(x-x_{1})\cdots (x-x_{i-1})(x-x_{i+1})\cdots(x-x_{n})}{(x_{i}-x_{1})\cdots(x_{i}-x_{i-1})(x_{i}-x_{i+1})\cdots (x_{i}-x_{n})} $

当$x_{1},x_{2},\cdots,x_{n}$取连续值时，如$1,2,\cdots,n$,有

$l_{i}(x) = \frac{(x-1)\cdots (x-(i-1))(x-(i+1))\cdots (x-n)}{(i-1)\cdots(i-(i-1))(i-(i+1))\cdots(i-n)}$

分母可以化简为

$(-1)^{n-i}(i-1)!(n-i)!$

我们可以利用Lagrange插值法实现形如$\Sigma_{i=1}^{n} i^k$快速求和,==n很大，k很小==

我们有结论$\Sigma i^{k}$是k+1次多项式，记为$S_{i}$

可以预处理计算前k+2项的和，得到$S_{i}$的k+2项点值，从而确定$S_{i}$的Lagrange插值形式。

通过插值表达式求$S_{n}$的值。

我们可以预处理$1-n$阶乘的逆元，对于$l_{i}(x)$分子那个东西，可以先预处理前缀乘积和后缀乘积

这样每一项的计算都是$O(1)$，计算$S_{n}$总的复杂度为$O(n)$

<!--More-->



[**F - Cumulative Sum**](https://atcoder.jp/contests/abc208/tasks/abc208_f)

可以看出f(n,m)是关于n的m+k次多项式

暴力计算前m+k+1个位置点值$f(1,m),f(2,m),\cdots,f(m+k+1,m)$

然后根据插值表达式计算f(n,m)

不知道为啥卡常==，需要时才取模

```C++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int dp[55];
int mod = 1e9+7;
int qp(int x,int n)
{
    int ans = 1;
    x %= mod;
    while(n)
    {
        if(n&1)
        {
            ans = (ans*x)%mod;
        }
        x = (x*x)%mod;
        n >>= 1;
    }
    return ans;
}

int n,m,k;
int f[2500050];
int inv[2500050];//阶乘逆元
int A[2500050];//(x-x_i)前缀
int B[2500050];//(x-x_i)后缀
void init(int m)//预处理阶乘逆元
{
    inv[0] = 1;
    for(int i = 1; i <= m; i++)
    {
        inv[i] = (inv[i-1]*i)%mod;
    }
    inv[m] = qp(inv[m],mod-2);
    for(int i = m-1; i >= 1 ; i--)
    {
        inv[i] = (inv[i+1]*(i+1))%mod;
    }
}
int cal(int n,int m)//计算f(n),m为次数+1
{
    int y;
    A[0] = 1;
    for(int i = 1; i <= m; i++)
    {
        y = (n-i)%mod;
        //assert(y != 0);
        A[i] = (A[i-1]*y)%mod;
    }
    B[m+1] = 1;
    for(int i = m; i >= 1; i--)
    {
        y = (n-i)%mod;
        B[i] = B[i+1]*y %mod;
    }


    int ans = 0;
    for(int i =1; i <= m; i++)
    {
        if((m-i)&1)
            ans = (ans - ((A[i-1]*B[i+1])%mod*inv[i-1]%mod * inv[m-i]%mod*f[i]%mod)+mod)%mod;
        else
            ans = (ans + ((A[i-1]*B[i+1])%mod*inv[i-1]%mod * inv[m-i]%mod*f[i]%mod))%mod;
    }
    return ans;

}
signed main()
{
    
    scanf("%lld%lld%lld",&n,&m,&k);
    init(m+k+1);

    for(int i = 1; i <= m+k+1; i++)
    {
        for(int j = 0; j <= m; j++)
        {
            if(j == 0)
            {
                dp[j] = qp(i,k);
            }
            else
            {
                dp[j] += dp[j-1];
            }
            if(dp[j] > mod)dp[j] -= mod;
        }
        f[i] = dp[m]%mod;
        if(i == n)
        {
            cout << f[n] << '\n';
            return 0;
        }
    }
    cout << cal(n,m+k+1) << '\n';

}

```

