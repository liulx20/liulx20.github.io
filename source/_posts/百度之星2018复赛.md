---
title: 百度之星2018复赛
date: 2020-08-08 16:07:44
tags: 题解
mathjax: true
---

只会两道QAQ,第二题不会。[2018百度之星复赛](http://acm.hdu.edu.cn/search.php?field=problem&key=2018%A1%B0%B0%D9%B6%C8%D6%AE%D0%C7%A1%B1%B3%CC%D0%F2%C9%E8%BC%C6%B4%F3%C8%FC+-+%B8%B4%C8%FC&source=1&searchmode=source)

<!-- More -->
## 没有兄弟的舞会

### 题面
度度熊、光羽、带劲三个人是好朋友。

度度熊有一棵$n$个点的有根树，其中1号点为树根。除根节点之外，每个点都有父节点，记i号点的父节点为$fa[i]$。

度度熊称点$i$和点$j$是**兄弟**（其中$i≠j$）当且仅当$fa[i]=fa[j]$。

第$i$个点的权值为$Ai$。现要求选出一个点集，该点集合法当且仅当**点集中至多只有一对兄弟**。

度度熊想知道，在所有可行的点集中，权值和**最大**以及**最小**的点集权值和分别是多少？

第一行一个数，表示数据组数$T$。

每组数据第一行一个整数$n$；第二行$n−1$个数，表示$fa[2],fa[3],..,fa[n]$；第三行$n$个数，表示$Ai$。

数据组数$T=100$，满足：

- $1 \leq n \leq 1e5$
- $−1e9\leq Ai \leq 1e9$
- $1 \leq fa[i]<i$

其中90%的数据满足$n \leq 1000$。

### 思路

维护每个父节点直接子节点权值的正最大值，正次大值，负最小值，负次小值。最大点集权值为所有正的最大值与最大的正次大值之和，最小点集权值为所有负最小值与最小的负次小值之和。

### 代码
```
//
// Created by liulex on 2020/7/27.
//

#include<bits/stdc++.h>
using namespace std;

int fa[100005];
int A[100005];
int B[100005];
int C[100005];
int D[100005];
int v[100005]; 
signed main()
{
    int T,n;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);

        A[0] = B[0] = C[0] = D[0] = A[1] = B[1] = C[1] = D[1] = 0;
        for(int i = 2; i <= n; i++){
            scanf("%d",&fa[i]);
            A[i] = B[i] = C[i] = D[i] = 0;
        }
        for(int i = 1; i <= n; i++){
            scanf("%d",&v[i]);
            if(v[i] > A[fa[i]] && v[i] > 0){
               B[fa[i]] = A[fa[i]],A[fa[i]] = v[i];
            }else if(v[i] > B[fa[i]] && v[i] >0){
                B[fa[i]] = v[i];
            }else if(v[i] < C[fa[i]] &&v[i] < 0){
                D[fa[i]] = C[fa[i]];
                C[fa[i]] = v[i];
            }else if(v[i] < D[fa[i]] && v[i]  < 0){
                D[fa[i]] = v[i];
            }
        }
        long long  ma = 0,mi = 0;
        int c = 0, d = 0;
        for(int i = 0; i <= n; i++){
            ma += A[i];
            mi += C[i];
            c = max(c,B[i]);
            d = min(d,D[i]);
        }
        cout<<ma+c<<' '<<mi+d<<'\n';
    }
}
```

## 带劲的and和

### 题面
度度熊专门研究过“动态传递闭包问题”，他有一万种让大家爆蛋的方法；但此刻，他只想出一道简简单单的题——至繁，归于至简。

度度熊有一张$n$个点$m$条边的**无向图**，第$i$个点的点权为$vi$。

如果图上存在一条**路径**使得点$i$可以走到点$j$，则称$i$,$j$是**带劲**的，记$f(i,j)=1$；否则$f(i,j)=0$。显然有$f(i,j)=f(j,i)$。

度度熊想知道求出：
$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}f(i,j)×max(vi,vj)×(vi\&vj)$

其中&是C++中的and位运算符，如$1\&3=1, 2\&3=2$。

请将答案对$1e9+7$取模后输出。

第一行一个数，表示数据组数$T$。

每组数据第一行两个整数$n,m$；第二行$n$个数表示$vi$；接下来$m$行，每行两个数u,v，表示点u和点v之间有一条无向边。**可能有重边或自环。**

数据组数$T=50$，满足：

- $1\leq n,m\leq 100000$
- $1\leq vi\leq 1e9$。

其中90%的数据满足$n,m\leq 1000$。

### 思路

我们可以通过并查集维护任意两点连通关系。当$i,j$属于同一连通分支时，$f(i,j)=1$，我们把这一连通分支里所有顶点权值排序，从前往后遍历，不难发现对于每一个权值$vi$,
对答案都有$v_{i}\sum_{j=1}^{i-1}v_{i}\&v_{j}$贡献。问题转换成了对这个求和$\sum_{j=1}^{i-1}v_{i}\&v_{j}$的处理，直接考虑与运算对求和没有前缀性质。
需要用到二进制思想，维护权值的二进制每一位出现次数的前缀和，(第$k$位记为$A_{k}$)，对于当前权值$v_{i}$，如果它的二进制第$k$位为1,那么将对求和产生$A_{k}*(1<<k)$的贡献。

### 代码

```
//
// Created by liulex on 2020/7/27.
//

#include<bits/stdc++.h>
using namespace std;

#define int long long
#define si signed
int v[100005];
si fa[100005];
vector<int> G[100005];
int A[33];
si find(si x){
    return fa[x] = (fa[x] == x?x:find(fa[x]));
}
const long long mod = 1e9+7;
si main()
{
    si T,n,m,x,y;
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        for(int i=0;i<=30;i++)A[i] = 0;
        for(int i = 1; i<=n; i++){
            scanf("%lld",&v[i]);
            fa[i] = i;
        }
        for(int i = 1; i <= m; i ++){
            scanf("%d%d",&x,&y);
            if(find(x) != find(y)){
                fa[find(x)] = find(y);
            }
        }
        for(int i=1;i<=n;i++){
            G[find(i)].push_back(v[i]);
        }
        long long ans = 0,t;
        for(int i=1; i <= n; i++){
            if(G[i].size()>1){

                for(int j=0;j<=30;j++)A[j] = 0;
                sort(G[i].begin(),G[i].end());
                for(int j=0;j<G[i].size();j++){
                        t = 0;
                        for(int k = 0; k <= 30; k++) {
                            if ((G[i][j] >> k) & 1) {
                                t += (A[k] * (1ll << k)) % mod;
                                t %= mod;
                                A[k]++;
                            }
                        }
                        ans += (G[i][j]*t)%mod;
                        ans %= mod;
                }
            }
            if(G[i].size())
            G[i].clear();
        }
        cout<<ans<<'\n';
    }
}
```