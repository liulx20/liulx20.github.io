<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="liulx">
<meta property="og:url" content="https://github.com/liulx20/index.html">
<meta property="og:site_name" content="liulx">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liulx">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://github.com/liulx20/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>liulx</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">liulx</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">雪沫乳花浮午盏,蓼茸蒿笋试春盘。人间有味是清欢。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>留言板</a>

  </li>
        <li class="menu-item menu-item-dongtai">

    <a href="/dongtai/" rel="section"><i class="fa fa-th fa-fw"></i>动态</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liulx"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">liulx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liulx20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liulx20"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liulex@buaa.edu.cn" title="E-Mail → mailto:liulex@buaa.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2022/01/15/%E9%95%BF%E9%95%BF%E8%A7%81%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/15/%E9%95%BF%E9%95%BF%E8%A7%81%E8%AF%86/" class="post-title-link" itemprop="url">长长见识</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-15 15:18:43 / 修改时间：15:18:44" itemprop="dateCreated datePublished" datetime="2022-01-15T15:18:43+08:00">2022-01-15</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/15/%E9%95%BF%E9%95%BF%E8%A7%81%E8%AF%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/15/%E9%95%BF%E9%95%BF%E8%A7%81%E8%AF%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/10/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-09 15:02:03" itemprop="dateCreated datePublished" datetime="2021-10-09T15:02:03+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-15 16:57:42" itemprop="dateModified" datetime="2021-10-15T16:57:42+08:00">2021-10-15</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>C/S模型：缓存大量数据，协议选择灵活,速度快，缺点：安全性</p>
<p>B/S模型：安全、跨平台，开发工作量小 缺点：不能缓存大量数据，严格遵守HTTP</p>
<h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p>网络套接字：socket</p>
<p>一个文件描述符指向一个套接字，该套接字内部由内核借助两个缓存区实现</p>
<p>在通信过程中。套接字一定是成对出现的</p>
<ul>
<li><p>网络字节序：</p>
<p>大端法：低地址高字节</p>
<p>网络字节序和主机字节序转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;<span class="comment">//本地-&gt;网络</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;<span class="comment">//网络转本地</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netlong)</span></span>;</span><br><span class="line"><span class="comment">//IP地址转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dest)</span></span>;本地字节序（<span class="built_in">string</span> ip)-&gt;网络字节序</span><br><span class="line">af:AF_INET</span><br><span class="line">   AF_INET6</span><br><span class="line">src:传入参数 IP地址，点分十进制</span><br><span class="line">dest：传出参数，网络字节序的IP地址</span><br><span class="line">成功返回<span class="number">1</span>，异常<span class="number">0</span>src不是有效ip地址，失败<span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span>*src,<span class="keyword">char</span> *dst,<span class="keyword">socklen_t</span> size)</span></span>;网络字节序-&gt;本地字节序（<span class="built_in">string</span> ip)</span><br><span class="line">src:网络字节序ip地址</span><br><span class="line">dst:本地字节序（<span class="built_in">string</span> ip)</span><br><span class="line">size dst大小</span><br><span class="line">返回值 成功src</span><br><span class="line">      失败<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p>man 7 ip</p>
</li>
<li><p>sockaddr地址结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">               <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">               <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">               <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = hton(<span class="number">9527</span>);</span><br><span class="line"><span class="keyword">int</span> dest;</span><br><span class="line">addr.sin_addr.s_addr = inet_pton(AF_INET,<span class="string">&quot;192.152.22.35&quot;</span>,(<span class="keyword">void</span> *)&amp;dst);</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY）;<span class="comment">//取出系统中任意有效地址，二进制类型</span></span><br><span class="line">bind(fd,(struct sockaddr*)&amp;addr,len);</span><br></pre></td></tr></table></figure>
<p>服务器</p>
<p>socket()创建套接字</p>
<p>bind(）绑定IP+Port</p>
<p>listen()设置同时监听上限</p>
<p>accept()阻塞监听客户端连接</p>
<p>close()</p>
<p>客户端</p>
<p>socket()创建套接字</p>
<p>connect()绑定IP和端口</p>
<p>close()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;<span class="comment">//创建一个套接字</span></span><br><span class="line">domain: AF_INET AF_INET6 AF_UNIX（本地）</span><br><span class="line">type:SOCK_STREAM,SOCK_DGRAM</span><br><span class="line">protocol:<span class="number">0</span></span><br><span class="line">成功返回新套接字对应的文件描述符</span><br><span class="line">失败<span class="number">-1</span>,perror</span><br><span class="line">    socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;<span class="comment">//给socket绑定一个地址结构（IP+port)</span></span><br><span class="line">sockfd:socket函数返回值</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_addr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//要与sock传递的一致</span></span><br><span class="line">    </span><br><span class="line">addr:&amp;addr</span><br><span class="line">addrlen:<span class="keyword">sizeof</span>(addr)</span><br><span class="line">成功<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;<span class="comment">//设置同时与服务器建立连接的上限数</span></span><br><span class="line">backlog:上限数值，最大<span class="number">128</span></span><br><span class="line">成功<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;<span class="comment">//阻塞等待客户端建立连接，成功的话返回一个与客户端成功连接的socket文件描述符</span></span><br><span class="line">sockfd:socket 返回值</span><br><span class="line">addr:传出参数，成功与服务器建立连接的客户端地址结构</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    传入&amp;addr_len</span><br><span class="line">addrlen:传入传出参数，入：addr大小，出：客户端addr实际大小</span><br><span class="line">成功返回能与客户端进行数据通信的socket对应的文件描述符</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr*addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//addr：传入参数，服务器的地址结构</span></span><br><span class="line"><span class="comment">//addrlen:服务器的地址结构大小</span></span><br><span class="line">返回值：</span><br><span class="line">    成功<span class="number">0</span></span><br><span class="line">    失败<span class="number">-1</span>errno</span><br><span class="line">如果不使用bind绑定客户端地址结构，采用隐式绑定</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ],CLIENT_IP[<span class="number">1024</span>];</span><br><span class="line">    lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bind(lfd,(struct sockaddr*)(&amp;serv_addr),<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(lfd,<span class="number">128</span>);</span><br><span class="line">    client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    cfd = accept(lfd,(struct sockaddr*)(&amp;client_addr),&amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip:%s port:%d\n&quot;</span>,inet_ntop(AF_INET,&amp;client_addr.sin_addr.s_addr,CLIENT_IP,<span class="keyword">sizeof</span>(CLIENT_IP)),ntohs(client_addr.sin_port));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd,buf,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nc</span> <span class="number">127.0.0.1</span> <span class="number">9527</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cfd;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = connect(cfd, (struct sockaddr *) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--counter) &#123;</span><br><span class="line">        write(cfd, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h3><ul>
<li><p>socket()创建监听套接字</p>
</li>
<li><p>bind()绑定地址结构</p>
</li>
<li><p>listen()</p>
</li>
<li><p>while(1){</p>
<p>cfd =accept()</p>
<p>pid = fork();</p>
<p>if(pid == 0){</p>
<p>close(lfd)</p>
<p>子进程read(cfd)-&gt;小-&gt;大 write(cfd)</p>
<p>}else if(pid &gt; 0){</p>
<p>close(cfd);//关闭用于客户端通信的套接字cfd</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
</li>
<li><p>子进程：</p>
<p>close(lfd)</p>
<p>read()</p>
<p>小—大</p>
<p>write()</p>
</li>
<li><p>父进程</p>
<p>close(cfd)</p>
<p>注册信号捕捉函数 SIGCHLD</p>
<p>在回调函数中完成子进程回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    bind(lfd, (struct sockaddr *) (&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cfd = accept(lfd, (struct sockaddr *) &amp;client_addr, &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">            <span class="keyword">int</span> ret, i;</span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;<span class="comment">//read函数返回0说明对端已经关闭</span></span><br><span class="line">                    <span class="comment">//read 返回-1出错</span></span><br><span class="line">                    <span class="comment">//errno = EAGIN or EWOULDBLOCK 设置非阻塞方式，没有数据到达</span></span><br><span class="line">                    <span class="comment">//errno = EINTR 慢速系统调用被中断</span></span><br><span class="line">                    <span class="comment">//其他异常</span></span><br><span class="line">                    close(cfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">                    buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, buf, ret);</span><br><span class="line">                write(STDOUT_FILENO, buf, ret);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signal(SIGCHLD, sigchld);</span><br><span class="line">            close(cfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h3><ul>
<li><p>socket()创建监听套接字</p>
</li>
<li><p>bind()绑定地址结构</p>
</li>
<li><p>listen()</p>
</li>
<li><p>while(1){</p>
</li>
</ul>
<p>cfd = Accept(lfd,)</p>
<p>pthread_create(&amp;tid,NULL,tfn,NULL);</p>
<p>pthread_detach(tid);//pthread_join(tid,void**);新线程—专门回收子线程</p>
<p>}</p>
<ul>
<li><p>子线程</p>
<p>void <em>tfn(void </em>arg){</p>
<p>read()   </p>
<p>小—大</p>
<p>   write()</p>
<p>}</p>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r .<span class="regexp">/test[本地目录] 用户名@101.200.170.171：/</span>home<span class="regexp">/用户名/</span>socket_server[远程目录]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -apn | grep 8000 //查看8000号端口网络连接状态</span><br></pre></td></tr></table></figure>
<h3 id="TCP状态时序图"><a href="#TCP状态时序图" class="headerlink" title="TCP状态时序图"></a>TCP状态时序图</h3><p>1.主动发起连接请求端 CLOSE— 发送SYN — SEND_SYN —接收ACK,SYN—SEND_SYN —-发送ACK — ESTABLISHED（数据通信态）</p>
<p>2.主动关闭连接请求端 ESTABLISHED（数据通信态）—发送FIN—FIN_WAIT1—接收ACK—FIN_WAIT2(半关闭)—接收端发送FIN—FIN_WAIT2（半关闭）—回发ACK—TIME_WAIT(2MSL)(只有主动关闭连接方会经历该状态）—CLOSE</p>
<p>3.被动接受连接请求端 CLOSE—LISTEN —接收SYN—LISTEN—发送SYN,ACK—SYN_RCVD—接收ACK—ESTABLISHED</p>
<p>4.被动关闭连接请求端：ESTABLISHED—接收FIN，发送ACK — CLOSE_WAIT (对端处于半关闭状态)— 发送FIN—LAST_ACK—接收ACK—CLOSE</p>
<ul>
<li><p>2MSL时长</p>
<p>保证最后一个ACK能被对端接收，（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求）</p>
</li>
</ul>
<h3 id="设置端口复用"><a href="#设置端口复用" class="headerlink" title="设置端口复用"></a>设置端口复用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在socket和bind之间插入</span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;<span class="comment">//设置端口复用，0/1</span></span><br><span class="line">setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR<span class="comment">/*SO_REUSEPORT*/</span>,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>半关闭：通信双方，只有一端关闭通信 FIN_WAIT_2</p>
<p>close(cfd);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> how)</span></span>;</span><br><span class="line">how:</span><br><span class="line">SHUT_RD</span><br><span class="line">SHUT_WR</span><br><span class="line">SHUT_RDWR</span><br><span class="line">shutdown在关闭多个文件描述符引用的文件时，采用全关闭方法，close只关闭一个</span><br></pre></td></tr></table></figure>
<h3 id="select多路IO转接"><a href="#select多路IO转接" class="headerlink" title="select多路IO转接"></a>select多路IO转接</h3><p>阻塞</p>
<p>非阻塞忙轮询</p>
<p>响应式—多路IO转接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nfds：监听的所有文件描述符中最大的文件描述符+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">传入传出参数：</span></span><br><span class="line"><span class="comment">readfds 读文件描述符监听集合，文件描述符指针，指向文件描述符表位图</span></span><br><span class="line"><span class="comment">writefds 写文件描述符监听集合 NULL</span></span><br><span class="line"><span class="comment">exceptfds 异常文件描述符监听集合 NULL</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回监听集合中，满足对应事件的的总数</span></span><br><span class="line"><span class="comment">0：没有满足监听条件的文件描述符</span></span><br><span class="line"><span class="comment">-1：error</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">timeout:定阻塞时间</span></span><br><span class="line"><span class="comment">    NULL:永远等待</span></span><br><span class="line"><span class="comment">    设置timeval,等待固定时间</span></span><br><span class="line"><span class="comment">    设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原理：借助内核，select来监听，客户端连接，数据通信事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line">FD_ZERO(rset);</span><br><span class="line"></span><br><span class="line">FD_SET(<span class="number">3</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">6</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>,&amp;rset);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lfd = socket(); <span class="comment">//创建套接字</span></span><br><span class="line">bind();<span class="comment">//绑定地址结构</span></span><br><span class="line">listen();<span class="comment">//设置监听上限</span></span><br><span class="line">fd_set rset,allset;<span class="comment">//创建r监听集合</span></span><br><span class="line">FD_ZERO(allset);<span class="comment">//将r监听集合清空</span></span><br><span class="line">FD_SET(lfd,&amp;allset);<span class="comment">//将lfd添加至读集合</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">rset = allset;<span class="comment">//保存监听集合</span></span><br><span class="line">ret = select(lfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//监听文件描述符集合对应事件</span></span><br><span class="line"><span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;<span class="comment">//有监听的描述符满足对应事件</span></span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))&#123;<span class="comment">//1在 0不在</span></span><br><span class="line">        cfd = accept(); <span class="comment">//建立连接，返回用于通信的文件描述符</span></span><br><span class="line">        FD_SET(cfd,&amp;allset);<span class="comment">//添加到监听通信描述符集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = lfd+<span class="number">1</span>; i &lt;= 最大文件描述符; i++)&#123;</span><br><span class="line">        FD_ISSET(i,&amp;rset);<span class="comment">//有read,write事件</span></span><br><span class="line">        read();</span><br><span class="line">        小--&gt;大</span><br><span class="line">        write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bind(lfd, (struct sockaddr *) (&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">    fd_set rset,allset;</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(lfd,&amp;allset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_addr_len;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        num = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))&#123;</span><br><span class="line">            client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">            cfd = accept(lfd,(struct sockaddr*)&amp;client_addr,&amp;client_addr_len);</span><br><span class="line">            FD_SET(cfd,&amp;allset);</span><br><span class="line">            <span class="keyword">if</span>(cfd &gt; maxfd)maxfd = cfd;</span><br><span class="line">            <span class="keyword">if</span>(--num)<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = lfd+<span class="number">1</span>; i &lt;= maxfd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123;</span><br><span class="line">                len = read(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    FD_CLR(i,&amp;allset);</span><br><span class="line">                    close(i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                    buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                write(i,buf,len);</span><br><span class="line">                write(STDOUT_FILENO,buf,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select优缺点：</p>
<p>文件描述符数量有限，1024</p>
<p>检测满足条件的fd,自己添加业务逻辑提高小，提高了编码难度</p>
<p>优点，跨平台。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">fds:监听的文件描述符数组</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span>POLLIN POLLOUT POLLERR</span><br><span class="line">               <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span>传入是，给<span class="number">0</span>，如果满足对应事件，返回非<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">nfds:监听数组的实际有效的监听个数</span><br><span class="line">timeout:超时时长 milliseconds</span><br><span class="line">    <span class="number">-1</span> 阻塞等待</span><br><span class="line">    <span class="number">0</span> 立即返回，不阻塞进程</span><br><span class="line">    &gt;<span class="number">0</span>等待指定毫秒数</span><br><span class="line">返回值：返回满足对应监听事件的文件描述符总个数</span><br><span class="line">    <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)&#123;<span class="comment">/*lfd有读事件就绪*/</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>read函数返回0说明对端已经关闭<br>read 返回-1出错<br>errno = EAGIN or EWOULDBLOCK 设置非阻塞方式，没有数据到达<br>errno = EINTR 慢速系统调用被中断</p>
<p>errno = ECONNRESET说明连接被重置，需要close()移除监听序列</p>
<p>其他异常</p>
</li>
<li><p>优点：自带数组结构，可以将监听事件、返回事件集合分离，拓展监听上限，超出1024限制</p>
</li>
<li><p>缺点：不能跨平台，Linux,无法直接定位满足监听事件的文件描述符，编码难度大</p>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">size:创建的红黑树监听结点数量(仅供参考)</span><br><span class="line">返回值：指向新创建的红黑树根节点的fd</span><br><span class="line">    失败<span class="number">-1</span>，errno</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    epfd:epoll_create函数返回值，epfd</span><br><span class="line">    op：对红黑树的操作  EPOLL_CTL_ADD  EPOLL_CTL_MOD  EPOLL_CTL_DEL</span><br><span class="line">    event:本质上是一个<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>结构体地址</span></span><br><span class="line"><span class="class">        <span class="title">events</span>:</span></span><br><span class="line">                EPOLLIN EPOLLOUT  EPOLLERR</span><br><span class="line">        data：联合体</span><br><span class="line">              <span class="keyword">int</span> fd;对应监听事件的fd</span><br><span class="line">    成功<span class="number">0</span>，失败<span class="number">-1</span> errno</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">               <span class="keyword">void</span>        *ptr;</span><br><span class="line">               <span class="keyword">int</span>          fd;</span><br><span class="line">               <span class="keyword">uint32_t</span>     u32;<span class="comment">//不用</span></span><br><span class="line">               <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">    &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">               <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">               <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">//阻塞监听</span></span><br><span class="line">     epfd:epoll_create返回值，epfd</span><br><span class="line">     events:数组，传出参数，传出满足监听条件的fd结构体</span><br><span class="line">     maxevents:数组元素的总个数</span><br><span class="line">     timeout:同poll</span><br><span class="line">     返回值</span><br><span class="line">         &gt;<span class="number">0</span> 满足监听的总个数，可用作循环上限</span><br><span class="line">         <span class="number">0</span> 没有fd满足监听事件</span><br><span class="line">         失败<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>sys<span class="regexp">/fs/</span><span class="keyword">file</span>-max 当前计算机所能打开的最大文件个数，受硬件影响</span><br><span class="line">ulimit -a 当前用户下进程默认打开文件描述符个数，缺省为<span class="number">1024</span></span><br><span class="line">修改文件描述符上限</span><br><span class="line">sudo vi <span class="regexp">/ect/</span>security/limits.conf</span><br><span class="line">修改：</span><br><span class="line"> * soft nofile <span class="number">65535</span>--&gt;设置默认值， 可以通过形如ulimit -n <span class="number">20000</span>命令修改</span><br><span class="line"> * hard nofile <span class="number">1000000</span>--》命令修改上限</span><br></pre></td></tr></table></figure>
<p>显著提高程序中大量并发连接中只有少量活跃的情况下的系统cpu利用率</p>
<p>Epoll事件模型</p>
<p>ET边沿触发，只有数据到来才触发，不管缓存区是否还有数据</p>
<p>LT水平触发，只要有数据都会触发—默认采用模式(缓存区剩余未读尽数据会导致epoll_wait返回)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改边沿触发 event.events = EPOLLIN | EPOLLET;</span><br></pre></td></tr></table></figure>
<p>LT是缺省的工作方式，同时支持block unblock socket,传统的select poll都是这种模型代表</p>
<p>ET是高速工作方式，仅支持no-block socket,忙轮询</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;event);</span><br><span class="line"><span class="keyword">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(cfd,F_SETFL,flag);</span><br></pre></td></tr></table></figure>
<p>优点：高效，突破1024文件描述符,事件分离</p>
<p>缺点：不能跨平台Linux</p>
<h3 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h3><p>epoll ET 模式+非阻塞+void*ptr</p>
<p>不但要监听cfd的读事件，还要监听cfd的写事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__func__ 打印函数名</span><br><span class="line">__LINE__行号</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *epoll基于非阻塞I/O事件驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS  1024                                    <span class="comment">//监听上限数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述就绪文件描述符相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                                                 <span class="comment">//要监听的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> events;                                             <span class="comment">//对应的监听事件</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                                              <span class="comment">//泛型参数</span></span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);       <span class="comment">//回调函数</span></span><br><span class="line">    <span class="keyword">int</span> status;                                             <span class="comment">//是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">long</span> last_active;                                       <span class="comment">//记录每次加入红黑树 g_efd 的时间值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_efd;                                                  <span class="comment">//全局变量, 保存epoll_create返回的文件描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">MAX_EVENTS</span>+1];</span>                    <span class="comment">//自定义结构体类型数组. +1--&gt;listen fd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将结构体 myevent_s 成员变量 初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventset</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ev-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(ev-&gt;buf));</span><br><span class="line">    ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);                       <span class="comment">//调用eventset函数的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventadd</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;       <span class="comment">//EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status == <span class="number">0</span>) &#123;                                          <span class="comment">//已经在红黑树 g_efd 里</span></span><br><span class="line">        op = EPOLL_CTL_ADD;                 <span class="comment">//将其加入红黑树 g_efd, 并将status置1</span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)                       <span class="comment">//实际添加/修改</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add failed [fd=%d], events[%d]\n&quot;</span>, ev-&gt;fd, events);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;</span>, ev-&gt;fd, op, events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventdel</span><span class="params">(<span class="keyword">int</span> efd, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status != <span class="number">1</span>)                                        <span class="comment">//不在红黑树上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epv.data.ptr = ev;</span></span><br><span class="line">    epv.data.ptr = <span class="literal">NULL</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;                                             <span class="comment">//修改状态</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                <span class="comment">//从红黑树 efd 上将 ev-&gt;fd 摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptconn</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="keyword">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cfd = accept(lfd, (struct sockaddr *)&amp;<span class="built_in">cin</span>, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">            <span class="comment">/* 暂时不做出错处理 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: accept, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)                                <span class="comment">//从全局数组g_events中找一个空闲元素</span></span><br><span class="line">            <span class="keyword">if</span> (g_events[i].status == <span class="number">0</span>)                                <span class="comment">//类似于select中找值为-1的元素</span></span><br><span class="line">                <span class="keyword">break</span>;                                                  <span class="comment">//跳出 for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == MAX_EVENTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: max connect limit[%d]\n&quot;</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;                                                      <span class="comment">//跳出do while(0) 不执行后续代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) &#123;             <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */</span></span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);   </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         <span class="comment">//将cfd添加到红黑树g_efd中,监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;</span>, </span><br><span class="line">            inet_ntoa(<span class="built_in">cin</span>.sin_addr), ntohs(<span class="built_in">cin</span>.sin_port), g_events[i].last_active, i);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)arg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);            <span class="comment">//读文件描述符, 数据存入myevent_s成员buf中</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);        <span class="comment">//将该节点从红黑树上摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;                                <span class="comment">//手动添加字符串结束标记</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        eventset(ev, fd, senddata, ev);                     <span class="comment">//设置该 fd 对应的回调函数为 senddata</span></span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      <span class="comment">//将fd加入红黑树g_efd中,监听其写事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="comment">/* ev-g_events 地址相减得到偏移元素位置 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%ld], closed\n&quot;</span>, fd, ev-g_events);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv[fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)arg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, <span class="number">0</span>);                    <span class="comment">//直接将数据 回写给客户端。未作处理</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d], [%d]%s\n&quot;</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     <span class="comment">//将该fd的 回调函数改为 recvdata</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       <span class="comment">//从新添加到红黑树上， 设为监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);                                      <span class="comment">//关闭链接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error %s\n&quot;</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建 socket, 初始化lfd */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            <span class="comment">//将socket设为非阻塞</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                                               <span class="comment">//bzero(&amp;sin, sizeof(sin))</span></span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	bind(lfd, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">	listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */</span></span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventadd(int efd, int events, struct myevent_s *ev) */</span></span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = SERV_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);                           <span class="comment">//使用用户指定端口.如未指定,用默认端口</span></span><br><span class="line"></span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+<span class="number">1</span>);                 <span class="comment">//创建红黑树,返回给全局 g_efd </span></span><br><span class="line">    <span class="keyword">if</span> (g_efd &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create efd in %s err %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line"></span><br><span class="line">    initlistensocket(g_efd, port);                      <span class="comment">//初始化监听socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>+1];</span>            <span class="comment">//保存已经满足就绪事件的文件描述符数组 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;server running:port[%d]\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> checkpos = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);                          <span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkpos++) &#123;         <span class="comment">//一次循环检测100个。 使用checkpos控制检测对象</span></span><br><span class="line">            <span class="keyword">if</span> (checkpos == MAX_EVENTS)</span><br><span class="line">                checkpos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (g_events[checkpos].status != <span class="number">1</span>)         <span class="comment">//不在红黑树 g_efd 上</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> duration = now - g_events[checkpos].last_active;       <span class="comment">//客户端不活跃的世间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (duration &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                close(g_events[checkpos].fd);                           <span class="comment">//关闭与该客户端链接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] timeout\n&quot;</span>, g_events[checkpos].fd);</span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   <span class="comment">//将该客户端 从红黑树 g_efd移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/</span></span><br><span class="line">        <span class="keyword">int</span> nfd = epoll_wait(g_efd, events, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error, exit\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfd; i++) &#123;</span><br><span class="line">            <span class="comment">/*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)events[i].data.ptr;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           <span class="comment">//读就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">                <span class="comment">//lfd  EPOLLIN  </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         <span class="comment">//写就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出前释放所有资源 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ctags</span></span><br><span class="line"><span class="attribute">ctags</span> ./* -R</span><br><span class="line"><span class="attribute">Ctrl</span> + ] 光标置于调用函数上，跳转至函数定义位置</span><br><span class="line"><span class="attribute">Ctrl</span> + t 返回到此前跳转位置</span><br><span class="line"><span class="attribute">Ctrl</span>+ o 在屏幕左边列出文件列表，再次ctrl+o关闭</span><br><span class="line"><span class="attribute">F4</span>在屏幕右边列出文件列表，再次F<span class="number">4</span>关闭</span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>1.main()</p>
<p>   创建线程池</p>
<p>   向线程池添加任务，借助回调处理任务</p>
<p>   销毁线程池</p>
<p>2.pthreadpool_create()</p>
<p>   创建线程池结构体指针</p>
<p>   初始化线程池结构体</p>
<p> 创建N个任务线程</p>
<p>创建一个管理线程</p>
<p>失败时销毁开辟的所有空间（释放）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *(*function)(<span class="keyword">void</span> *);          <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                          <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="keyword">threadpool_task_t</span>;                    <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;               <span class="comment">/* 用于锁住本结构体 */</span>    </span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> thread_counter;     <span class="comment">/* 记录忙状态线程个数de琐 -- busy_thr_num */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_full;      <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_empty;     <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> *threads;                 <span class="comment">/* 存放线程池中每个线程的tid。数组 */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> adjust_tid;               <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="keyword">threadpool_task_t</span> *task_queue;      <span class="comment">/* 任务队列(数组首地址) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_thr_num;                    <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_thr_num;                    <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> live_thr_num;                   <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> busy_thr_num;                   <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> wait_exit_thr_num;              <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queue_front;                    <span class="comment">/* task_queue队头下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_rear;                     <span class="comment">/* task_queue队尾下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_size;                     <span class="comment">/* task_queue队中实际任务数 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_max_size;                 <span class="comment">/* task_queue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shutdown;                       <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.threadpool_thread()</p>
<p>进入子进程回调函数</p>
<p>接收参数 void *arg -&gt;pool 结构体</p>
<p>加锁-&gt;lock-&gt;整个结构体锁</p>
<p>判断条件变量 wait </p>
<p>4.adjust_thread()</p>
<p>循环10秒执行一次</p>
<p>进入管理者线程回调函数</p>
<p>接收参数 void *arg -&gt;pool 结构体</p>
<p>加锁-&gt;lock-&gt;整个结构体锁</p>
<p>获取管理线程池需要的变量</p>
<p>根据既定算法，使用上述变量，判断是否应该创建、销毁线程池中指定步长的线程</p>
<p>5.threadpool_add()</p>
<p>模拟产生任务，num[20]</p>
<p>设置回调函数，处理任务</p>
<p>内部实现：</p>
<p>加锁</p>
<p>初始化任务队列结构体成员，回调函数function arg</p>
<p>利用环形队列机制，实现添加任务，借助队尾指针挪移实现</p>
<p>唤醒阻塞在条件变量上的线程</p>
<p>解锁</p>
<p>6.从3.中的wait之后继续执行，处理任务</p>
<p>加锁</p>
<p>获取任务处理回调函数，及参数</p>
<p>利用环形队列机制，实现处理任务，借助队头指针挪移%实现</p>
<p>唤醒阻塞在条件变量上的server</p>
<p>解锁</p>
<p>加锁</p>
<p>改忙线程数++</p>
<p>解锁</p>
<p>执行处理任务的线程</p>
<p>加锁</p>
<p>改忙线程数—</p>
<p>解锁</p>
<p>7.创建销毁线程</p>
<p>管理者线程 task_num,live_num,busy_num</p>
<p>根据既定算法，使用上述变量判断是否应该创建、销毁线程池中指定步长的线程</p>
<p>如果满足创建条件</p>
<p>pthread_create() 回调任务线程函数 live_num++</p>
<p>如果满足销毁条件</p>
<p>wait_exit_thr_num = 10;</p>
<p>signal给阻塞在条件变量上的线程发送假满足信号</p>
<p>阻塞线程会被假信号唤醒，wait_exit_thr_num pthread_exit()</p>
<h3 id="TCP-UDP各自优缺点"><a href="#TCP-UDP各自优缺点" class="headerlink" title="TCP UDP各自优缺点"></a>TCP UDP各自优缺点</h3><p>TCP:面向连接的，可靠数据传输 对不稳定的网络层，采取完全弥补的通信方式，丢包重传</p>
<p>优点：稳定，数据流量稳定，速度稳定，顺序稳定</p>
<p>缺点：传输速度慢，效率低，开销大</p>
<p>使用场景：数据完整性要求较高，不追求效率</p>
<p>​                   大数据传输，文件传输</p>
<p>UDP:无连接，不可靠数据报传递 对于不稳定的网络层，采取完全不弥补的通信方式，默认还原网络状况</p>
<p>优点：传输速度快，效率高，开销低</p>
<p>缺点：不稳定</p>
<p>使用场景：对时效性要求较高，稳定性其次</p>
<p>游戏、视频会议，视频电话 应用层数据校验协议，弥补udp的不足</p>
<h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><p>UDP实现的C/S模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">accept(),connec()被舍弃</span><br><span class="line">recv()/send()只能用于TCP通信，替代read/write</span><br><span class="line">server:</span><br><span class="line">        lfd =  socket(AF_INET,STREAM,<span class="number">0</span>);SOCK_DGRAM报式协议</span><br><span class="line">        bind()</span><br><span class="line">        listen()可有可无</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            read(cfd,buf,)被替换--recvfrom()</span><br><span class="line">            小-大</span><br><span class="line">            write()被替换--sendto()</span><br><span class="line">        &#125;</span><br><span class="line">client:</span><br><span class="line">       connfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)</span><br><span class="line">       sendto(&#x27;服务器地址结构&#x27;，地址结构大小)</span><br><span class="line">       recvfrom()</span><br><span class="line">       close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">sockfd:套接字</span><br><span class="line">buf:缓存区地址</span><br><span class="line">len缓存区大小</span><br><span class="line">flags:<span class="number">0</span>默认值</span><br><span class="line">src_addr：(struct sockaddr*)&amp;addr;传出。对端地址结构</span><br><span class="line">addrlen:传入传出</span><br><span class="line">返回值：</span><br><span class="line">    成功接收数据字节数，<span class="number">-1</span>失败，<span class="number">0</span>对端关闭</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockfd:套接字</span><br><span class="line">buf:存储数据的缓存区地址</span><br><span class="line">len 数据长度</span><br><span class="line">flags:<span class="number">0</span>默认值</span><br><span class="line">src_addr：(struct sockaddr*)&amp;addr;传出。目标地址结构</span><br><span class="line">addrlen:地址结构长度</span><br><span class="line">返回值：</span><br><span class="line">    成功写出数据字节数，<span class="number">-1</span>失败，<span class="number">0</span>对端关闭</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,<span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        n = sendto(sockfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);         <span class="comment">//NULL:不关心对端信息</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h3><p>（domain)</p>
<p>对比TCP C/S模型，注意</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; domain AF_INET--&gt;AF_UNIX/AF_LOCAL</span><br><span class="line">                                                type SOCK_STREM/SOCK_DGRAM都可以</span><br><span class="line"><span class="number">2.</span>地址结构：sockaddr_in--&gt;sockaddr_un</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">    <span class="keyword">__kernel_sa_family_t</span> sum_family;</span><br><span class="line">    <span class="keyword">char</span> sun_path[UNIX_PATH_MAX];</span><br><span class="line">&#125;;</span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(addr.sun_path,<span class="string">&quot;srv.socket&quot;</span>);</span><br><span class="line"><span class="number">3.b</span>ind();</span><br><span class="line">bind(fd,(struct sockaddr*)&amp;addr,offsetof(struct sockaddr_un,sun_path)+<span class="built_in">strlen</span>(<span class="string">&quot;srv.socket&quot;</span>));</span><br><span class="line">bind()函数调用成功会创建一个socket文件,因此为保证bind成功，通常我们再bind之前,可以使用unlink</span><br><span class="line"><span class="number">4.</span>客户端不能依赖隐式绑定，并且应该在通信建立过程中，创建并初始化<span class="number">2</span>个地址结构</span><br><span class="line">    <span class="function">client_addr <span class="title">bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    server_addr <span class="title">connect</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR  <span class="meta-string">&quot;serv.socket&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd, len, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">/* servaddr total len */</span></span><br><span class="line"></span><br><span class="line">    unlink(SERV_ADDR);                              <span class="comment">/* 确保bind之前serv.sock文件不存在,bind会创建该文件 */</span></span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           <span class="comment">/* 参3不能是sizeof(servaddr) */</span></span><br><span class="line"></span><br><span class="line">    Listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accept ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);  <span class="comment">//AF_UNIX大小+108B</span></span><br><span class="line"></span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (<span class="keyword">socklen_t</span> *)&amp;len);</span><br><span class="line"></span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      <span class="comment">/* 得到文件名的长度 */</span></span><br><span class="line">        cliaddr.sun_path[len] = <span class="string">&#x27;\0&#x27;</span>;                       <span class="comment">/* 确保打印时,没有乱码出现 */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client bind filename %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((size = read(cfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            write(cfd, buf, size);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">client.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR <span class="meta-string">&quot;serv.socket&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_ADDR <span class="meta-string">&quot;clie.socket&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  cfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    cliaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);     <span class="comment">/* 计算客户端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    unlink(CLIE_ADDR);</span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 <span class="comment">/* 客户端也需要bind, 不能依赖自动绑定*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                                          <span class="comment">/* 构造server 地址 */</span></span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">/* 计算服务器端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对比本地套 和 网络套。<br>                    网络套接字                        本地套接字</p>
<pre><code>server：    lfd = socket(AF_INET, SOCK_STREAM, 0);            lfd = socket(AF_UNIX, SOCK_STREAM, 0);

        bzero() ---- struct sockaddr_in serv_addr;         bzero() ---- struct sockaddr_un serv_addr, clie_addr;

        serv_addr.sin_family = AF_INET;                       serv_addr.sun_family = AF_UNIX;    
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        serv_addr.sin_port = htons(8888);                   strcpy（serv_addr.sun_path, &quot;套接字文件名&quot;）
                                                         len = offsetof(sockaddr_un, sun_path) + strlen();
</code></pre><p>​<br>​            bind(lfd, (struct sockaddr <em>)&amp;serv_addr, sizeof());     unlink(“套接字文件名”);<br>​                                                              bind(lfd, (struct sockaddr </em>)&amp;serv_addr, len);  创建新文件<br>​<br>            Listen(lfd, 128);                               Listen(lfd, 128);</p>
<pre><code>        cfd = Accept(lfd, ()&amp;clie_addr, &amp;len);            cfd = Accept(lfd, ()&amp;clie_addr, &amp;len);  


client：        
        lfd = socket(AF_INET, SOCK_STREAM, 0);            lfd = socket(AF_UNIX, SOCK_STREAM, 0);

        &quot; 隐式绑定 IP+port&quot;                                  bzero() ---- struct sockaddr_un clie_addr;
                                                          clie_addr.sun_family = AF_UNIX;
                                                        strcpy（clie_addr.sun_path, &quot;client套接字文件名&quot;）
                                                         len = offsetof(sockaddr_un, sun_path) + strlen();
                                                       unlink( &quot;client套接字文件名&quot;);
                                                       bind(lfd, (struct sockaddr *)&amp;clie_addr, len);

        bzero() ---- struct sockaddr_in serv_addr;        bzero() ---- struct sockaddr_un serv_addr;

        serv_addr.sin_family = AF_INET;                          serv_addr.sun_family = AF_UNIX;

        inet_pton(AF_INT, &quot;服务器IP&quot;, &amp;sin_addr.s_addr)                            
                                                         strcpy（serv_addr.sun_path, &quot;server套接字文件名&quot;）
        serv_addr.sin_port = htons(&quot;服务器端口&quot;);        

                                                            len = offsetof(sockaddr_un, sun_path) + strlen();

        connect(lfd, &amp;serv_addr, sizeof());                         connect(lfd, &amp;serv_addr, len);
</code></pre><h3 id="libevent库"><a href="#libevent库" class="headerlink" title="libevent库"></a>libevent库</h3><p>开源、精简、跨平台、专注于网络通信</p>
<p>源码包安装：</p>
<p>./configure 检查安装环境生成makefile</p>
<p>make 生成.o文件和可执行文件</p>
<p>sudo make install 将必要的资源cp至系统指定目录</p>
<p>进入sample 目录，运行demo</p>
<p>编译使用库的.c文件时，需要加-levent</p>
<p>库名 libevent.so  /usr/local/lib <code>ll libevent*</code></p>
<h4 id="libevent框架"><a href="#libevent框架" class="headerlink" title="libevent框架"></a>libevent框架</h4><p>创建event_base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base*<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>*<span class="title">base</span> =</span> event_base_new();</span><br></pre></td></tr></table></figure>
<p>创建事件event</p>
<p>​        常规事件 <code>event_new();</code></p>
<p>​        bufferevent <code>bufferevent_socket_new();</code></p>
<p>将事件添加到base上</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event*ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure>
<p>循环监听事件满足</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base * base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>释放event_base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure>
<p>特性：基于<code>事件</code>的异步通信模型—回调</p>
<ul>
<li><p>启动循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base * base)</span></span>;</span><br><span class="line">只有event_new指定了EV_PERSIST才持续触发，否则只触发一次就跳出循环</span><br><span class="line">EV_WRITE|EV_PERSIST、 EV_READ|EV_PERSIST</span><br></pre></td></tr></table></figure></li>
<li><p>其他循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base*base,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line">在指定时间后停止循环</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base*base)</span></span>;</span><br><span class="line">立即停止循环</span><br></pre></td></tr></table></figure></li>
<li><p>查看支持哪些多路IO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">event_get_supported_methods</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前用的多路IO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base*base)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查看fork后子进程使用的event_base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用该函数后，父进程创建的base才能在子进程中使用</p>
</li>
</ul>
<h4 id="常规事件"><a href="#常规事件" class="headerlink" title="常规事件"></a>常规事件</h4><p>创建事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base*base,<span class="keyword">evutil_socket_t</span> fd,<span class="keyword">short</span> what,event_callback_fn cb,<span class="keyword">void</span>*arg)</span></span>;</span><br><span class="line">base :event_base_new()返回值</span><br><span class="line">   fd:绑定到event上的文件描述符</span><br><span class="line"> what:对应的事件（读、写、异常）</span><br><span class="line">     EV_READ</span><br><span class="line">     EV_WRITE</span><br><span class="line">     EV_PERSIST持续触发，结合event_base_dispatch函数使用，生效</span><br><span class="line"> cb:一旦事件满足监听条件，回调的函数</span><br><span class="line"> arg:回调函数的参数</span><br><span class="line"> 返回值：成功创建的event</span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,<span class="keyword">short</span>,<span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>添加事件到event_base</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event * ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line">tv：<span class="literal">NULL</span>,添加的事件不会超时</span><br><span class="line">    否则，tv以秒和微秒指定超时值</span><br></pre></td></tr></table></figure>
<p>从event_base摘下事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>未决和非未决</p>
<p>未决：有资格被处理，但还没有处理</p>
<p>非未决：没有资格被处理</p>
</li>
</ul>
<h4 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>带buf的事件对象</p>
<p>原理：bufferevent有两个缓存区，也是队列实现。先进先出，只能读一次</p>
<p>读：有数据—&gt;读回调函数被调用—&gt;使用bufferevent_read()读数据</p>
<p>写：使用bufferevent_write()—&gt;向缓冲区写数据—&gt;该缓存区有数据自动写出—&gt;写完，回调函数被调用，通知写数据完成</p>
<p>用bufferevent_read()来从读缓存中读数据。替代read()功能</p>
<ul>
<li>创建bufferevent</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent* <span class="title">bufferevent_socket_new</span><span class="params">(struct event_base*base,<span class="keyword">evutil_socket_t</span> fd,<span class="keyword">enum</span> bufferevent_options)</span></span>;</span><br><span class="line">fd:跟bufferevent绑定的文件描述符</span><br><span class="line">options:BEV_OPT_CLOSE_ON_FREE  </span><br><span class="line">返回：成功创建的bufferevent事件对象</span><br></pre></td></tr></table></figure>
<ul>
<li><p>释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>给bufferevent设置回调</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,bufferevent_data_cb readcb,bufferevent_data_cb writecb,bufferevent_event_cb eventcb,<span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line">readcb：设置读缓冲回调 read_cb&#123;bufferevent_read()读数据&#125;</span><br><span class="line">writecb:设置写缓冲回调，发送写成功通知 给调用者 可以为<span class="literal">NULL</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent*bev,<span class="keyword">short</span> events,<span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">events:BEV_EVENT_CONNECTED请求的连接过程已经完成，实现客户端可用</span><br><span class="line">eventcb:设置事件回调，也可传<span class="literal">NULL</span></span><br><span class="line">cbarg:上述回调函数参数</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> * ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_read</span><span class="params">(struct bufferevent * bev,<span class="keyword">void</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent * bev,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>禁用、启用缓冲区</p>
<p>默认：新建bufferevent写缓冲是enable的，而读缓冲是disable的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent * bufev,<span class="keyword">short</span> events)</span></span>;<span class="comment">//启用缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent * bufev,<span class="keyword">short</span> events)</span></span>;<span class="comment">//禁用</span></span><br><span class="line">events: EV_READ EV_WRITE EV_READ|EV_WRITE</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">bufferevent_get_enable</span><span class="params">(struct bufferevent * bufev)</span></span>;<span class="comment">//获取缓冲区禁用状态</span></span><br></pre></td></tr></table></figure>
<p>客户端</p>
<p>socket() connect()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, struct sockaddr *address,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line">address、len connect()第2，3个参数</span><br></pre></td></tr></table></figure>
<p>监听服务器：</p>
<p>socket() bind()listen()accept()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct event_base * base;</span></span></span><br><span class="line"><span class="function"><span class="params">    evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct event_base * base;</span></span></span><br><span class="line"><span class="function"><span class="params">     evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct sockaddr *sa,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> socklen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">flags:可识别的标志</span><br><span class="line">    LEV_OPT_CLOSE_ON_FREE：释放bufferevent时关闭底层传输端口，这将关闭底层套接字，释放底层bufferevent等</span><br><span class="line">    LEV_OPT_REUSEABLE端口复用，可以用|</span><br><span class="line">backlog:listen第<span class="number">2</span>个参数，传<span class="number">-1</span>：表默认最大值</span><br><span class="line">sa:服务器自己的地址结构IP+Port</span><br><span class="line">socklen:sa的长度</span><br><span class="line">socket bind listen accept</span><br><span class="line">返回值：成功创建的监听器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> sock,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>*ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">listener:evconnlistener_new_bind返回值</span><br><span class="line">sock:用于通信的文件描述符</span><br><span class="line">addr:客户端IP+addr</span><br><span class="line">len:addr的len</span><br><span class="line">ptr:外部ptr传递进来值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>释放监听服务器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener*lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>服务器</p>
<p>1.创建一个event_base</p>
<p>2.创建一个bufferevent事件对象 bufferevent_socket_new();</p>
<p>3.使用bufferevent_setcb()给read,write,event设置回调，</p>
<p>4.当监听的事件满足时，read_cb会被调用，在其内部bufferevent_read()读</p>
<p>5.创建一个监听服务器evconnlistener_new_bind(),设置其回调函数，当有客户端成功连接时，这个回调函数会被调用</p>
<p>6.listener_cb()在函数内部完成与客户端通信</p>
<p>7.设置bufferevent的读写缓冲区enable、disable</p>
<p>8.启动循环，event_base_dispatch</p>
<p>9.释放资源</p>
<p>客户端</p>
<p>1.创建event_base</p>
<p>2.使用bufferevent_socket_new()创建一个用于跟服务器通信的bufferevent事件对象</p>
<p>3.使用bufferevent_socket_connect()连接服务器</p>
<p>4.使用buffer_setcb()给bufferevent对象的readcb,writecb,eventcb设置回调</p>
<p>5.设置bufferevent对象的读写缓冲区</p>
<p>6.接收、发送数据 bufferevent_read() bufferevent_write()</p>
<p>7.启动循环监听event_base_dispath()</p>
<p>8.释放资源</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h4><ul>
<li>请求行</li>
<li>请求头</li>
<li>空行（必须要有）</li>
<li>请求数据</li>
</ul>
<p>GET:</p>
<p>请求指定页面信息，并返回实体主体</p>
<p>POST:</p>
<p>向指定资源提交数据进行处理请求，数据被包含在请求体中。POST请求可能导致新的资源建立或已有资源修改</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span>  /hello.c HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="应答消息"><a href="#应答消息" class="headerlink" title="应答消息"></a>应答消息</h3><ul>
<li>状态行：包括协议版本号，状态码，状态信息</li>
<li>消息报头</li>
<li>空行：必须要有</li>
<li>响应正文</li>
</ul>
<p><code>telnet</code>调试</p>
<p><code>telnet 127.0.0.1 9999</code></p>
<p>GET /hello.c HTTP/1.1</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/10/04/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/04/linux/" class="post-title-link" itemprop="url">linux</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-04 14:04:05" itemprop="dateCreated datePublished" datetime="2021-10-04T14:04:05+08:00">2021-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-07 14:35:10" itemprop="dateModified" datetime="2021-11-07T14:35:10+08:00">2021-11-07</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/04/linux/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/04/linux/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Linux 系统目录</p>
<ul>
<li>bin 二进制可执行文件</li>
<li>boot 开机启动程序</li>
<li>dev 设备文件</li>
<li>home 普通用户</li>
<li>etc:用户信息和系统配置文件 password group</li>
<li>lib 库文件</li>
<li>root 管理员宿主目录</li>
<li>usr用户资源目录</li>
</ul>
<p>文件类型：</p>
<ul>
<li>普通文件 -</li>
<li>目录文件 d</li>
<li>字符设备文件 c</li>
<li>块设备文件 b</li>
<li>软连接 l</li>
<li>管道文件 p</li>
<li>套接字 s</li>
<li>未知文件</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>which:查看指定命令所在路径</li>
<li>pwd： 查看当前所在路径</li>
<li>rmdir:删除空目录</li>
<li>rm : rm file <code>rm dir -rf</code> f强制删除</li>
<li>cp </li>
<li>mv</li>
<li>cat</li>
<li>tac</li>
</ul>
<p>软连接：快捷方式</p>
<p><code>ln -s file file.s</code>创建软连接</p>
<p>为保证软连接可以随意移动，需保证用绝对路径创建</p>
<p>硬链接：</p>
<p><code>ln file file.h</code>增加硬链接文件计数，共享Inode</p>
<ul>
<li><p>whoami</p>
<p><code>sudo su</code>切换root用户</p>
</li>
<li><p>chmod </p>
<p><code>chmod u+x a.c</code>给所有者添加可执行权限</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u表示用户</span><br><span class="line">g表示同组用户</span><br><span class="line">o表示其他用户</span><br><span class="line"><span class="keyword">a</span>表示所有用户</span><br></pre></td></tr></table></figure>
<p>rwx r:4 w:2 x:1</p>
<p><code>chmod 471 a.c</code></p>
</li>
<li><p>chown</p>
<p><code>sudo chown new_user a.c</code>更改文件所有者</p>
</li>
<li><p>adduser</p>
<p>sudo adduser 新用户名</p>
</li>
<li><p>addgroup 创建用户组</p>
<p><code>sudo addgroup g88</code></p>
</li>
<li><p>chgrp</p>
<p><code>sudo chgrp g88 a.c</code></p>
<p><code>sudo chown nobody:nogroup a.c</code>同时修改用户和用户组</p>
</li>
<li><p>deluser</p>
<p><code>sudo deluser wangwu</code></p>
</li>
<li><p>find</p>
</li>
</ul>
<p><code>find ./ -type &#39;l&#39;</code>查找当前目录下软连接</p>
<p><code>find ./ -name &#39;*.jpg&#39;</code>按文件名搜索</p>
<p><code>find ./ -maxdepth 1 - name &#39;*.jpg&#39;</code>指定搜索层级</p>
<p><code>find ./ -size +20M -size -50M</code>文件大小</p>
<p><code>-atime -mtime -ctime</code></p>
<p><code>find ./ -ctime 1</code> 当天内修改过</p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -exec ls -l &#123;&#125; \;</code></p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -ok rm -r &#123;&#125; \;</code></p>
<ul>
<li><p>grep 找文件内容</p>
<p><code>grep -r &#39;copy&#39; ./ -n</code> -n显示行号</p>
</li>
<li><p>ps</p>
<p><code>ps aux</code> </p>
<p><code>ps aux |grep &#39;kernel&#39;</code></p>
</li>
</ul>
<p>find ./ -type f | xargs ls -l </p>
<p>-xargs :将find搜索的结果集执行某一命令，当结果集数量过大时，可以分片映射</p>
<p>-print0:</p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -print0 | xargs print0 ls -l</code></p>
<p>awk 按列拆分，sed按行拆分</p>
<ul>
<li>软件安装：</li>
</ul>
<p><code>sudo apt-get update</code>更新软件源列表</p>
<p>卸载<code>sudo apt-get remove</code></p>
<p>安装deb文件</p>
<p>sudo dpkg -i xx.deb</p>
<p>源码安装：</p>
<p>   1.解压缩代码包</p>
<ol>
<li><p>cd dir</p>
</li>
<li><p>./configure</p>
<p>检测文件是否缺失，创建makefile，检测编译环境</p>
</li>
<li><p>make</p>
<p>编译源码，生成库和可执行文件</p>
</li>
<li><p>sudo make install</p>
<p>把库和可执行程序安装到系统路径下</p>
</li>
<li><p>sudo make distclean</p>
<p>删除和卸载软件</p>
</li>
</ol>
<p>压缩</p>
<ul>
<li><p>tar</p>
<p><code>tar zcvf 要生成的压缩包名 压缩材料</code> z: 调用gzip, c： creat, v：显示压缩过程，可以没有，f生成文件名</p>
<p>先调用gzip 然后调用tar打包</p>
</li>
<li><p>gzip</p>
<p><code>gzip 文件名</code>压缩一个文件</p>
<p><code>gzip a.c</code> 得到a.c.gz</p>
</li>
<li><p>bzip2</p>
<p><code>tar jcvf test.tar.gz file1 dir2</code></p>
</li>
<li><p>解压，将压缩命令中的c替换为x</p>
</li>
<li><p>rar </p>
<p><code>rar a -r newdir dir</code></p>
<p>解压</p>
<p><code>unrar x rartest.rar</code></p>
</li>
</ul>
<p><code>sudo aptitude show tree</code>显示软件是否安装</p>
<ul>
<li><p>zip </p>
<p><code>zip -r dir.zip dir</code></p>
<p>解压</p>
<p>unzip dir.zip</p>
</li>
<li><p>who </p>
</li>
<li>jobs当前后台运行的作业</li>
<li>fg 前台</li>
<li>bg后台</li>
<li>kill</li>
<li>env 环境变量</li>
<li>top 任务管理器</li>
</ul>
<p>设置密码</p>
<p>sudo passwd 用户名</p>
<p>切换用户</p>
<p>su 用户名</p>
<ul>
<li>ifconfig 查看ip地址</li>
<li>man 查看手册</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.可执行程序或<span class="keyword">shell</span><span class="bash">命令</span></span><br><span class="line"><span class="number">2</span>.系统调用</span><br><span class="line"><span class="number">3</span>.库调用</span><br><span class="line"><span class="number">5</span>.文件格式、规范</span><br><span class="line"><span class="number">9</span>.内核例程</span><br></pre></td></tr></table></figure>
<ul>
<li>alias 起别名</li>
<li>unmask 指定用户创建文件时的掩码</li>
<li>创建终端Ctrl+Shift +t</li>
<li>切换标签Alt+n</li>
<li>新开终端Ctrl+Shift + n</li>
</ul>
<p>光标移动到第一个字符contrl+a</p>
<p>移动到最后一个字符contrl+e</p>
<p>清空输入control+u</p>
<p>空目录大小4096</p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><ul>
<li><p>命令模式i a o,I A O,s S切换到文本模式,:切换到末行模式，zz保存退出</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i:</span>插入光标前一个字符</span><br><span class="line"><span class="symbol">I:</span>插入行首</span><br><span class="line"><span class="symbol">a:</span>插入光标后一个字符</span><br><span class="line"><span class="symbol">A:</span>插入行末</span><br><span class="line"><span class="symbol">o:</span>向下新开一行，插入行首</span><br><span class="line"><span class="symbol">O:</span>向上新开一行，插入行首</span><br><span class="line"><span class="symbol">s:</span>删除当前字符，插入</span><br><span class="line"><span class="symbol">S:</span>删除当前行，插入</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>文本模式ESC切换到文本模式</p>
</li>
<li><p>末行模式w:保存 q:退出，两次ESC回到命令模式</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">h：左移</span><br><span class="line"><span class="symbol">j:</span>下移</span><br><span class="line"><span class="symbol">k:</span>上移</span><br><span class="line"><span class="symbol">l:</span>右移</span><br><span class="line"></span><br><span class="line">跳转到指定行</span><br><span class="line"><span class="number">1</span>.88G(命令模式)</span><br><span class="line"><span class="number">2</span>.<span class="symbol">:</span><span class="number">88</span>(末行模式)</span><br><span class="line"></span><br><span class="line">跳转文件首：</span><br><span class="line">gg(命令模式)</span><br><span class="line"></span><br><span class="line">跳转文件尾</span><br><span class="line">G(命令模式)</span><br><span class="line"></span><br><span class="line">自动格式化程序：</span><br><span class="line">gg=G(命令模式)</span><br><span class="line"></span><br><span class="line">括号对应：</span><br><span class="line"><span class="string">%(命令模式)</span></span><br><span class="line"></span><br><span class="line">删除单个字符</span><br><span class="line">x(命令模式)</span><br><span class="line"></span><br><span class="line">删除单词</span><br><span class="line">dw(光标置于首字母)</span><br><span class="line"></span><br><span class="line">删除光标至行尾</span><br><span class="line">D或d$</span><br><span class="line"></span><br><span class="line">删除光标到行首</span><br><span class="line">d0</span><br><span class="line"></span><br><span class="line">光标移至行首</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">光标移至行尾</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">替换单个字符</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line">删除指定区域：</span><br><span class="line">按v切换为可视模式，使用hjkl来选中待删除区域，按d删除该区域数据</span><br><span class="line"></span><br><span class="line">删除指定行</span><br><span class="line">dd</span><br><span class="line"></span><br><span class="line">删除指定N行</span><br><span class="line">ndd</span><br><span class="line"></span><br><span class="line">粘贴<span class="symbol">:</span></span><br><span class="line">p粘至光标所在下一行</span><br><span class="line">P粘在光标所在上一行</span><br><span class="line"></span><br><span class="line">复制一行：</span><br><span class="line">yy</span><br><span class="line"></span><br><span class="line">复制多行：</span><br><span class="line">nyy</span><br><span class="line"></span><br><span class="line">查找</span><br><span class="line"><span class="number">1</span>.找设想内容</span><br><span class="line">命令模式下，按“/”输入欲搜索关键字，回车，使用n检索下一个</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.找 看到的内容</span><br><span class="line">将光标置于任意一个字符上，按“*、<span class="comment">#”查找</span></span><br><span class="line"></span><br><span class="line">单行替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:s</span> /源字符串/替换字符串</span><br><span class="line"></span><br><span class="line">通篇替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:%s</span> /源字符串/替换字符串 只替换每一行首个</span><br><span class="line"><span class="symbol">:%s</span> /源字符串/替换字符串/g 替换所有</span><br><span class="line"></span><br><span class="line">指定行替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:</span>起始行号，终止行号s /源字符串/替换字符串/g </span><br><span class="line"></span><br><span class="line">撤销：</span><br><span class="line">u</span><br><span class="line"></span><br><span class="line">反撤销：</span><br><span class="line">Ctrl + r</span><br><span class="line"></span><br><span class="line">分屏</span><br><span class="line"><span class="symbol">:sp</span> 横屏分 Ctrl + ww切换</span><br><span class="line"><span class="symbol">:vsp</span> 竖屏分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">跳转至man手册</span><br><span class="line">将光标置于待查看函数单词，使用K跳转，(指定卷：nK</span><br><span class="line"></span><br><span class="line">查看宏定义</span><br><span class="line">将光标置于待查看宏定义单词，[ d</span><br><span class="line"></span><br><span class="line">末行模式<span class="symbol">:</span>! 执行shell 命令</span><br></pre></td></tr></table></figure>
<p>配置vim</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="string">/etc/vim/vimrc</span></span><br><span class="line">2. ~<span class="string">/.vimrc</span></span><br><span class="line">~<span class="string">./vimrc</span>优先级高</span><br></pre></td></tr></table></figure>
<h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><p>预处理 gcc -E 展开宏、头文件，替换条件编译，删除注释、空白，空行</p>
<p>编译 gcc -S 检查语法规范 编译消耗时间最多</p>
<p>汇编：gcc -c将汇编指令翻译成机器指令</p>
<p>链接：无参数 数据段合并，地址回填</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-I 指定头文件</span></span><br><span class="line">头文件与.c文件不在同一目录</span><br><span class="line">gcc -I ./inc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="deletion">-c 只做预处理、编译、汇编</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-g: 编译时添加调试信息</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-On （n = 0-3） 编译优化</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-Wall 提示更多警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-D&lt;DEF&gt; 编译时定义宏</span></span><br><span class="line">gcc hello.c -D HELLO</span><br></pre></td></tr></table></figure>
<h3 id="动态库、静态库"><a href="#动态库、静态库" class="headerlink" title="动态库、静态库"></a>动态库、静态库</h3><p>提高编译效率</p>
<p>静态库：对空间要求较低，对时间要求较高的核心程序</p>
<p>动态库：对时间要求较低，对空间要求较高</p>
<p>只做静态库的方法：静态库lib开头 .a结尾</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ar</span> <span class="selector-tag">rcs</span> <span class="selector-tag">libmylib</span><span class="selector-class">.a</span> <span class="selector-tag">file1</span><span class="selector-class">.o</span>（得先编译成<span class="selector-class">.o</span>文件)</span><br></pre></td></tr></table></figure>
<p>1.将.c生成.o文件</p>
<p>gcc -c add.c -o add.o</p>
<p>2.使用ar工具制做静态库</p>
<p>ar rcs libmymath.a add.o sub.o</p>
<p>编译错误会有行号信息，链接错误没有行号，显示ld returned 1 exit status</p>
<p>3.使用静态库：</p>
<p><code>gcc test.c libmathlib.a -o test</code></p>
<p><code>gcc test.c ./lib/libmath.a -o a.out -I ./inc</code></p>
<p>lib 存放.a文件</p>
<p>inc 存放相应头文件,必须有相应头文件，记录函数声明信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防卫式声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MYMATH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MYMATH_H_</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div1</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>动态库制作</p>
<p>1、将.c生成.o文件（生成与位置无关的代码 -fPIC）</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span> -o <span class="keyword">add</span>.o -fPIC</span><br></pre></td></tr></table></figure>
<p>2.使用gcc -shared 制作动态库</p>
<p>gcc -shared -o lib库名.so add.o sub.o div.o</p>
<p>3.编译可执行程序时，指定所使用的动态库，-l指定库名，-L指定库路径</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o a.<span class="keyword">out</span> -lmymath -L ./<span class="class"><span class="keyword">lib</span> -<span class="title">I</span> ./<span class="title">inc</span></span></span><br></pre></td></tr></table></figure>
<p>4.运行可执行程序出错</p>
<p>原因：</p>
<p>链接器：工作于链接阶段，工作时需要-l,和-L</p>
<p>动态链接器：工作于程序运行阶段，工作时需提供动态库所在的目录地址</p>
<p>1.通过环境变量设置<code>export LD_LIBRARY_PATH = 动态库路径</code> 临时生效，重启终端环境变量失效 环境变量只与进程有关</p>
<p>2.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">永久生效</span><br><span class="line">1）</span><br><span class="line">vi ~/.bashrc//改变bash环境变量</span><br><span class="line">2）写入 <span class="built_in">export</span> LD_LIBRARY_PATH= 动态库路径 保存</span><br><span class="line">3）使环境变量生效</span><br><span class="line">. .bashrc 或者 <span class="built_in">source</span> .bashrc 或者 重启终端</span><br></pre></td></tr></table></figure>
<p><code>ldd a.out</code> 查看a.out 加载哪些动态库，及动态库路径</p>
<p>3.直接把动态库放到与标准c库一起，</p>
<p> <code>cp libmymath.so /lib</code></p>
<ol>
<li><p>配置文件法</p>
<p>1）sudo vi /etc/ld.so.conf</p>
<p>2）写入动态库绝对路径 保存</p>
<p>3） sudo ldconfig -v 使配置文件生效</p>
<p>ldd a.out 查看，失败not found</p>
</li>
</ol>
<p>数据段合并</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20211004203908020.png" alt="image-20211004203908020"></p>
<p>连接时会把.text段和.rodata段合并,.data段和.bss段合并，节省空间</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>-g 使用该参数编译可执行程序</p>
<p>gdb a.out</p>
<p>基础指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>: <span class="built_in">list</span> <span class="number">1</span> <span class="comment">//列出源码。根据源码指定行号设置断点</span></span><br><span class="line">b <span class="number">52</span> <span class="comment">//break 在52行设置断点</span></span><br><span class="line">run/r <span class="comment">//run</span></span><br><span class="line">n/next <span class="comment">//next,下一条指令，如果当前断点是函数则不进入函数</span></span><br><span class="line">s/step <span class="comment">//step，下一条指令，进入函数</span></span><br><span class="line">p/print :p i<span class="comment">//print i</span></span><br><span class="line"><span class="keyword">continue</span>: 继续执行断点后续指令</span><br><span class="line">quit: 退出gdb当前调试</span><br></pre></td></tr></table></figure>
<p>其他指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用run查找段错误位置</span><br><span class="line">finish 结束当前函数调用，回到调用点</span><br><span class="line">start 启动调试</span><br><span class="line">    </span><br><span class="line"><span class="built_in">set</span> args 设置命令行参数</span><br><span class="line">run 后面也能加命令行参数</span><br><span class="line">run argv[<span class="number">1</span>] argv[<span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">info b 断点信息表</span><br><span class="line">    </span><br><span class="line">b <span class="number">41</span> <span class="keyword">if</span> i = <span class="number">4</span> <span class="comment">//条件断点</span></span><br><span class="line">    </span><br><span class="line">ptype j <span class="comment">//查看变量类型</span></span><br><span class="line">    </span><br><span class="line">bt/backtrace 查看栈帧信息</span><br><span class="line"></span><br><span class="line">frame <span class="number">1</span> 切换栈帧</span><br><span class="line">    </span><br><span class="line">display i <span class="comment">//设置追踪i</span></span><br><span class="line"></span><br><span class="line">undisplay 编号<span class="comment">//取消跟踪变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> 删除断点</span><br></pre></td></tr></table></figure>
<p>栈帧：随着函数调用而在stack上开辟的一片内存空间，用于存放函数调用而产生的局部变量和临时值</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><ul>
<li><p>1个规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖条件</span><br><span class="line">	（一个tab缩进）命令</span><br><span class="line"><span class="section">test: test.c</span></span><br><span class="line">	gcc -o test test.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.o</span></span><br><span class="line">	gcc hello.o -o hello</span><br><span class="line">	 </span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o </span><br></pre></td></tr></table></figure>
<p>all:指定makefile的终极目标</p>
</li>
</ul>
<p>1、目标的时间必须晚于依赖条件的时间，否则，更新目录</p>
<p>2、依赖条件不存在，找寻新的规则去产生依赖</p>
<ul>
<li><p>2个函数</p>
<p>wildcard </p>
<p>patsubst</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#找到当前目录所有后缀为.c的文件赋值给src,将文件名组成列表赋值给变量src</span></span><br><span class="line"></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c %.o <span class="variable">$(src)</span>)</span></span><br><span class="line"><span class="comment">#将参数3中，包含参数1的部分，替换为参数2</span></span><br><span class="line"><span class="comment">#把src变量里所有后缀为.c的文件替换为.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:#(没有依赖)</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out <span class="comment">#-rm 出错依然执行</span></span><br></pre></td></tr></table></figure>
<p>make clean -n//尝试执行，但不真正执行</p>
</li>
</ul>
<ul>
<li>3个自动变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span>:在规则的命令中表示规则中的目标</span><br><span class="line"><span class="variable">$&lt;</span>：在规则的命令中，表示第一个依赖条件,如果将该变量应用在模式规则中，它可将依赖列表中的依赖依次取出，套用规则</span><br><span class="line"><span class="variable">$^</span>：在规则的命令中，表示所有依赖条件</span><br><span class="line"></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span><span class="comment"># add.c sub.c hello.c</span></span><br><span class="line">obj = <span class="variable">$(subsubst %.c %.o <span class="variable">$(src)</span>)</span><span class="comment"># add.o sub.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">All:a.out</span></span><br><span class="line"></span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out</span><br></pre></td></tr></table></figure>
<p>模式规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span><span class="comment"># add.c sub.c hello.c</span></span><br><span class="line">obj = <span class="variable">$(subsubst %.c %.o <span class="variable">$(src)</span>)</span><span class="comment"># add.o sub.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">All:a.out</span></span><br><span class="line"></span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out</span><br></pre></td></tr></table></figure>
<p>静态模式规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>:%.o:%.c</span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>生成伪目标</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean ALL</span></span><br></pre></td></tr></table></figure>
<p>调加参数</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myArgs = -Wall -g</span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br></pre></td></tr></table></figure>
<p>makefile 名字为m1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f m1</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p>-n模拟执行make,make clean 命令</p>
<p>-f：指定文件执行make命令</p>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p>系统调用</p>
<ul>
<li>open 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//根据error num 返回错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags)</span></span>;<span class="comment">//O_RDONLY O_WRONLY ORDWR O_CREAT O_APPEND O_EXCL（检查文件是否存在） O_TRUNC（把文件清零） O_NONBLOCK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags,<span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//不是C语言支持重载，而是open支持可变参数</span></span><br><span class="line"><span class="comment">//返回新的文件描述符，错误返回-1，并设置errno</span></span><br><span class="line"><span class="comment">//mode_t 8进制整数 读写执行权限，需要创建时指定，同时权限受unmask限制 mode&amp;~unmask</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> count)</span></span>;<span class="comment">//count缓冲区大小</span></span><br><span class="line"><span class="comment">//成功返回读取得到的字节数,失败返回-1</span></span><br><span class="line"><span class="comment">//-1 并且errno = EAGIN 或EWOULDBLOCK说明不是read失败，而是read在以非阻塞方式读一个设备文件(网络文件），并且文件无数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> count)</span></span>;<span class="comment">//count实际写出内容的大小</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open argv1 error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open argv2 error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((n = read(fd1,buf,<span class="number">1024</span>))!= <span class="number">0</span>)&#123;</span><br><span class="line">        write(fd2,buf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>strace 跟踪程序运行时所进行的系统调用</p>
<p>系统缓冲区</p>
<p>read write无缓冲IO</p>
<p>预读入缓输出</p>
<ul>
<li><p>文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stdin</span> <span class="number">0</span> STDIN_FILENO</span><br><span class="line"><span class="built_in">stdout</span> <span class="number">1</span> STDOUT_FILENO</span><br><span class="line"><span class="built_in">stderr</span> <span class="number">2</span> STDERR_FILENO</span><br></pre></td></tr></table></figure>
<p>最多1024个，新建文件描述符是目前进程最小可用的描述符</p>
</li>
<li><p>阻塞、非阻塞:</p>
<p>阻塞是设备文件、网络文件的属性</p>
<p>读常规文件是不会阻塞的</p>
<p>产生阻塞的场景：读设备文件，读网络文件</p>
<p>/dev/tty —终端文件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> fd,n;</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    tryagain:</span><br><span class="line">        n = read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EAGAIN)&#123;</span><br><span class="line">                perror(<span class="string">&quot;read STDIN_FILENO&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                write(STDOUT_FILENO,<span class="string">&quot;try again\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>));</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">goto</span> tryagain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fcntl函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,...<span class="comment">/*arg*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> flags,n;</span><br><span class="line">    flags = fcntl(STDIN_FILE,F_GETFL);<span class="comment">//获取stdin属性信息</span></span><br><span class="line">    <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(STDIN_FILENO,FSETFL,flags);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取文件状态 F_GETFL</p>
<p>设置文件状态 F_SETFL</p>
<ul>
<li><p>lseek</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">whence <span class="comment">//SEEK_SET SEEK_SET SEEK_END</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>文件读写使用同一偏移位置</p>
</li>
<li><p>使用lseek获取、</p>
</li>
<li>拓展文件大小，要使文件大小真正发生变化，需要发生IO操作 </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trunate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;<span class="comment">//拓展一个现有文件大小</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>od -tcx filename 查看文件的16进制表示</p>
<p>od -tcd filename 查看文件的10进制表示</p>
<ul>
<li><p>传入参数</p>
<p>1.指针作为函数参数</p>
<p>2.const 修饰</p>
<p>3.指针指向有效区域，在函数内部做读入操作</p>
</li>
<li><p>传出参数</p>
<p>1.指针作为函数参数</p>
<p>2.指针指向的空间可以无意义，但有效</p>
<p>3.函数对其进行写操作</p>
<p>4.函数调用后，充当返回值</p>
</li>
<li><p>传入传出参数</p>
<p>1.指针作为函数参数</p>
<p>2.在函数调用前，指针指向的空间有意义</p>
<p>3.在函数内部，先读后写</p>
<p>4.函数调用结束后，充当函数返回值</p>
</li>
</ul>
<ul>
<li><p>inode 本质为结构体，存储文件属性信息</p>
</li>
<li><p>dentry 目录项： 文件名、inode号 硬链接，相同inode,不同dentry</p>
</li>
<li><p>stat 获取文件属性 (从inode中获取)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,struct stat * buf)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    path:文件路径</span><br><span class="line">     buf:传出参数，存放文件属性</span><br><span class="line">获取文件大小： buf.st_size</span><br><span class="line">获取文件类型： buf.st_mode</span><br><span class="line">获取文件权限： buf.st_mode</span><br></pre></td></tr></table></figure>
<p>stat符号穿透，stat检查符号链接时，直接获取符号链接引用的真正文件信息</p>
<p>lstat不会进行符号穿透</p>
<p>vim,cat会穿透符号链接，ls -l 不会</p>
</li>
<li><p>link 函数：创建硬链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>unlink 函数:删除一个文件的目录项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>unlink :如果文件硬链接数到0了，但该文件仍不会马上释放，需等到所有打开该文件的进程关闭</p>
</li>
<li><p>symlink创建符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> * newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<p>readlink读软连接本身</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readlink t.soft</span><br></pre></td></tr></table></figure></li>
<li><p>readlink</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path,<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>rename</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> * newpath)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>getcwd:获取工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>chdir：改变工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文件权限</p>
<p>r:目录可以被浏览</p>
<p>w:创建删除修改文件</p>
<p>x:可以被进入</p>
</li>
<li><p>opendir函数 库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR*<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>closedir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>readdir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR*dirp)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    close(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span> * name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readdir</span><span class="params">(<span class="keyword">char</span> *dir)</span></span>&#123;</span><br><span class="line">    DIR *dp = opendir(dir);</span><br><span class="line">    <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp))!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sdp-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(name,<span class="string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);</span><br><span class="line">        isFile(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span> * name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    ret = stat(name, &amp;sb);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;</span><br><span class="line">        readdir(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%ld\n&quot;</span>,name,sb.st_size);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;</span><br><span class="line">        isFile(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> isFile(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>dup</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line">oldfd:已有文件描述符</span><br><span class="line">newfd:新文件描述符</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd,<span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">把旧的复制给新的，返回newfd</span><br><span class="line">newfd指向和oldfd一致</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">0</span>);<span class="comment">//0被占用，fcnt使用文件描述符表最小可用文件描述符返回</span></span><br><span class="line"><span class="keyword">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">7</span>);<span class="comment">//7未被占用，可以被使用</span></span><br></pre></td></tr></table></figure>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进程：占用内存、cpu等系统资源</p>
</li>
<li><p>PCB</p>
<p>进程id</p>
<p>进程状态：就绪，运行，挂起，停止</p>
<p>进程切换时需要保存和恢复的一些寄存器值</p>
<p>描述虚拟地址空间信息</p>
<p>描述控制终端的信息</p>
<p>当前工作位置</p>
<p>文件描述符表</p>
<p>和信号相关信息</p>
<p>用户id和组id</p>
<p>会话和进程组</p>
<p>进程可以使用的资源上限</p>
</li>
</ul>
<ul>
<li>环境变量</li>
</ul>
<p>PATH SHELL TERM LANG HOME <code>echo $PATH</code></p>
<ul>
<li><p>进程控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>进程共享</p>
<p>刚发生父子进程fork之后</p>
<p>全局变量，.data,.text,栈，堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式相同</p>
<p>不同：</p>
<p>进程id,fork返回值，父进程id，进程运行时间，闹钟（定时器），未决信号集</p>
<p>读时共享，写时复制</p>
<p>父子进程共享 文件描述符，mmap映射区</p>
</li>
<li><p>gdb调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child 跟踪子进程</span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br></pre></td></tr></table></figure></li>
<li><p>exec函数族</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程id不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> * arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>execlp，加载一个进程，借助PATH环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span><span class="comment">/*相当于argv[0],没啥用*/</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//只有execlp出错时才返回-1，否则之后代码不再执行</span></span><br><span class="line">perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;./a.out&quot;</span>,<span class="string">&quot;./a.out&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  只有execve是系统调用</p>
<ul>
<li><p>孤儿进程</p>
<p>父进程先于子进程结束，子进程的父进程将成为init进程</p>
</li>
<li><p>僵尸进程</p>
<p>进程终止，父进程尚未收回，子进程残留资源（PCB)存放于内核中，变为僵尸进程</p>
</li>
<li><p>wait函数（waitpid(-1,&amp;status,0);)</p>
<p>阻塞等待子进程退出</p>
<p>回收子进程残留资源</p>
<p>获取子进程结束状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> the child terminated normally</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">    <span class="keyword">return</span> the <span class="built_in">exit</span> status of the child</span><br><span class="line">WIFSIGNALED(status)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> the child process was terminated by a signal</span><br><span class="line">WTERMSIG(status)</span><br><span class="line">       <span class="keyword">return</span> the number of the signal that caused the child process to <span class="built_in">terminate</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
<li><p>waitpid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options)</span></span>;<span class="comment">//一次wait/waitpid函数调用，只能回收一个子进程</span></span><br><span class="line">正常回收返回pid</span><br><span class="line">如果设置WNOHANG，子进程未结束，返回<span class="number">0</span></span><br><span class="line"><span class="number">-1</span>：失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>文件，管道，共享内存，消息队列，套接字，命名管道</p>
<p>管道（使用最简单，匿名管道只能用于有血缘关系的进程之间，要共享文件描述符）</p>
<p>信号（开销小，表示信息有限）</p>
<p>共享映射区（无血缘关系）</p>
<p>本地套接字（最稳定，实现复杂度最高）</p>
<ul>
<li><p>管道</p>
<p>pipe函数创建 mkfifo 创建有名管道（伪文件不占用磁盘空间）</p>
<ol>
<li>其本质上是一个伪文件</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>规定数据从管道写段流入，从读端写出</li>
</ol>
<p>管道的原理，管道是为内核使用环形队列机制，借助内核缓冲区（4k)实现</p>
<p>局限性：自己写，不能自己读</p>
<p>​              数据不可反复读</p>
<p>​              半双工通信</p>
<p>​              只能在有血缘关系的进程之间使用</p>
<p>pipe函数：创建并打开管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line">参数:fd[<span class="number">0</span>]读端</span><br><span class="line">    fd[<span class="number">1</span>]写端</span><br><span class="line">返回：<span class="number">0</span> 成功 <span class="number">-1</span>失败</span><br></pre></td></tr></table></figure></li>
<li><p>管道的读写行为</p>
<ol>
<li><p>读管道 </p>
<ul>
<li><p>管道有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据</p>
<p>管道写端全部关闭，read返回0(读到文件结尾)</p>
<p>写端没有全部关闭，read阻塞等待</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道写端全部关闭，进程异常终止，SIGPIPE</p>
</li>
<li><p>管道写端没有全部关闭</p>
<p>管道已满，write阻塞</p>
<p>管道未满，write将数据写入，并返回实际写入字节数</p>
</li>
</ul>
</li>
</ol>
<p>可以有一个写端，多个读端，或者一个读端，多个写端</p>
</li>
<li><p>ulimit -a 查看打开文件个数，pipe缓存区大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>FIFO命名管道</p>
<p>解决没有关系进程之间的通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo myfifo</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文件进程通信</p>
</li>
<li><p>存储映射IO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;<span class="comment">//创建共享内存</span></span><br><span class="line">参数：</span><br><span class="line">    addr：指定映射区的首地址，通常传<span class="literal">NULL</span>,表示让系统自动分配</span><br><span class="line">    length:共享内存大小（&lt;=文件实际大小）</span><br><span class="line">    prot:共享内存映射区的读写权限 PROT_READ PROT_WRITE PROT_NONE PROT_EXEC</span><br><span class="line">    flags:标志共享内存共享属性：MAP_SHARED MAP_PRIVATE（对内存的修改不会反应到磁盘上）</span><br><span class="line">    fd:用于创建共享内存映射区的文件描述符</span><br><span class="line">    offset：默认<span class="number">0</span>，表示映射文件全部，偏移位置，必须是<span class="number">4</span>k的整数倍</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">        成功：映射区首地址</span><br><span class="line">        失败： MAP_FAILED,(<span class="keyword">void</span>*)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> munmap(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length);释放映射区</span><br><span class="line">addr:mmap返回值</span><br><span class="line">length:大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mann.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    perror(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;testmp&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lseek(fd,10,SEEK_END);</span></span><br><span class="line"><span class="comment">    write(fd,&#x27;\0&#x27;,1); //相当于ftruncate()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ftruncate(fd,<span class="number">20</span>);<span class="comment">//需要写权限</span></span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---%s\n&quot;</span>,p);</span><br><span class="line">    <span class="keyword">int</span> ret = munmap(p,len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<p>1.用于创建映射区文件大小为0，实际指定非零大小创建映射区，会造成SIGBUS</p>
<p>2.用于创建映射区文件大小为0，实际指定0大小创建映射区，invalid argument</p>
<p>3.用于创建映射区的文件读写属性为只读，实际mmap指定写，会造成invalid argument</p>
<p>4.创建映射区隐含一次read操作，需要read权限，mmap读写权限，映射区访问权限为SHARED时，应该不超过文件的open权限，文件只读open没发建立映射区</p>
<p>5.文件描述符fd在mmap创建后即可关闭，后续文件可以通过地址访问</p>
<p>6.offset必须是4k整数倍（MMU映射的最小单位为4k)</p>
<p>7.对申请的内存越界访问未定义</p>
<p>8.munmap释放的地址，必须是mmap申请的地址</p>
<p>9.映射区访问权限为私有，对内存的修改只跟内存有关，跟磁盘无关</p>
<p>10.映射区访问权限为私有，只需要open文件时有读权限，用于创建映射区即可</p>
</li>
<li><p>mmap</p>
<p>1.open(“文件名”,O_RDWR)</p>
<p>2.mmap(NULL,有效文件大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</p>
</li>
<li><p>父子间mmap通信，需设置flag为MAP_SHARED，否则父子进程各有一份映射区</p>
<p>父进程先创建映射区open（O_RDWR) mmap(MAP_SHARED)</p>
<p>指定MAP_SHARED权限</p>
<p>fork()创建子进程</p>
<p>一个进程读，一个进程写</p>
</li>
<li><p>无血缘关系进程之间mmap通信</p>
<p>两个进程打开同一个文件，创建映射区</p>
<p>指定flags为MAP_SHARED</p>
<p>一个进程写入，另一个进程读出，同一个文件mmap映射区是同一个位置</p>
<p>无血缘关系进程间通信 mmap：数据可以重复读取</p>
<p>​                                       fifo:数据只能一次读取</p>
</li>
<li><p>匿名映射：只能用于有血缘关系进程之间通信</p>
<p>使用MAP_ANONYMOUS（或者MAP_ANON)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//fd -1</span></span><br></pre></td></tr></table></figure>
<p>不支持ANONYMOUS的操作系统，可以打开/dev/zero，大小想要多大有多大</p>
<p>/dev/null</p>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>简单，不能携带大量信息，满足某个特设条件才发送</p>
<p>信号的特质：</p>
<p>信号时软件层面的中断，一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令</p>
<p>所有信号的产生和处理都是内核完成的</p>
<p>产生信号：</p>
<ol>
<li>按键产生，Ctrl+C Ctrl + Z Ctrl + \</li>
<li>系统调用产生 kill raise abort</li>
<li>软件条件产生，定时器alarm sleep借助alarm实现</li>
<li>硬件异常产生，非法访问内存（段错误）、除零，内存对齐出错（总线错误）</li>
<li>命令产生kill命令</li>
</ol>
<p>递达：递送并到达进程,直接被处理掉</p>
<p>未决：产生和抵达之间的状态，主要由于阻塞（屏蔽）导致该状态</p>
<p>信号处理方式：</p>
<p>1。执行默认动作</p>
<p>2.忽略（丢弃）</p>
<p>3.捕获（调用户处理函数）</p>
<ul>
<li><p>阻塞信号集（信号屏蔽字）：本质：位图，用来记录信号的屏蔽状态，将某些信号加入集合，对他们设置屏蔽，当屏蔽信号x后，再收到该信号，该信号的处理将推后（解除屏蔽后）</p>
</li>
<li><p>未决信号集,本质：位图，用来记录信号的处理状态</p>
<p>信号产生，未决信号集中描述该信号的位立即翻转为1，表信号处于未决状态，当信号被处理对应位翻转回0</p>
<p>信号产生后由于某些原因不能抵达（主要是阻塞），这类信号的集合称之为未决信号集，在屏蔽解除时，信号一直处于未决状态</p>
</li>
</ul>
<p>kill -l 列出所有信号</p>
<p>0-31常规信号：都有默认的处理事件和处理动作</p>
<p>34-64实时信号 ：没有默认事件</p>
<ul>
<li><p>信号4要素</p>
<p>1.编号，2.名称 3.信号对应的事件 4.默认处理动作</p>
<p>man 7 signal</p>
<p>SIGHUB 用户退出shell</p>
<p>SIGQUIT <ctrl+\></p>
<p>SIGINT <ctrl+c>终止进程</p>
<p>SIGKILL 无条件终止进程，不能被忽略，处理，阻塞</p>
<p>SIGSTOP停止进程的执行，不能忽略，处理，阻塞</p>
<p>SIGUSR1，SIGUSR2没有默认处理事件，处理动作是终止进程</p>
<p>SIGTERM, kill命令发送的信号，终止进程（不带信号编号）</p>
<p>SIGCHLD:子进程状态发生变化时，父进程接收这个信号，默认动作为忽略这个信号</p>
<p>SIGTSTP：停止中断交互进程的运行<ctrl+z></p>
</li>
<li><p>默认动作</p>
<p>Term：终止进程</p>
<p>Ign忽略信号</p>
<p>Core:终止进程，生成Core文件</p>
<p>Stop:停止（暂停）进程</p>
<p>Cont:继续运行进程</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sid)</span></span>;</span><br><span class="line">pid &gt; <span class="number">0</span> 杀死指定进程</span><br><span class="line">   = <span class="number">0</span> 杀跟调用kill函数的进程处于同一进程组的所有组员</span><br><span class="line">    &lt;<span class="number">-1</span> 取绝对值，发送信号给该绝对值所对应的进程组的所有组员</span><br><span class="line">    =<span class="number">-1</span> 发送信号给有权限的所有进程</span><br></pre></td></tr></table></figure>
<p>  ps ajx查看进程组信息</p>
<p>  kill -SIGKILL -1杀死所有有权限的进程</p>
<p>  发送者实际有效ID == 接收者实际有效ID</p>
<ul>
<li><p>其他几个发信号函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;<span class="comment">//发送信号给调用者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>alarm函数</p>
<p>设置定时器，（闹钟）指定seconds后，发送SIGALRM信号，进程接收到该信号，默认动作终止</p>
<p>每个进程有且只有唯一定时器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">返回值：无错误</span><br></pre></td></tr></table></figure>
<p>取消定时器alarm(0)返回旧闹钟剩余秒数</p>
<p>定时，与进程状态无关</p>
<p>time指令 查看程序执行的时间<code>time ./alarm</code></p>
<p>实际执行时间=系统时间+用户时间+等待时间</p>
<p>setitimer函数，可以实现周期定时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which,<span class="keyword">const</span> struct itimerval *new_value,struct itimerval *old_value)</span></span>;</span><br><span class="line">new_value 定时秒数</span><br><span class="line">old_value 传出参数，上次定时剩余时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span><span class="comment">/*next value*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span><span class="comment">/*current value*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;<span class="comment">/*seconds*/</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;<span class="comment">/*microseconds*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_t</span>;</span></span><br><span class="line"><span class="keyword">new_t</span>.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">new_t</span>.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">it_interval 用来设定两次定时任务之间的间隔时间</span><br><span class="line">it_value 定时的时长</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">which</span></span><br><span class="line"><span class="comment">自然计时：ITIMER_REAL -&gt;14)SIGLARM</span></span><br><span class="line"><span class="comment">虚拟空间计时（用户空间）ITIMER_VIRTUAL—&gt;26)SIGVTALRM 计算占用cpu时间</span></span><br><span class="line"><span class="comment">运行时计时（用户+内核）ITIMER_PROF-&gt;27)SIGPROF 计算占用cpu及执行系统调用的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">成功<span class="number">0</span>，失败<span class="number">-1</span></span><br></pre></td></tr></table></figure></li>
<li><p>信号集操作函数</p>
<p>只可以操作阻塞信号集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;<span class="comment">//typedef unsigned long sigset_t;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集清零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集置为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//删除某个信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//判断信号是否在信号集，在返回1，不在返回0</span></span><br></pre></td></tr></table></figure>
<p>sigprocmask函数</p>
<p>可以用来屏蔽信号，解除屏蔽</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> sigset*<span class="built_in">set</span>,sigset*oldset)</span></span>;<span class="comment">//成功0，失败-1</span></span><br><span class="line"><span class="built_in">set</span>传入参数，是一个位图</span><br><span class="line">oldset传出参数，保存旧的信号屏蔽集</span><br><span class="line">how参数取值：假设当前信号的屏蔽字为mask</span><br><span class="line">   SIG_BLOCK:<span class="built_in">set</span>表示需要屏蔽的信号，mask = mask|<span class="built_in">set</span></span><br><span class="line">   SIG_UNBLOCK:<span class="built_in">set</span>表示需要解除的信号，相当于mask = mask&amp;~<span class="built_in">set</span></span><br><span class="line">   SIG_SETMASK,替换原来的mask mask = <span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<p>sigpending函数</p>
<p>读取当前进程未决信号集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//set传出参数</span></span><br></pre></td></tr></table></figure></li>
<li><p>信号捕捉</p>
<p>signal函数</p>
<p>注册一个信号捕捉函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sigaction函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction*act,struct sigaction *oldact)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (*sg_sigaction)(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span> *);<span class="comment">//发送信号携带复杂信息</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;<span class="comment">//只工作于信号捕捉工作时间之中，绝大时候传0</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;<span class="comment">//设置参数，绝大时候传0</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);<span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>信号捕捉特性</p>
<p>1.进程正常运行时，默认PCB有一个信号屏蔽字，假定为mask，它决定了进程自动屏蔽哪些信号，当注册了某个信号捕捉函数，捕捉到该信号之后，要调用该函数，而该函数有可能执行很长时间，这期间所屏蔽的信号不由mask指定，而由sa_mask指定，调用完信号处理函数，再恢复为mask</p>
<p>2.xxx信号捕捉函数执行期间，相同信号自动被屏蔽</p>
<p>3.阻塞的常规信号不支持排队，产生多次只记录一次</p>
</li>
<li><p>内核实现信号捕捉</p>
<p>1.在执行主控制流程的某条指令时因为中断、异常或系统调用进入内核（用户态）</p>
<p>2.内核处理完异常准备回用户模式之前先处理当前进程中可以递送的信号</p>
<p>3.do_signal()如果信号的处理动作有自定义的信号处理函数则回到用户模式执行信号处理函数</p>
<p>4.信号处理函数返回时执行特殊的系统调用sigreturn再次进入内核（用户态）函数调用之后需要返回调用者</p>
<p>5.sys_sigreturn()返回用户模式，从主控制流程中上次被中断的地方继续向下执行</p>
</li>
<li><p>SIGCHID产生条件</p>
<p>子进程终止时</p>
<p>子进程接收到SIGSTOP信号停止时</p>
<p>子进程处于停止态，接收到SIGCONT后唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt; <span class="number">0</span>)&#123;<span class="comment">//防止因为处理SIGCHID期间屏蔽SIGCHID，造成一些子进程的SIGCHID丢失导致未回收</span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(status))<span class="comment">//正常退出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d exit %d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))<span class="comment">//被信号退出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d cancel signal %d\n&quot;</span>, pid, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中断系统调用</p>
<p>1.慢速系统调用：可能会使进程永远阻塞的系统调用，如果阻塞期间收到一个信号，该系统调用就被中断，不再执行，也可设定系统调用是否重启</p>
<p>2.其他系统调用：getpid getppid fork</p>
<p>慢速系统调用被中断的相关行为，实际上就是pause行为</p>
</li>
</ul>
<p>  可修改sa_flags来设置被信号中断后系统调用是否重启SA_INTERRURT不重启，SA_RESTART重启</p>
<ul>
<li><p>会话</p>
<p>多个进程组的集合</p>
<p>setid函数</p>
<p>创建一个会话，并以自己的ID设置进程组ID，同时也是会话的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//成功返回0，失败-1并设置errno</span></span><br><span class="line">调用setid函数的进程，既是新会长，也是新组长</span><br></pre></td></tr></table></figure>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3></li>
</ul>
<p>daemon 进程，Linux后台服务进程，通常独立于控制终端，并且周期性执行某种任务，或等待某些发生的事件。通常采用以d结尾的名字</p>
<p>通常运行于操作系统后台，脱离控制终端，一般不与用户进行交互，周期性等待某个事件发生或者周期性执行某一动作</p>
<p>不受用户登录注销影响，通常采用以d结尾的命名方式</p>
<p>创建守护进程：</p>
<ul>
<li><p>创建子进程，父进程退出</p>
<p>所有工作在子进程中进行，形式上脱离了控制终端</p>
</li>
<li><p>在子进程中创建会话</p>
<p>setsid()函数</p>
<p>使子进程完全独立出来，脱离控制</p>
</li>
<li><p>改变当前目录为根目录</p>
<p>chdir()函数</p>
<p>防止占用可卸载文件系统</p>
<p>也可换成其他路径</p>
</li>
<li><p>重设文件权限掩码</p>
<p>umask()函数</p>
<p>防止继承的文件创建屏蔽字拒绝某些权限</p>
<p>增加守护进程灵活性</p>
</li>
<li><p>关闭/重定向文件描述符</p>
<p>0，1，2，继承打开文件不会用到，浪费系统资源，无法卸载</p>
</li>
<li><p>开始执行守护进程核心工作，守护进程退出处理程序模型</p>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程:独立地址空间，拥有PCB，最小资源分配单位</p>
<p>线程：有独立PCB，但没有独立地址空间，最小执行单位</p>
<p>ps -Lf pid —&gt;线程号</p>
<p>页目录（首地址在PCB中），页表，页面</p>
<ul>
<li>轻量级进程，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li>
<li>从内核看线程和进程一样的，但PCB所指的三级页表相同</li>
<li>进程可以蜕变成线程</li>
<li>线程可以看成是寄存器和栈的集合</li>
<li>在linux下，线程是最小的执行单位，晋城市最先的资源分配单位</li>
</ul>
<p>线程共享资源</p>
<ul>
<li>文件描述符表</li>
<li>每个信号处理方式</li>
<li>当前工作目录</li>
<li>用户id,组id</li>
<li>内存地址空间</li>
</ul>
<p>线程非共享资源</p>
<ul>
<li>线程id</li>
<li>处理器现场和栈指针（内核栈）</li>
<li>独立的栈空间</li>
<li>errno变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<p>线程优缺点：</p>
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信，共享数据方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>库函数，不稳定</li>
<li>调试，编写困难，gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<h4 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h4><ul>
<li>pthread_self函数</li>
</ul>
<p>获取线程id,其作用对应进程的getpid()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">线程ID：<span class="keyword">pthread_t</span>类型，本质在linux下为无符号整型，其它系统有可能是结构体</span><br><span class="line">线程ID是进程内部识别标志，(两个进程间可以有线程ID相同)</span><br><span class="line">线程号：标识线程身份，交给CPU选择调度时间</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_create</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;<span class="comment">//成功返回0，失败返回错误号</span></span><br><span class="line">thread 传出参数，新创建线程的子线程id</span><br><span class="line">attr 线程属性,<span class="literal">NULL</span>表示默认参数</span><br><span class="line">start_routine 回调函数</span><br><span class="line">arg 回调函数所需要的参数</span><br><span class="line">传参采用值传递，借助强转</span><br><span class="line">(<span class="keyword">void</span>*)i<span class="comment">//不可是(void*)&amp;i</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_exit</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;<span class="comment">//将当前线程退出</span></span><br><span class="line">retval 退出值，无退出值时，<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>pthread_join函数</p>
<p>阻塞等待线程退出，获取线程退出状态，对应进程中的waitpid()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span> ** retval)</span></span>;成功<span class="number">0</span>，失败错误号</span><br><span class="line">thread 线程ID</span><br><span class="line">retval记录线程结束状态</span><br></pre></td></tr></table></figure></li>
<li><p>pthread_cancel函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  杀死线程,cancel杀死进程需要到达一个取消点(保存点)（系统调用</p>
<p>  子线程没发生系统调用，须要子线程自己添加取消点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_testcancel();</span><br></pre></td></tr></table></figure>
<p>  如果子线程没有到达取消点，那么pthread_cancel()无效</p>
<p>  被pthread_cancel()杀死的线程返回-1，使用pthread_join回收</p>
<ul>
<li><p>pthread_detach 函数</p>
<p>线程分离</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;<span class="comment">//成功0，失败错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离之后资源由操作系统自动回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程失败打印错误,perror没用</span></span><br><span class="line">strerror(ret);</span><br><span class="line">检查出错返回</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;xxx error %s\n&quot;</span>,stderror(ret));</span><br></pre></td></tr></table></figure>
<p>线程控制原语：thread_create()  thread_self()   pthread_exit()   pthread_join()  pthread_cacel() pthread_detach()</p>
<p>进程控制原语：fork()                    gepid()             exit() //return    wait()/waitpid() kill()</p>
</li>
<li><p>线程属性初始化</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr)</span></span>;<span class="comment">//成功0，失败：错误号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr)</span></span>;<span class="comment">//成功0，失败：错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离状态的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">int</span>* detachstate)</span></span>;</span><br><span class="line">attr:已初始化的线程属性</span><br><span class="line">detachstate： PTHREAD_CREATE_DETACHED（分离线程）</span><br><span class="line">              PTHREAD_CREATE_JOINABLE(非分离线程)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><p>线程使用注意事项</p>
<ul>
<li><p>主线程退出其他线程不退出，主线程应调用pthread_exit</p>
</li>
<li><p>避免僵尸进程</p>
<p>pthread_join</p>
<p>pthread_detach</p>
<p>pthread_create 指定分离属性</p>
<p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收栈中的值</p>
</li>
<li><p>malloc和mmap申请的内存可以被其他线程释放</p>
</li>
<li><p>应避免在对多线程模型中调用fork，除非马上exec，子进程只有调用fork的线程存在，其他线程在子进程中均pthread_exit</p>
</li>
<li><p>信号的复杂语义很难与多线程并存，应避免使用信号机制</p>
</li>
</ul>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>线程同步：协同步调，按照预定的先后次序运行</p>
<p>线程同步：指一个线程发出某一个功能调用时，在没有得到结果之前，该调用不返回，同时其他线程为保证数据一致性，不能调用该功能。</p>
<p>锁：建议锁，对公共数据的访问，所有线程应该在访问公共数据前先拿锁再访问，但锁不具有强制性（互斥量）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init()</span><br><span class="line">pthread_mutex_mutex_destory()</span><br><span class="line">pthread_mutex_lock()</span><br><span class="line">pthread_mutex_trylock()</span><br><span class="line">pthread_mutex_unlock()</span><br><span class="line">返回值：成功<span class="number">0</span>，失败返回错误号</span><br><span class="line"><span class="keyword">pthread_mutex_t</span>类型，本质是一个结构体</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;变量值只有<span class="number">0</span>，<span class="number">1</span>两种</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;<span class="comment">//restrict本指针指向的内存写操作只能由mutex完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>尽量保证锁的粒度越小越好。</p>
<p>互斥锁，初值为1</p>
<p>加锁 —操作，阻塞线程</p>
<p>解锁++操作，唤醒阻塞在锁上的线程</p>
<p>try锁，尝试加锁，成功—，失败返回，同时设置错误号EBUSY</p>
<ul>
<li><p>死锁:使用锁不恰当导致的现象：</p>
<p>1.对一个锁反复lock</p>
<p>2.两个线程各持有一把锁，请求对方持有的锁</p>
</li>
<li><p>读写锁</p>
<ul>
<li><p>锁只有一把，以读方式加锁，读锁，以写方式加锁，写锁</p>
</li>
<li><p>读共享，写独占</p>
</li>
<li>写锁优先级高</li>
</ul>
<p>读写锁是写模式加锁时，解锁前，所有对该锁的加锁线程都会被阻塞</p>
<p>读写锁是读模式加锁时，如果线程以读模式对其加锁会成功，如果以写模式加锁会阻塞</p>
<p>读写锁是读模式加锁时，同时有以读、写模式加锁的线程请求，会先满足写请求，致使所有线程阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init</span><br><span class="line">pthread_rwlock_destory</span><br><span class="line">pthread_rwlock_rdlock</span><br><span class="line">pthread_rwlock_wrlock</span><br><span class="line">pthread_rwlock_tryrdlock</span><br><span class="line">pthread_rwlock_trywrlock</span><br><span class="line">pthread_rwlock_unlock</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> 类型，用于定义一个读写锁变量</span><br></pre></td></tr></table></figure>
<p>相较于互斥量而言，当读线程多时，提高访问效率</p>
</li>
<li><p>条件变量</p>
<p>条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用，给多线程提供一个会和的场所</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init函数</span><br><span class="line">pthread_cond_destory</span><br><span class="line">pthread_cond_wait</span><br><span class="line">pthread_cond_timewait</span><br><span class="line">pthread_cond_signal</span><br><span class="line">pthread_cond_broadcast</span><br><span class="line">    </span><br><span class="line"><span class="keyword">pthread_cont_t</span>类型，用于定义条件变量</span><br><span class="line"><span class="keyword">pthread_cont_t</span> cond = PTHREAD_COND_INITIALIZER;<span class="comment">//静态初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>pthread_cond_wait函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span>*<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数作用：</p>
<ul>
<li>阻塞等待条件变量cond满足</li>
<li>释放已掌握的互斥锁，解除互斥量（1，2两步为一个原子操作）<code>pthread_mutex_unlock(&amp;mutex)</code></li>
<li>当被唤醒，pthread_cond_wait返回时，解除阻塞并重新申请获得互斥锁<code>pthread_mutex_lock(&amp;mutex)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>生产者消费者模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cond不满足)&#123;</span><br><span class="line">   pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>信号量</p>
<p>相当于初始化值为N的互斥量</p>
<p>可应用于进程、线程之间同步</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">sem_init</span><br><span class="line">sem_destory</span><br><span class="line">sem_wait<span class="comment">//加锁</span></span><br><span class="line">sem_trywait</span><br><span class="line">sem_timewait</span><br><span class="line">sem_post<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> 本质上是结构体</span><br><span class="line"><span class="keyword">sem_t</span> sem;<span class="comment">//规定信号量sem不能小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>*sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">//pshared 0 线程间同步</span></span><br><span class="line">          <span class="number">1</span> 进程间同步</span><br><span class="line"><span class="comment">//value N值（指定同时访问的线程数）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>“cd” does not work in shell script</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr -d <span class="string">&quot;\r&quot;</span> &lt; oldname.sh &gt; newname.sh</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/08/14/Effective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/14/Effective-C/" class="post-title-link" itemprop="url">Effective C++</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-14 12:58:27" itemprop="dateCreated datePublished" datetime="2021-08-14T12:58:27+08:00">2021-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-28 22:00:28" itemprop="dateModified" datetime="2021-09-28T22:00:28+08:00">2021-09-28</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/08/14/Effective-C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/14/Effective-C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="尽量以const-enum-inline-替换-define"><a href="#尽量以const-enum-inline-替换-define" class="headerlink" title="尽量以const,enum,inline 替换#define"></a>尽量以const,enum,inline 替换#define</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AspectRatio 1.635</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.635</span>;</span><br></pre></td></tr></table></figure>
<p>class 专属常量，为保证常量只有一份实体，必须让它成为一个static变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Num = <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">int</span> score[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="尽量使用const"><a href="#尽量使用const" class="headerlink" title="尽量使用const"></a>尽量使用const</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greet[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greet;<span class="comment">//non_const pointer non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greet;<span class="comment">//const data, non-const pointer</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greet;<span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greet;<span class="comment">//const pointer,const data</span></span><br></pre></td></tr></table></figure>
<p>如果const出现在星号左边，被指物是常量，出现在星号右边，指针本身是常量。</p>
<p>STL迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();<span class="comment">//相当于T* const</span></span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">//没问题，改变iter所指物</span></span><br><span class="line">++iter;<span class="comment">//不行，iter是const</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin();<span class="comment">//相当于const T*</span></span><br><span class="line">*cIter = <span class="number">10</span>;<span class="comment">//不行，*cIter是const</span></span><br><span class="line">++cIter;<span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>
<p>const 重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Textbook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Textbook(<span class="built_in">std</span>::<span class="built_in">string</span> s):text(s)&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;non const\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Textbook <span class="title">tb</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Textbook <span class="title">ctb</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只是改变参数const属性不可以重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Textbook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="确定对象在被调用前已经被初始化"><a href="#确定对象在被调用前已经被初始化" class="headerlink" title="确定对象在被调用前已经被初始化"></a>确定对象在被调用前已经被初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;addr,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones):theName(name),theAddr(addr),thePhones(phones)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化列表省了一次调用默认构造函数的代价</p>
<p>为免除跨编译单元之初始化次序问题，用local static对象替换non_local static 对象</p>
<h3 id="构造、析构、赋值操作"><a href="#构造、析构、赋值操作" class="headerlink" title="构造、析构、赋值操作"></a>构造、析构、赋值操作</h3><p>在一个内含reference成员的class内支持赋值操作，必须自己定义copy assignment操作符。</p>
<p>面对内含const成员的class,编译器反应一样。</p>
<p>如果某个base class将assignment操作符声明为private,编译器拒绝为其derived class生成assignment操作符.</p>
<h3 id="不想使用编译器自动生成的函数"><a href="#不想使用编译器自动生成的函数" class="headerlink" title="不想使用编译器自动生成的函数"></a>不想使用编译器自动生成的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Test(<span class="keyword">const</span> Test &amp;);<span class="comment">//只有声明</span></span><br><span class="line">        Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将复制构造函数、copy assignment声明为private,外部不可调用，内部调用会有链接错误</p>
<p>还可以定义一个base类，其复制构造函数、copy assignment为private，子类就不能生成默认构造函数、copy assignment.</p>
<h3 id="为多态基类声明virtual函数"><a href="#为多态基类声明virtual函数" class="headerlink" title="为多态基类声明virtual函数"></a>为多态基类声明virtual函数</h3><p>一个base类指针指向一个derived对象，base类析构函数non-virtual,调用delete时，derived类成员可能未被delete</p>
<p>要实现virtual函数，对象必须携带一些信息。用于在运行时决定哪一个virtual函数被调用</p>
<p>通常是一个所谓的vptr指针指出。</p>
<p>vptr指向一个由函数指针构成的数组，称为vtbl.</p>
<ul>
<li>只有class内含至少一个virtual函数才为析构函数声明为virtual</li>
</ul>
<p>STL容器都带有non-virtual析构函数</p>
<p>纯虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数的运作方式：</p>
<p>最深层派生（most derived)的那个class其析构函数最先被调用，然后是其每一个base class的析构函数被调用。</p>
<h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><h3 id="绝不在构造函数和析构函数中调用virtual函数"><a href="#绝不在构造函数和析构函数中调用virtual函数" class="headerlink" title="绝不在构造函数和析构函数中调用virtual函数"></a>绝不在构造函数和析构函数中调用virtual函数</h3><p>“在base class构造期间，virtual函数不是virtual函数”（会调用base class版本的virtual函数）</p>
<h3 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator=返回一个reference to *this"></a>令operator=返回一个reference to *this</h3><h3 id="在operator-中处理自我赋值"><a href="#在operator-中处理自我赋值" class="headerlink" title="在operator=中处理自我赋值"></a>在operator=中处理自我赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//证同测试（identity test)</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp;rhs)&#123;</span><br><span class="line">    Bitmap* POrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)某class的copy assignment操作符可能被声明为’以by value方式接收实参‘</p>
<p>(2)以by value 方式传递东西会造成一份副本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将copy操作从函数本体移至函数参数构造阶段</p>
<h3 id="复制对象时勿忘每一成分"><a href="#复制对象时勿忘每一成分" class="headerlink" title="复制对象时勿忘每一成分"></a>复制对象时勿忘每一成分</h3><p>令copy构造函数调用copy assignment操作无意义，构造函数用来初始化新对象，而assignment操作符只施于已初始化对象身上。</p>
<p>令copy assignment操作符调用copy构造函数不合理，因为这就像在构造一个已经存在的对象。</p>
<p>copy构造函数和copy assignment操作符有相似代码，消除重复代码的做法是，建立一个新的成员函数给二者调用。</p>
<h3 id="以对象资源管理对象"><a href="#以对象资源管理对象" class="headerlink" title="以对象资源管理对象"></a>以对象资源管理对象</h3><ul>
<li><p>获得对象后立刻放进管理对象</p>
</li>
<li><p>管理对象运用析构函数确保资源被释放</p>
<p>share_ptr在其析构函数中调用delete 而不是delete[]</p>
<p>不能在动态分配的array身上使用share_ptr</p>
</li>
</ul>
<h3 id="在资源管理类中小心copying行为"><a href="#在资源管理类中小心copying行为" class="headerlink" title="在资源管理类中小心copying行为"></a>在资源管理类中小心copying行为</h3><ul>
<li>禁止复制</li>
<li>对底层资源祭出引用计数法</li>
</ul>
<p>shared_ptr允许指定所谓的删除器，那是一个函数或函数对象，当引用次数为0时便调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span>:<span class="title">mutexPtr</span><span class="params">(pm,unlock)</span></span>&#123;</span><br><span class="line">            lock(mutexPtr.get());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mutex&gt;mutexPtr;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制底部资源</li>
</ul>
<p>复制资源管理对象时，也应该复制其所包裹的底层资源</p>
<ul>
<li>转移底部资源的所有权</li>
</ul>
<p>某些场合下希望只有一个RAII指向一个（raw resource),即使RAII对象被复制依然如此，此时资源的所有权会从被复制物转移到目标物.</p>
<h3 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h3><p>share_ptr 重载了*，-&gt;运算符，隐式转换至底层资源</p>
<h3 id="成对使用new-和delete时要采取相同的形式"><a href="#成对使用new-和delete时要采取相同的形式" class="headerlink" title="成对使用new 和delete时要采取相同的形式"></a>成对使用new 和delete时要采取相同的形式</h3><p>当使用new,有两件事情发生：第一内存被分配出来，第二，针对此内存会有一个或更多构造函数函数被调用，</p>
<p>当使用delete,有两件事发生：会有一个或多个析构函数被调用，然后内存才被释放</p>
<p>delete最大的问题在于，即将被删除的内存究竟存有多少个对象，这个问题决定了有多少个析构函数必须被调用</p>
<p>唯一让delete知道内存是否存在一个数组大小记录的办法就是在使用delete时加上中括号</p>
<p>==重写不能改变返回值类型，参数列表==</p>
<p>==引用也能实现多态==</p>
<p>成为虚函数的条件：<br>1.要能取地址<br>2.依赖对象调用</p>
<p>==内联函数不能成为虚函数，没法对一个内联函数取地址==</p>
<p>==构造函数 不可以 系统调用 不依赖对象调用==</p>
<p>static函数 不可以 无this指针 不依赖对象调用</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用本质上是一个常量指针，<code>int * const p</code></p>
<p>占用空间情况和指针一致</p>
<p>对引用的修改即是对源数据的修改</p>
<p>引用必须初始化，指针不可以</p>
<p>指针可以赋值为nullptr,没有空引用</p>
<p>没有<code>int &amp; const a</code>,只有<code>const int &amp; a</code></p>
<p>强转运算重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;assignment\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp;&amp;a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//default</span></span><br><span class="line">    A a = A();</span><br><span class="line">    <span class="comment">//default,move</span></span><br><span class="line">    <span class="comment">//没有move会调用copy</span></span><br><span class="line">    A c = C();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//都不行， &#x27;A&#x27; is an inaccessible base of &#x27;C&#x27;|</span></span><br><span class="line">    A&amp;&amp; a = C();</span><br><span class="line">    A * a = <span class="keyword">new</span> C();</span><br><span class="line">    A a = C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>const 重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print const\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.print(); <span class="comment">//print,当没有non-const print()时，也输出print const</span></span><br><span class="line">    <span class="keyword">const</span> A b;</span><br><span class="line">    b.print();<span class="comment">//print const,当没有const print(),报错passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print const\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&amp;&amp; a = C();</span><br><span class="line">    a.print();<span class="comment">//输出的是print,类C没有重载A的print()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子类以私有方式重写父类虚函数，通过父类引用、指针可以调用子类相应私有方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//此处print为私有</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&amp;&amp; a = C();</span><br><span class="line">    a.print();<span class="comment">//输出C</span></span><br><span class="line">    C c;</span><br><span class="line">    c.print();<span class="comment">//报错&#x27;virtual void C::print()&#x27; is private within this context</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>纯虚函数是可以有实现的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">    A(<span class="keyword">int</span> x)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;test A\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A::test();</span><br><span class="line">    &#125;</span><br><span class="line">    B(<span class="keyword">int</span> x):A(x)&#123;<span class="comment">//必须写在初始化列表</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    b.test();</span><br><span class="line">    <span class="comment">//test(1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造函数中==必须写在member initialization list的==</p>
<ul>
<li>初始化一个reference member</li>
<li>初始化一个const member</li>
<li>当调用一个base类的constructor且它有一组参数</li>
<li>当调用一个member类的constructor且它有一组参数</li>
</ul>
<h3 id="段错误的原因"><a href="#段错误的原因" class="headerlink" title="段错误的原因"></a>段错误的原因</h3><ul>
<li><p>访问不存在的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>访问系统保护的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)<span class="number">0</span>; </span><br><span class="line">*ptr = <span class="number">100</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>访问只读的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = <span class="string">&quot;test&quot;</span>; </span><br><span class="line"><span class="built_in">strcpy</span>(ptr, <span class="string">&quot;TEST&quot;</span>); </span><br></pre></td></tr></table></figure></li>
<li><p>栈溢出 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>double free</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*p) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Why are only <code>static const</code> integral types &amp; enums allowed In-class Initialization?</p>
<p>为什么只有static const integral类型以及enums被允许类内初始化呢？</p>
<p>这个答案就在Bjarne的那段话中。“C++需要每一个对象有特定的定义。如果C++允许存储在内存中的对象进行类内定义，那么这一规则将会被打破。”</p>
<p>注意只有static const integers 会被看作编译时的常量。编译器了解这样的integer变在任何情况下都不会改变，因此编译器才可以对其做出特有的优化与改进，编译器会简单的将其内联化这样的变量，因而不再使其保存在内存中。因为保存在内存中的需求被移除了，使得他们成了Bjane所说规则的例外。</p>
<p>值得注意的是，即使static const integral这样的变量被允许使用类内初始化，但是获取这样的变量的地址是不被允许的。一个变量只有拥有类外定义的情况下，才能被获得地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//要有這句才能過編譯</span></span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;A::x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>静态成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//static member function &#x27;static int A::print()&#x27; cannot have cv-qualifier</span></span><br></pre></td></tr></table></figure>
<p>1.static成员函数不包含<code>this</code>指针<br>2.static成员函数不能为<code>virtual</code><br>3.不能存在static和non-static成员函数有相同的名字和参数<br>4.static 成员函数不能被声明成const、volatile或者const volatile。(可以为inline)</p>
<p>析构函数是私有、删除的情况下，不能在栈上定义对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~A() =<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//A a;</span></span><br><span class="line">    <span class="comment">//use of deleted function &#x27;A::~A()&#x27;</span></span><br><span class="line">    <span class="comment">//因为a离开作用域后会自动调用析构函数</span></span><br><span class="line">    A *a = <span class="keyword">new</span> A();<span class="comment">//允许，不能delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;right\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;left\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;const left\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;const right\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>&amp;&amp; x = <span class="number">2</span>;</span><br><span class="line">   test(x);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp; y = <span class="number">3</span>;</span><br><span class="line">   test(y);</span><br><span class="line">   test(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">left</span></span><br><span class="line"><span class="comment">const left</span></span><br><span class="line"><span class="comment">right</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">setVal() = <span class="number">3</span>;<span class="comment">//允许，返回的是左值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span>&#123;&#125;</span><br><span class="line">test(<span class="number">2</span>);<span class="comment">//不合法，要求传一个左值</span></span><br></pre></td></tr></table></figure>
<p>不能对一个类的构造/析构函数取地址，因为构造函数析构函数没有返回值，不能产生一个有效的函数指针。</p>
<p>成员函数指针占16个字节。为在简单函数指针的后面还需要保存怎样调整 “this” 指针（总是隐式地传递给非静态成员函数）的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A&#x27;s this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> pad0[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&#x27;s this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> pad2[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> A, B</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    obj.foo();</span><br><span class="line">    obj.bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A&#x27;s this: 0x7fff57ddfb48</span></span><br><span class="line"><span class="comment">B&#x27;s this: 0x7fff57ddfb68</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">“<span class="keyword">this</span>” 指针的值传给 B 的方法要比 A 的方法要大 <span class="number">32</span> 字节——一个类 A 对象的实际大小。</span><br></pre></td></tr></table></figure>
<p><code>g++ -fno-elide-constructors</code>阻止部分编译优化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *(*fun(<span class="keyword">int</span>*))(<span class="keyword">int</span>*);</span><br><span class="line">=&gt;fun先与(<span class="keyword">int</span>*)结合，接收一个参数<span class="keyword">int</span>*</span><br><span class="line">  <span class="keyword">int</span> ** fun(<span class="keyword">int</span>*)(<span class="keyword">int</span>*)</span><br><span class="line">=&gt;<span class="keyword">typedef</span> <span class="keyword">int</span>** (*FP)(<span class="keyword">int</span>*);</span><br><span class="line">  FP (<span class="keyword">int</span> *);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>* (*test(<span class="keyword">int</span>* ))(<span class="keyword">int</span>*)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> fun1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>*  (*(*f)(<span class="keyword">int</span>*))(<span class="keyword">int</span>*) = test;</span><br><span class="line">    <span class="comment">//f是一个函数指针，接受一个参数(int*)</span></span><br><span class="line">    <span class="comment">//返回值也是一个函数指针int* (*) (int*)</span></span><br><span class="line">    f(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><ul>
<li>没有所谓空引用</li>
<li>引用必须有初值</li>
<li>使用引用不能测试其有效性</li>
<li>pointer可以重新赋值，指向另一个对象</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>static_cast基本与C旧式转型一致，不能用static_cast将一个struct转为int,或将一个double转为pointer,不能移除const性质</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; (<span class="keyword">size_t</span>)(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//报错了???</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够将任意类型指针转成<code>void*</code>，通过<code>void*</code> 转成其他类型指针</p>
<p>const_cast 用来改变表达式的常量性、易变性</p>
<p>将一个指针或引用去掉const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = j;</span><br><span class="line"><span class="keyword">int</span> &amp;k = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(i);</span><br><span class="line">k++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(a.c_str());</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a.c_str());</span><br></pre></td></tr></table></figure>
<p>dynamic_cast 安全的向下转型或跨系转型动作</p>
<p><code>dynamic_cast</code> can only cast to a pointer value or reference, dynamic 转换时的类必须有虚函数</p>
<p><code>reinterpret_cast</code>不具有移植性</p>
<h3 id="绝对不要以多态方式处理数组"><a href="#绝对不要以多态方式处理数组" class="headerlink" title="绝对不要以多态方式处理数组"></a>绝对不要以多态方式处理数组</h3><p>基类数组元素大小和derived类不一致，数组产生的偏移不一样</p>
<h3 id="C-的const类型成员函数"><a href="#C-的const类型成员函数" class="headerlink" title="C++的const类型成员函数"></a>C++的const类型成员函数</h3><ul>
<li>在C++中只有被声明为const的成员函数才能被一个const类对象调用</li>
<li>const成员函数可以被对应的具有相同形参列表的非const成员函数重载</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span> <span class="keyword">const</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">const</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法的本质是：void fun (const 类 *this, int a,int b);</p>
<p><strong>本质上，const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针。</strong></p>
<h3 id="重载-lt-运算符"><a href="#重载-lt-运算符" class="headerlink" title="重载&lt;运算符"></a>重载&lt;运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A&amp;a,<span class="keyword">const</span> A&amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">bool</span> A::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A&amp;a)&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==类引用成员、常量指针必须在构造函数初始化列表中完成初始化==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> * y):x(x),y(y)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; x;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><ul>
<li><p>两种函数允许编译器执行类型转换</p>
<p>单自变量constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Name(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator=<span class="number">0</span>,<span class="keyword">int</span> denominator=<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  隐式类型转换操作符</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//将Rational转为double</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="前置后置"><a href="#前置后置" class="headerlink" title="前置后置"></a>前置后置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>++();前置</span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后置，返回const，避免出现i++++</span></span><br><span class="line">&#125;</span><br><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    UPInt oldValue = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不要重载-，-amp-amp-，及，运算符"><a href="#不要重载-，-amp-amp-，及，运算符" class="headerlink" title="不要重载||，&amp;&amp;，及，运算符"></a>不要重载||，&amp;&amp;，及，运算符</h3><p>函数调用语义会取代骤死式语义</p>
<ul>
<li><p>函数调用动作执行时，所有参数都会被求值</p>
</li>
<li><p>未规定参数求值顺序</p>
</li>
</ul>
<p>逗号表达式从左至右求值</p>
<p>不能重载的运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">. </span><br><span class="line">.* </span><br><span class="line">:: </span><br><span class="line">?:</span><br><span class="line"><span class="keyword">new</span> </span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">sizeof</span></span><br><span class="line"><span class="keyword">typeid</span></span><br><span class="line"><span class="keyword">static_cast</span></span><br><span class="line"><span class="keyword">dynamic_cast</span></span><br><span class="line"><span class="keyword">const_cast</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure>
<h3 id="不同意义的new和delete"><a href="#不同意义的new和delete" class="headerlink" title="不同意义的new和delete"></a>不同意义的new和delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br><span class="line"><span class="comment">//new operator</span></span><br></pre></td></tr></table></figure>
<p><code>new operator</code>由语言内建的，类似sizeof,不能改变意义</p>
<p><code>operator new</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以重载，但需保证第一个参数为size_t</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));</span><br></pre></td></tr></table></figure>
<p>operator new 和malloc一样，唯一任务是分配内存</p>
<p><code>placement new</code></p>
<p>有一些分配好的内存上直接构建对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (buffer) Widget();</span><br></pre></td></tr></table></figure>
<p>如果只想处理原始的、未设初值的内存，应该回避new operator 和delete operator,改用operator new 和operator delete</p>
<p>如果使用placement new ，不应该调用delete，调用相应对象析构函数即可</p>
<p><code>operator new[]</code>可以重载</p>
<p>数组版<code>new operator</code>先调用<code>operator new[]</code>分配内存，后为每个元素调用构造函数</p>
<p>数组版delete operator先为每个元素调用析构函数，后调用<code>operator delete[]</code>释放空间</p>
<h3 id="在constructor内阻止内存泄漏"><a href="#在constructor内阻止内存泄漏" class="headerlink" title="在constructor内阻止内存泄漏"></a>在constructor内阻止内存泄漏</h3><p>析构函数只负责析构构造好的对象，构造过程中发生异常不会引发析构函数调用</p>
<h3 id="禁止异常流出destructor"><a href="#禁止异常流出destructor" class="headerlink" title="禁止异常流出destructor"></a>禁止异常流出destructor</h3><p>如果基于exception的因素离开destructor,此时正有另一个exception处于作用状态，c++会调用terminate函数，程序立即结束</p>
<p>如果exception从destruction流出而没得到任何处理，会导致析构函数执行不全</p>
<h3 id="实现shared-ptr"><a href="#实现shared-ptr" class="headerlink" title="实现shared_ptr"></a>实现shared_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shared_ptr(T *p):ptr(p),_use_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">    Shared_ptr(Shared_ptr&lt;T&gt;&amp;other):_use_count(&amp;(++(*other._use_count))),ptr(other.ptr)&#123;&#125;</span><br><span class="line">    Shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(Shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="keyword">this</span> == sp)&#123;<span class="comment">//处理自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++(*sp._use_count);</span><br><span class="line">        --(*<span class="keyword">this</span>-&gt;_use_count);</span><br><span class="line">        <span class="keyword">if</span>(!(*(<span class="keyword">this</span>-&gt;_use_count))&amp;&amp;<span class="keyword">this</span>-&gt;ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> _use_count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_use_count= sp._use_count;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = sp.ptr;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="comment">//返回值是引用，避免当前指针指向派生类对象造成对象切割问题</span></span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Shared_ptr()&#123;</span><br><span class="line">        --(*_use_count);</span><br><span class="line">        <span class="keyword">if</span>(!*_use_count)&#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> _use_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">void</span>*() <span class="comment">//隐式转换，有隐式转换才能写如:if(p) if(!p) if(p == 0)语句 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_use_count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* _use_count;<span class="comment">//动态内存分配，保证所有的Shared_ptr共用一份use_count,节省内存</span></span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">Shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; p.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   Shared_ptr&lt;<span class="keyword">int</span>&gt; c = p;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; p.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; c.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; (*c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出一个exception与传递一个参数差异"><a href="#抛出一个exception与传递一个参数差异" class="headerlink" title="抛出一个exception与传递一个参数差异"></a>抛出一个exception与传递一个参数差异</h3><p>一个对象被抛出无论是以by value和by reference方式传递都会发生复制行为，因为抛出异常时，控制权会离开当前作用域，其他局部变量会被销毁，只能通过复制保存对象状态。</p>
<ul>
<li>即使是静态局部变量，复制行为也会发生</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   B b;</span><br><span class="line">   A&amp;a = b;</span><br><span class="line">   a.print();<span class="comment">//B</span></span><br><span class="line">   A c = a;<span class="comment">//调用A的复制函数，只关注静态类型</span></span><br><span class="line">   c.print();<span class="comment">//A</span></span><br><span class="line">   </span><br><span class="line">   A* x = <span class="keyword">new</span> B;</span><br><span class="line">   x-&gt;print();<span class="comment">//B</span></span><br><span class="line">   A* y = x;</span><br><span class="line">   y-&gt;print();<span class="comment">//B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个被抛出的临时对象可以被左值引用捕捉，不需要<code>by reference-to-const</code>方式，函数调用将一个临时对象传递给一个左值引用是不合法的</p>
<p>by value 方式传递exception,会调用两次复制构造函数，第一次产生一个临时对象，第二次将临时对象复制给参数<code>w</code></p>
<p>by reference只会调用一次复制构造函数，产生一个临时对象</p>
<p>exception和catch子句匹配不会发生隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(someFunction())&#123;</span><br><span class="line">        	<span class="keyword">throw</span> value;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">double</span> d)&#123;<span class="comment">//不会捕捉value</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两种转换可以发生：</p>
<ul>
<li><p>为base class exceptions写的catch子句可以捕捉derived class exceptions</p>
</li>
<li><p>有形指针到无形指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">void</span> *)...<span class="comment">//可以捕捉任意指针类型</span></span><br></pre></td></tr></table></figure>
<p>catch子句以其在源代码中出现的顺序匹配（first fit)。</p>
</li>
</ul>
<p><code>mutable</code>关键字修饰的member成员能在const member functions中改变。实现<code>lazy fetching</code>,对象读取可能需要在const member function内进行</p>
<h3 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h3><p>只要你产生了一个non-heap object而没有为它命名，便诞生了一个临时对象。</p>
<p>此等匿名对象通常发生于：</p>
<ul>
<li>当隐式转换被施行起来以求函数能够调用成功</li>
<li>当函数返回对象的时候</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">countChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buffer[MAX_STRING_LEN];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c &gt;&gt; setw(MAX_STRING_LEN) &gt;&gt; buffer;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;These are &quot;</span>&lt;&lt; countChar(buffer,c);</span><br><span class="line"><span class="comment">//countChar 接收const string &amp;类型，传入的却是char[]</span></span><br><span class="line"><span class="comment">//会调用string的构造器，以buffer为参数生成临时string对象</span></span><br><span class="line"><span class="comment">//当countChar返回时，临时对象自动销毁</span></span><br></pre></td></tr></table></figure>
<p>只有当对象以by value或reference-to-const参数时转换才会发生</p>
<p>如果对象传给一个reference-to-no-const,并不会发生这种转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uppercasify</span><span class="params">(<span class="built_in">string</span> &amp; str)</span></span>;</span><br><span class="line"><span class="keyword">char</span> sub[] = <span class="string">&quot;Effective C++&quot;</span>;</span><br><span class="line">uppercasify(sub);<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//期望是修改原对象，如果允许生成临时对象，修改的只是临时对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Number <span class="keyword">operator</span>+(<span class="keyword">const</span> Number&amp;a,<span class="keyword">const</span> Number&amp;b);</span><br></pre></td></tr></table></figure>
<p>返回值是一个临时对象</p>
<h3 id="返回值优化（RVO"><a href="#返回值优化（RVO" class="headerlink" title="返回值优化（RVO)"></a>返回值优化（RVO)</h3><p>返回所谓<code>constructor arguments</code>以取代对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator()*rhs.numerator(),lhs.denominator(),rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用重载技术避免隐式类型转换"><a href="#利用重载技术避免隐式类型转换" class="headerlink" title="利用重载技术避免隐式类型转换"></a>利用重载技术避免隐式类型转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x=<span class="number">0</span>):x(x)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许</span></span><br><span class="line">    get() = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//允许</span></span><br><span class="line">    A&amp;&amp;a = get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Rational&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x*rhs.y + <span class="keyword">this</span>-&gt;y*rhs.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y*rhs.y;</span><br><span class="line">        <span class="keyword">int</span> z = __gcd(<span class="keyword">this</span>-&gt;x,<span class="keyword">this</span>-&gt;y);</span><br><span class="line">        <span class="keyword">this</span>-&gt;x/=z;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y/=z;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回const,避免写出类似a+b = c;表达式</span></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>+(<span class="keyword">const</span> Rational&amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)&#123;</span><br><span class="line">        <span class="comment">//调用的复制构造函数</span></span><br><span class="line">        <span class="keyword">return</span> Rational(lhs) += rhs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">Rational <span class="title">a</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">   <span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">   a += b;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; a.x &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; a.y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   a = a + b;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; a.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Derived::Derived()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果在堆上创建对象，为其分配堆内存；</span></span><br><span class="line"><span class="comment">// operator new的介绍参见条款 8</span></span><br><span class="line"><span class="keyword">if</span> (本对象在堆上)</span><br><span class="line"><span class="keyword">this</span> = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Derived));<span class="comment">//在构造函数内无法知道对象是不是在堆上,对 this 赋值是非法的。  </span></span><br><span class="line">Base::Base(); <span class="comment">// 初始化 Base 部分,cannot call constructor &#x27;Base::Base&#x27; directly, 通过函数调用访问构造函数也是不允许的。</span></span><br><span class="line">dm1.<span class="built_in">string</span>(); <span class="comment">// 构造 dm1</span></span><br><span class="line">dm2.<span class="built_in">string</span>(); <span class="comment">// 构造 dm2</span></span><br><span class="line">dm3.<span class="built_in">string</span>(); <span class="comment">// 通过对象调用访问构造函数也是不允许的。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator只能声明成友元</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; str,A&amp;a);</span><br><span class="line"><span class="comment">//第一个参数必须是ostream</span></span><br><span class="line"><span class="comment">//如果反过来就会出现 t &lt;&lt; cout;形式调用</span></span><br></pre></td></tr></table></figure>
<h3 id="不要产生内含local-static对象的inline-non-member-functions"><a href="#不要产生内含local-static对象的inline-non-member-functions" class="headerlink" title="不要产生内含local static对象的inline non-member functions"></a>不要产生内含local static对象的inline non-member functions</h3><p><code>inline non-member functions</code>意味着这个函数有内部连接（<code>internal linkage</code>)</p>
<p>函数如果有内部连接，可能在程序中被复制，也就是程序目标代码可能会对带有内部连接的函数复制一份以上代码，而此复制行为包括函数内的staic对象</p>
<p>如果有一个inline non-member function并于其中包含local static对象，程序可能会产生多个static副本</p>
<p>带有private constructors的class不能被继承导致禁止派生</p>
<p>只有const static member能在类定义区内指定初值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects = <span class="number">10</span>;<span class="comment">//类内指定</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;<span class="comment">//类外指定</span></span><br></pre></td></tr></table></figure>
<p>==智能指针没法管理栈上的对象==,事实上也不需要，离开作用域自动析构</p>
<h3 id="在成员函数调用delete-this"><a href="#在成员函数调用delete-this" class="headerlink" title="在成员函数调用delete this"></a>在成员函数调用delete this</h3><p>在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。假设这个成员函数名字叫release，而delete this就在这个release方法中被调用，那么这个对象在调用release方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定 的，调用release之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。说到这里，相信大家都能明白为什么会这样 了。</p>
<p><strong>根本原因</strong>在于delete操作符的功能和类对象的内存模型。当一个类对象声明时，系统会为其分配内存空间。<strong>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中</strong>。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当 调用delete this时，类对象的内存空间被释放。<strong>在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行</strong>。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现<strong>不可预期</strong>的问题。</p>
<p>为什么是不可预期的问题？<strong>delete this之后不是释放了类对象的内存空间了么</strong>，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生<strong>指针错误</strong>，<strong>无访问权限之类的令系统崩溃</strong>的问题才对啊？这个问题牵涉到操作系统的内存管理策略。<strong>delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回</strong>。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<p>大致明白在成员函数中调用delete this会发生什么之后，再来看看另一个问题，如果在类的析构函数中调用delete this，会发生什么？实验告诉我们，会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存” (来自effective c++)。显然，<strong>delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃</strong>。</p>
<p><strong>1.在普通的非const成员函数中：</strong>this的类型是一个指向类类型的const指针，可以改变this指向的值，但是不能改变this所保存的地址</p>
<p>2.在const成员函数中，this的类型是一个指向const类类型对象的const指针，既不能改变this所指向的对象，也不能改变this所保存的地址。</p>
<h3 id="关于成员函数内调用memset-this-0-sizeof-this"><a href="#关于成员函数内调用memset-this-0-sizeof-this" class="headerlink" title="关于成员函数内调用memset(this,0,sizeof(*this))"></a>关于成员函数内调用memset(this,0,sizeof(*this))</h3><p>会将对象内存按位清零，包括成员变量、虚指针、虚基类指针等信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;nothing\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;~A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    B()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;~B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="keyword">sizeof</span>(*<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;test();</span><br><span class="line">    a-&gt;test();<span class="comment">//会发生段错误，虚指针已经被清零</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    B b;</span></span><br><span class="line"><span class="comment">    b.test();</span></span><br><span class="line"><span class="comment">    b.test();//调用没问题，但数据确是清零了，原因在于对象调用虚函数不会通过虚机制，会以B::test()形式调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="push-back-emplace-back"><a href="#push-back-emplace-back" class="headerlink" title="push_back emplace_back"></a>push_back emplace_back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> y=<span class="number">0</span>):x(x),y(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a):x(a.x)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(A&amp;&amp; a):x(<span class="built_in">std</span>::move(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;move constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;~A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;push_back\n&quot;</span>;</span><br><span class="line">        <span class="comment">//vec.push_back(2,2);不被允许</span></span><br><span class="line">        vec.push_back(<span class="number">2</span>);<span class="comment">//此时会先调用A constructor生成临时对象a,然后再调用move constructor</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;push end\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;emplace back\n&quot;</span>;</span><br><span class="line">        vec.emplace_back(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//会直接调用constructor</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;emplace end\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//如下情况是没有区别的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        vec.push_back(a);</span><br><span class="line">        vec.emplace_back(a);<span class="comment">//都会调用copy constructor</span></span><br><span class="line">        </span><br><span class="line">        vec.push_back(A(<span class="number">2</span>));</span><br><span class="line">        vec.emplace_back(A(<span class="number">2</span>));<span class="comment">//都会调用constructor and move constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;test\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;const test\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.test();<span class="comment">//test</span></span><br><span class="line">    <span class="keyword">const</span> A b;</span><br><span class="line">    b.test();<span class="comment">//const test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==可以定义纯虚析构函数，但是纯虚析构函数必须有定义==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~A() = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">A::~A()&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这是非法的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="comment">//合法</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//More Effective C++  p203疑似有误</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()<span class="keyword">const</span>&#123;<span class="keyword">return</span> pointee;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*()<span class="keyword">const</span>&#123;<span class="keyword">return</span> *pointee&#125;;</span><br></pre></td></tr></table></figure>
<p>==传参时隐式类型转换产生临时对象只发生参数以by value或者reference-to-const形式传递时发生，通过reference-to-non-const形式传递不会发生，因为可能改变reference-to-non-const的值，而隐式类型转换会产生临时对象，发生的改变只作用在临时对象上==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>&amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">2.0</span>;</span><br><span class="line">    test(x);<span class="comment">//cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> func(<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    ::<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;func;<span class="comment">//cout未对函数指针进行重载，会把函数指针隐式转换为bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">short</span> num)</span></span>&#123;</span><br><span class="line">    ::<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(::<span class="built_in">std</span>::<span class="built_in">putchar</span>);</span><br><span class="line">   <span class="comment">// print(0);0的类型是int,可以转换为short或指针， call of overloaded &#x27;print(int)&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="空对象调用成员函数"><a href="#空对象调用成员函数" class="headerlink" title="空对象调用成员函数"></a>空对象调用成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nod</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;dynamic print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;static print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printV</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;virtual print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Nod * a = <span class="literal">nullptr</span>;</span><br><span class="line">   a-&gt;printS();<span class="comment">//静态函数，不涉及this指针，没问题</span></span><br><span class="line">   a-&gt;printD();<span class="comment">//不涉及Nod成员变量访问，没问题，涉及成员变量会得到段错误</span></span><br><span class="line">   a-&gt;printV();<span class="comment">//段错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实现final"><a href="#实现final" class="headerlink" title="实现final"></a>实现final</h3><p>1）如果类的构造函数或析析构函数声明为私有的，那么该类不能被继承，但同时该类也不能使用；</p>
<p>2）派生类只能访问基类的公有成员和保护成员，如果是私有继承，基类中所有成员到子类中将成为私有的，子类的派生类也即子类的子类只能访问其直接父类的公有成员或保护成员，不能访问最原始基类的任何成员；</p>
<p>3）如果有三个类A、B、C，B虚拟继承A，C继承B，则意味着C将直接继承A和B，也即构造C的对象时，将会直接调用A的构造函数</p>
<p>(下述解决方案g++不报错)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalBase</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	~FinalBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span> :</span> <span class="keyword">virtual</span> <span class="keyword">private</span> FinalBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i&#x27;m a final class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tfinalclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Final obj;</span><br><span class="line">	obj.foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">MakeFinally</span>&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       MakeFinally()&#123;&#125;;<span class="comment">//只有MakeFinally的友类才可以构造MakeFinally</span></span><br><span class="line">       ~MakeFinally()&#123;&#125;;</span><br><span class="line">   <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span>  MakeFinally&lt;MyClass&gt;&#123;&#125;;<span class="comment">//MyClass是不可派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于虚继承，所以D要直接负责构造MakeFinally类，从而导致编译报错，所以D作为派生类是不合法的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> MyClass&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>（好像也不行）</p>
<ul>
<li>父类写一个纯虚函数 —— 子类<strong>必须</strong>实现这一函数</li>
<li>这个纯虚函数放在 <code>private</code> 区域 —— 子类<strong>不能</strong>实现这一函数</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/07/22/pytorch%E5%A4%87%E5%BF%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/pytorch%E5%A4%87%E5%BF%98/" class="post-title-link" itemprop="url">pytorch备忘</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 14:34:58" itemprop="dateCreated datePublished" datetime="2021-07-22T14:34:58+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-24 18:29:15" itemprop="dateModified" datetime="2021-07-24T18:29:15+08:00">2021-07-24</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/22/pytorch%E5%A4%87%E5%BF%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/22/pytorch%E5%A4%87%E5%BF%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Tensor操作"><a href="#Tensor操作" class="headerlink" title="Tensor操作"></a>Tensor操作</h3><p>创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">torch.zeros(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#全零</span></span><br><span class="line">torch.ones(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#全一</span></span><br><span class="line">torch.Tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])<span class="comment"># from list</span></span><br><span class="line">npy = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">torch.from_numpy(npy)<span class="comment">#from numpy</span></span><br><span class="line">torch.arange(<span class="number">6</span>)<span class="comment">#tensor([0, 1, 2, 3, 4, 5])</span></span><br></pre></td></tr></table></figure>
<p>运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.Tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a + b</span><br><span class="line"><span class="comment">#tensor([3., 5., 7.])</span></span><br><span class="line">a * b</span><br><span class="line"><span class="comment">#tensor([ 2.,  6., 12.])</span></span><br><span class="line">a / b</span><br><span class="line"><span class="comment"># tensor([0.5000, 0.6667, 0.7500])</span></span><br><span class="line">a + <span class="number">1</span></span><br><span class="line"><span class="comment">#tensor([2., 3., 4.])</span></span><br><span class="line">torch.dot(a,b)</span><br><span class="line"><span class="comment">#tensor(20.)</span></span><br><span class="line">a.outer(b)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 2.,  3.,  4.],</span></span><br><span class="line"><span class="string">        [ 4.,  6.,  8.],</span></span><br><span class="line"><span class="string">        [ 6.,  9., 12.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">torch.mm<span class="comment">#矩阵乘法</span></span><br></pre></td></tr></table></figure>
<p>维度操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">6</span>)<span class="comment">#tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="comment">#view 维度不匹配会RE</span></span><br><span class="line">x = x.view(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#tensor([[0, 1, 2],[3, 4, 5]])</span></span><br><span class="line">torch.<span class="built_in">sum</span>(x,dim = <span class="number">0</span>)<span class="comment"># tensor([3, 5, 7])</span></span><br><span class="line">torch.transpose(x,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 3],</span></span><br><span class="line"><span class="string">        [1, 4],</span></span><br><span class="line"><span class="string">        [2, 5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">indices = torch.LongTensor([<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">torch.index_select(x,dim=<span class="number">1</span>,index = indices)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 2],</span></span><br><span class="line"><span class="string">        [3, 5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">row_indices = torch.arange(<span class="number">2</span>).long()</span><br><span class="line">col_indices = torch.LongTensor([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">x[row_indices,col_indices]<span class="comment">#((0,0),(1,1))</span></span><br><span class="line"><span class="comment"># tensor([0, 4])</span></span><br></pre></td></tr></table></figure>
<p>连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">6</span>).view(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">torch.cat([x,x],dim = <span class="number">0</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 1, 2],</span></span><br><span class="line"><span class="string">        [3, 4, 5],</span></span><br><span class="line"><span class="string">        [0, 1, 2],</span></span><br><span class="line"><span class="string">        [3, 4, 5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">torch.stack([x,x])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[0, 1, 2],</span></span><br><span class="line"><span class="string">         [3, 4, 5]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[0, 1, 2],</span></span><br><span class="line"><span class="string">         [3, 4, 5]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>随机数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.rand(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#uniform random</span></span><br><span class="line">torch.randn(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#random normal</span></span><br></pre></td></tr></table></figure>
<p>requires_grad</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad = <span class="literal">True</span>)</span><br><span class="line">x.grad <span class="keyword">is</span> <span class="literal">None</span><span class="comment">#True</span></span><br><span class="line">y = (x + <span class="number">2</span>)*(x + <span class="number">5</span>) + <span class="number">3</span></span><br><span class="line">x.grad <span class="keyword">is</span> <span class="literal">None</span><span class="comment">#True</span></span><br><span class="line">z = y.mean()</span><br><span class="line">z.backward()</span><br><span class="line">x.grad <span class="keyword">is</span> <span class="literal">None</span><span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<p>创建cuda张量</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is<span class="constructor">_avaliable()</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is<span class="constructor">_avaliable()</span> <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">3</span>).<span class="keyword">to</span>(device)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 创建一个张量,在第0维插入一个维度</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">x = x.unsqueeze(<span class="number">0</span>)</span><br><span class="line">x.shape</span><br><span class="line"><span class="comment">#torch.Size([1, 3, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 去掉该维度</span></span><br><span class="line">x = x.squeeze(<span class="number">0</span>)</span><br><span class="line">x.shape</span><br><span class="line"><span class="comment"># torch.Size([3, 3])</span></span><br><span class="line"><span class="comment">#squeeze对size大于1的维度应用无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 在区间[3,7]创建一个形状为5x3的随机张量</span></span><br><span class="line">x = <span class="number">3</span> + torch.rand(<span class="number">5</span>,<span class="number">3</span>)*(<span class="number">7</span>-<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 创建一个具有正态分布(mean = 0, std = 1)的张量</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">x.normal_()</span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 找到 torch.Tensor([1,1,1,0,1])中所有非零元素索引</span></span><br><span class="line">x = torch.Tensor([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">torch.nonzero(x)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0],</span></span><br><span class="line"><span class="string">        [1],</span></span><br><span class="line"><span class="string">        [2],</span></span><br><span class="line"><span class="string">        [4]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6. 创建一个大小为（3,1)的随机向量，水平扩展4个副本</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">x.expand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.0839, 0.0839, 0.0839, 0.0839],</span></span><br><span class="line"><span class="string">        [0.1283, 0.1283, 0.1283, 0.1283],</span></span><br><span class="line"><span class="string">        [0.9937, 0.9937, 0.9937, 0.9937]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7 返回两个三维矩阵的乘积</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">torch.bmm(a,b).shape</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#8 返回一个三维矩阵和一个二维矩阵的乘积</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b = torch.rand(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">torch.bmm(a,b.unsqueeze(<span class="number">0</span>).expand(a.size(<span class="number">0</span>), *b.size()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/07/11/kick-start-2021D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/kick-start-2021D/" class="post-title-link" itemprop="url">kick start 2021D</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-11 21:47:07" itemprop="dateCreated datePublished" datetime="2021-07-11T21:47:07+08:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 12:29:30" itemprop="dateModified" datetime="2021-07-12T12:29:30+08:00">2021-07-12</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/11/kick-start-2021D/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/11/kick-start-2021D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Arithmetic-Square"><a href="#Arithmetic-Square" class="headerlink" title="Arithmetic Square"></a><a target="_blank" rel="noopener" href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813">Arithmetic Square</a></h3><p>给一个3*3matrix，中间位置元素缺失，要求填上中间元素，使得矩阵中行、列、对角线形成的等差数列个数最多</p>
<p>枚举几种填数方式即可。</p>
<p>（唯一一道没WA的==)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;(x));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*A[i][<span class="number">1</span>] == A[i][<span class="number">0</span>]+A[i][<span class="number">2</span>])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*A[<span class="number">1</span>][i] == A[<span class="number">0</span>][i]+A[<span class="number">2</span>][i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*A[<span class="number">1</span>][<span class="number">1</span>] == A[<span class="number">0</span>][<span class="number">0</span>]+A[<span class="number">2</span>][<span class="number">2</span>])</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*A[<span class="number">1</span>][<span class="number">1</span>] == A[<span class="number">0</span>][<span class="number">2</span>] + A[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[<span class="number">0</span>][<span class="number">0</span>] + A[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans = check();</span><br><span class="line">    x = A[<span class="number">2</span>][<span class="number">0</span>] + A[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    ans = max(ans,check());</span><br><span class="line">    x = A[<span class="number">1</span>][<span class="number">0</span>] + A[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    ans = max(ans,check());</span><br><span class="line">    x = A[<span class="number">0</span>][<span class="number">1</span>] + A[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    ans = max(ans,check());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">sc(t)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=t; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        sc(A[<span class="number">0</span>][i])</span><br><span class="line">    &#125;</span><br><span class="line">    sc(A[<span class="number">1</span>][<span class="number">0</span>])sc(A[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        sc(A[<span class="number">2</span>][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = slove();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/11/kick-start-2021D/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/07/06/%E6%8F%92%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/06/%E6%8F%92%E5%80%BC/" class="post-title-link" itemprop="url">插值</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-06 15:24:44 / 修改时间：16:21:07" itemprop="dateCreated datePublished" datetime="2021-07-06T15:24:44+08:00">2021-07-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/06/%E6%8F%92%E5%80%BC/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/06/%E6%8F%92%E5%80%BC/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Lagrange插值法"><a href="#Lagrange插值法" class="headerlink" title="Lagrange插值法"></a>Lagrange插值法</h3><p>给定一组n个函数点值${(x<em>{1},f(x</em>{1})),(x<em>{2},f(x</em>{2})),\cdots,(x<em>{n},f(x</em>{n}))}$,用n-1次多项式拟合这n个点.</p>
<p>记$f(x) = l<em>{1}(x)f(x</em>{1}) + l<em>{2}(x)f(x</em>{2}) + \cdots + l<em>{n}(x)f(x</em>{n}) $</p>
<p>其中$l<em>{i}(x) = 0, x \neq x</em>{i}$</p>
<p>​       $l<em>{i}(x) =1,x = x</em>{i}$</p>
<p>可以将$l_{i}(x)$构造成</p>
<p>$l<em>{i}(x) = \frac{(x-x</em>{1})\cdots (x-x<em>{i-1})(x-x</em>{i+1})\cdots(x-x<em>{n})}{(x</em>{i}-x<em>{1})\cdots(x</em>{i}-x<em>{i-1})(x</em>{i}-x<em>{i+1})\cdots (x</em>{i}-x_{n})} $</p>
<p>当$x<em>{1},x</em>{2},\cdots,x_{n}$取连续值时，如$1,2,\cdots,n$,有</p>
<p>$l_{i}(x) = \frac{(x-1)\cdots (x-(i-1))(x-(i+1))\cdots (x-n)}{(i-1)\cdots(i-(i-1))(i-(i+1))\cdots(i-n)}$</p>
<p>分母可以化简为</p>
<p>$(-1)^{n-i}(i-1)!(n-i)!$</p>
<p>我们可以利用Lagrange插值法实现形如$\Sigma_{i=1}^{n} i^k$快速求和,==n很大，k很小==</p>
<p>我们有结论$\Sigma i^{k}$是k+1次多项式，记为$S_{i}$</p>
<p>可以预处理计算前k+2项的和，得到$S<em>{i}$的k+2项点值，从而确定$S</em>{i}$的Lagrange插值形式。</p>
<p>通过插值表达式求$S_{n}$的值。</p>
<p>我们可以预处理$1-n$阶乘的逆元，对于$l_{i}(x)$分子那个东西，可以先预处理前缀乘积和后缀乘积</p>
<p>这样每一项的计算都是$O(1)$，计算$S_{n}$总的复杂度为$O(n)$</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/06/%E6%8F%92%E5%80%BC/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/07/04/linux%E5%86%85%E6%A0%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/04/linux%E5%86%85%E6%A0%B8/" class="post-title-link" itemprop="url">linux内核</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-04 15:48:43" itemprop="dateCreated datePublished" datetime="2021-07-04T15:48:43+08:00">2021-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-08 22:33:18" itemprop="dateModified" datetime="2021-07-08T22:33:18+08:00">2021-07-08</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/04/linux%E5%86%85%E6%A0%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/04/linux%E5%86%85%E6%A0%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用通过返回一个long类型来表示成功与否，（通常0成功、负值失败</p>
<p>系统调用出错时，将错误码写入全局<code>errno</code>中，通过调用<code>perror()</code>可翻译成字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123; </span><br><span class="line">         <span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SYSCALL_DEFINE0</code>是一个宏，定义一个无参数(0个)的系统调用</p>
<p><code>asmlinkage long sys_getpid(void)</code></p>
<p><code>asmlinkage</code>限定词。是一个编译指令，通知编译器仅从栈中提取该函数的参数，所有的系统调用需要这一限定词</p>
<p>函数返回值为long,系统调用在内核空间、用户空间的返回值分别为long,int</p>
<p>系统调用在内核中定义都加<code>sys_</code>前缀</p>
<ul>
<li><p>系统调用号</p>
<p>每个系统调用赋予了一个系统调用号，通过系统调用号关联系统调用</p>
<p>当用户进程执行一个系统调用时，这个系统调用号就用来指明到底是要执行哪个系统调用。</p>
<p>系统调用号一经分配不能变更，linux中有一个未实现的sys_ni_syscall() 只返回-ENOSYS，这个错误号是为无效系统调用设置的</p>
</li>
<li><p>用户空间程序无法执行内核代码，应该通过一定方式通知系统，告诉内核自己需要执行一个系统调用</p>
<p>通知内核的机制是通过软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序</p>
<p>此时的异常处理程序就是系统调用处理程序，在x86系统上预定义的软中断是中断号128，通过<code>int$0x80</code>触发中断</p>
</li>
<li><p>指定恰当系统调用</p>
<p>系统调用号通过<code>eax</code>寄存器传递给内核</p>
<p>sys_call()函数通过给定的NR_syscalls作比较来检查其有效性，如果大于等于NR_syscalls,则返回-ENOSYS,否则执行相应系统调用</p>
<p><code>call *sys_call_table(,%rax,8)</code></p>
<p>系统调用表表项是以64位（8字节）类型存放的</p>
</li>
<li><p>参数传递</p>
<p>通过<code>ebx ecx edx esi edi</code>按照顺序存放前五个参数</p>
<p>需要六个及六个以上参数的情况，需要一个单独的寄存器存放指向所有这些参数在用户空间地址的指针</p>
</li>
<li><p>参数验证</p>
<p>系统调用需要检查所有参数是否合法有效</p>
<p>在接受一个用户空间的指针之前，内核需要保证：</p>
<ul>
<li>指针指向的内存区域属于用户空间，进程不能哄骗内核去读内核空间的数据</li>
<li>指针指向的内存区域在进程的地址空间，进程绝不能哄骗内核去读其他进程的数据</li>
<li>如果是读，该内存应被标记位可读，如果是写，该内存应被标记为可写，如果是可执行，该内存被标记为可执行</li>
</ul>
<p>为了向用户空间写入数据，内核提供了<code>copy_to_user()</code>,他需要三个参数，第一个是进程空间的目的内存地址，一个是内核空间的源地址，最后一个是数据长度</p>
<p>为了向内核空间写入数据，<code>copy_from_user()</code></p>
<p>如果执行失败，这两个函数返回的都是没能完成拷贝的数据字节数，如果成功返回0，当出现错误时，返回标准-EFAULT</p>
<p><code>copy_to_user</code>,<code>copy_from_user</code>都可能引起阻塞，当包含用户数据的页被换出时，这种情况就会发生，此时进程就会休眠，直到却也处理程序将该页重新换入物理内存</p>
<p>最后一项检查针对是否有合法权限</p>
<ul>
<li>老版Linux内核需要超级用户权限的系统调用才可以调用<code>suser()</code>函数完成检查</li>
<li>新的系统允许检查针对特定资源的特殊权限，调用者可以使用<code>capable()</code>来检查是否有劝能对指定的资源进行操作</li>
</ul>
</li>
<li><p>系统调用上下文</p>
<p>内核在执行系统调用时处于进程上下文</p>
<p>current指针指向当前任务，即引发系统调用的进程</p>
<p>在进程上下文中，内核可以休眠（比如在系统调用阻塞或者显示调用schedule()的时候）并且可以抢占</p>
<p>首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能</p>
<p>在进程上下文中能够被抢占表明，像用户空间中的进程一样，当前的进程可以被其他进程抢占</p>
<p>因为新的进程可以使用相同的系统调用，所以需要保证系统调用是可重入的</p>
<p>当系统调用返回后，控制权仍在system_call()中，它最终会负责切换到用户空间</p>
</li>
<li><p>绑定一个系统调用</p>
<p>首先，在系统调用表中最后加入一个表项，从0开始计算，系统调用在该表中的位置就是它的系统调用号</p>
<p>对于所支持的各种体系结构，系统调用号都必须定义于<code>&lt;asm/unistd.h&gt;</code></p>
<p>系统调用必须被编译进内核映像（不能编译成模块），这只要把它放进kernel/下的一个相关文件中就可以了</p>
</li>
<li><p>从用户空间访问系统调用</p>
<p>open()系统调用的定义：</p>
<p><code>long open(const char *filename,int flags,int mode)</code></p>
<p>不靠库支持，直接调用此系统调用的宏形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_open 5</span></span><br><span class="line">_syscall3(<span class="keyword">long</span>,open,<span class="keyword">const</span> <span class="keyword">char</span> *,filename,<span class="keyword">int</span>,flags,<span class="keyword">int</span>,mode)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><code>&lt;linux/list.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>令人迷惑的宏</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">name</span> =</span> LIST_HEAD_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开一下就能看懂了==</span></span><br><span class="line"><span class="comment">//struct list_head list = &#123;&amp;list,&amp;list&#125;</span></span><br></pre></td></tr></table></figure>
<p>遍历list</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line">	<span class="keyword">for</span> (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) ((size_t)&amp;((TYPE*)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p>对地址0强转？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span><span class="comment">//0</span></span><br><span class="line">	<span class="keyword">char</span> c;<span class="comment">//8</span></span><br><span class="line">	<span class="keyword">int</span> a;<span class="comment">//12，这里发生了内存对齐，64位机器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(struct Node * node)</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里只计算相对首地址偏移量，不会发生段错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n%u\n%u\n%u\n&quot;</span>,node,&amp;node-&gt;next,&amp;node-&gt;c,&amp;node-&gt;a);</span><br><span class="line">	<span class="comment">//printf(&quot;%d&quot;,node-&gt;a);只有去访问一个成员才会出现段错误</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,<span class="keyword">sizeof</span>(*node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>64位系统<code>long</code>竟然是和<code>long long</code>数据范围一致，8位</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr,type,member) (&#123;\</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">(((type*)<span class="number">0</span>)-&gt;member)</span>*__mptr </span>= (ptr);\</span><br><span class="line">    (type*)((<span class="keyword">char</span>*)__mptr -offsetof(type,member));&#125;)</span><br></pre></td></tr></table></figure>
<p> 其中<code>typeof</code>是GNU中获取变量类型的关键字</p>
<p>为啥要有第一句？</p>
<p>因为宏没有参数检查的功能，增加这个<code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr)</code>赋值语句之后，如果类型不匹配，会有警告</p>
<p><code>ptr</code>，是指向<code>member</code>的指针，<code>type</code>，是容器结构体的类型，<code>member</code>就是结构体中的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)				\</span></span><br><span class="line">	<span class="keyword">for</span> (pos = list_first_entry(head, typeof(*pos), member);	\</span><br><span class="line">	     !list_entry_is_head(pos, head, member);			\</span><br><span class="line">	     pos = list_next_entry(pos, member))</span><br></pre></td></tr></table></figure>
<p>安全遍历list,用n缓存下一个节点，可以在遍历时删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line">	<span class="keyword">for</span> (pos = list_first_entry(head, typeof(*pos), member),	\</span><br><span class="line">		n = list_next_entry(pos, member);			\</span><br><span class="line">	     !list_entry_is_head(pos, head, member); 			\</span><br><span class="line">	     pos = n, n = list_next_entry(n, member))</span><br></pre></td></tr></table></figure>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><code>&lt;linux/kfifo&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kfifo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	in;<span class="comment">//入口偏移</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	out;<span class="comment">//出口偏移</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	esize;</span><br><span class="line">	<span class="keyword">void</span>		*data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>__attribute__((aligned(n)))</code>：此属性指定了指定类型的变量的最小对齐(以字节为单位),如果结构中有成员的长度大于n，则按照最大成员的长度来对齐.</p>
<p>注意：对齐属性的有效性会受到链接器(linker)固有限制的限制，即如果你的链接器仅仅支持8字节对齐，即使你指定16字节对齐，那么它也仅仅提供8字节对齐。</p>
<p><code>__attribute__((packed))</code>此属性取消在编译过程中的优化对齐</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>Linux内核提供唯一标志数（UID)到一个指针的映射</p>
<p><code>idr</code>数据结构用于映射用户空间的UID,比如将<code>inodify watch</code>的描述符或者POSIX的定时器ID映射到内核中相关联的数据结构上</p>
<ul>
<li>初始化一个idr</li>
</ul>
<p>静态或动态分配一个idr数据结构</p>
<p>然后调用<code>idr_init()</code></p>
<p><code>void idr_init(struct idr *idp)</code></p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">id_huh</span>;</span><span class="comment">/*静态定义idr结构*/</span></span><br><span class="line">idr_init(&amp;id_huh);</span><br></pre></td></tr></table></figure>
<ul>
<li>分配一个新的UID</li>
</ul>
<p>一旦建立了idr，就可以分配新的UID</p>
<ol>
<li>告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小</li>
</ol>
<p><code>int idr_pre_get(struct idr *idp,gfp_t gfp_mask);</code></p>
<p>该函数在需要时进行<code>UID</code>分配工作，调整由<code>idp</code>指向的<code>idr</code>大小，如果真的需要调整大小，则内存分配例程使用<code>gfp</code>标志：<code>gfp_mask</code></p>
<p>==该函数成功时返回1，失败时返回0==</p>
<ol>
<li>请求新的UID</li>
</ol>
<p>实际执行获取新的UID，并将其加到idr中</p>
<p><code>int idr_get_new(struct idr *idp,void *ptr,int *id);</code></p>
<p>该方法使用<code>idp</code>所指向的idr去分配一个新的UID,并且将其关联到指针ptr上，成功时该方法返回0，并将新的UID存于id。</p>
<p>错误时，返回非0错误码，错误码是<code>-EAGAIN</code>说明需要再次调用<code>idr_pre_get()</code>,如果idr已满，错误码为<code>-ENOSPC</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!idr_pre_get(&amp;id_huh,GFP_KERNEL))&#123;</span><br><span class="line"> <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">ret = idr_get_ner(&amp;idr_huh,ptr,&amp;id);</span><br><span class="line">&#125;<span class="keyword">while</span>(ret == -EAGAIN);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查找UID</p>
<p><code>void *idr_find(struct idr*idp,int id);</code></p>
<p>如果调用成功，则返回id关联的指针，如果错误，则返回空指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">ptr</span> =</span> idr_find(&amp;id_huh,id);</span><br><span class="line"><span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line"> <span class="keyword">return</span> -EINVAL;<span class="comment">/*错误*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除UID</p>
<p><code>void idr_remove(struct idr*idp,int id)</code></p>
<p>删除id及id关联的指针，不提供错误信息</p>
</li>
<li><p>撤销idr</p>
<p><code>void idr_destory(struct idr *idp)</code></p>
<p>释放idr中未使用的内存，不释放已经分配给UID使用的任何内存</p>
</li>
</ul>
<p><code>void idr_remove_all(struct idr*idp)</code></p>
<p>强制删除所有UID</p>
<h4 id="rb-tree"><a href="#rb-tree" class="headerlink" title="rb tree"></a>rb tree</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;<span class="comment">//parent and current color</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r)   ((struct rb_node *)((r)-&gt;__rb_parent_color &amp; ~3))  <span class="comment">//获得父结点的地址  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_color(r)   ((r)-&gt;rb_parent_color &amp; 1) <span class="comment">//获得颜色属性</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>奇奇怪怪的结构体初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_ROOT	(struct rb_root) &#123; NULL, &#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="强制内联-always-inline"><a href="#强制内联-always-inline" class="headerlink" title="强制内联 __always_inline"></a>强制内联 <code>__always_inline</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *</span></span><br><span class="line"><span class="class"><span class="title">rb_find_add</span>(<span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>, <span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">tree</span>,</span></span><br><span class="line"><span class="class">	    <span class="title">int</span> (*<span class="title">cmp</span>)(<span class="keyword">struct</span> <span class="title">rb_node</span> *, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">rb_node</span> *));</span></span><br></pre></td></tr></table></figure>
<p>带缓存的根节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rb_root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>O(1)获取最小节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_first_cached(root) (root)-&gt;rb_leftmost</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># define likely(<span class="name">x</span>)  __builtin_expect(!!(<span class="name">x</span>), <span class="number">1</span>)</span><br><span class="line"># define unlikely(<span class="name">x</span>)    __builtin_expect(!!(<span class="name">x</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>述源码中采用了内建函数<strong>builtin_expect来进行定义，即 built in function。<br>　　`</strong>builtin_expect<code>的函数原型为</code>long <strong>builtin_expect (long exp, long c)<code>，返回值为完整表达式</code>exp<code>的值，它的作用是期望表达式</code>exp<code>的值等于</code>c<code>（如果</code>exp == c<code>条件成立的机会占绝大多数，那么性能将会得到提升，否则性能反而会下降）。注意，</code></strong>builtin_expect (exp, c)<code>的返回值仍是</code>exp<code>值本身，并不会改变</code>exp<code>的值。</code>__builtin_expect<code>函数用来引导</code>gcc`进行条件分支预测。在一条指令执行时，由于流水线的作用，CPU可以同时完成下一条指令的取指，这样可以提高CPU的利用率。在执行条件分支指令时，CPU也会预取下一条执行，但是如果条件分支的结果为跳转到了其他指令，那CPU预取的下一条指令就没用了，这样就降低了流水线的效率。<br>　　另外，跳转指令相对于顺序执行的指令会多消耗CPU时间，如果可以尽可能不执行跳转，也可以提高CPU性能。<br>　　简单从表面上看if(likely(value)) == if(value)，if(unlikely(value)) == if(value)。<br>也就是likely和unlikely是一样的，但是实际上执行是不同的，加likely的意思是value的值为真的可能性更大一些，那么执行if的机会大，而unlikely表示value的值为假的可能性大一些，执行else机会大一些。<br>　　加上这种修饰，编译成二进制代码时likely使得if后面的执行语句紧跟着前面的程序，unlikely使得else后面的语句紧跟着前面的程序，这样就会被cache预读取，增加程序的执行速度。</p>
<h4 id="radix-tree"><a href="#radix-tree" class="headerlink" title="radix_tree"></a>radix_tree</h4><p>linux的基数树结构是将指针与long类型的整数键值相映射的机制，可以提到查找的效率，是典型的以空间换取时间的做法.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">radix_tree_root</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">gfp_t</span> gfp_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">rnode</span>;</span>  <span class="comment">/*间接指针，指向节点而非数据条目，通过设置root-&gt;rnode的低位表示是否是间接指针*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  height;  <span class="comment">/*从叶子节点向上计算的树高度*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;    <span class="comment">/*非叶子节点包含一个count域，表示出现在该节点的孩子节点的数量*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    <span class="keyword">void</span>*  slot[RADIX_TREE_MAP_SIZE];  <span class="comment">//64个指针，指示该几点的子节点最多有64个，该值是可以进行设置的，参考下面的全局变量的设置*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以index=0x5BFB68为例，化为二进制，每6位为一组：10110(22,第一层编号),111111(63,第2层编号),101101(45,第三层编号),101000(40,第四层编号)</p>
<p>dix_tree_node.tags:  标识该节点的每个子节点中的标志位，是通过位图的方式进行表示的。该域是一个2X2的数组，其中每个成员都是32位。在该节点结构中每个slot都用2位标识，用于记录该节点下面的子节点的响应标识位有没有被置位。行数对应于有多少个标识，比如，如果有两个标识，PAGE_DIRTY和PAGE_WRITEBACK，那么就需要使用两行；如果有三个标识，就使用三行。列数对应于有多少个子节点，例如，如果有64个子节点，那么每一列代表其中的一个子节点。因此，该2x2数组中的每个值代表了每个slot中的每个标识是否被设置（当然需要将long类型的整数对应成二进制位才行，那么64个子节点恰好是需要64位，恰好是两个long  int 类型，每位代表一个子节点；每行代表一个标识）。该标识对于基数树的查找非常有帮助。如果tag[0]=0（PAGE_DIRTY为全为0），那么标识该节点对应的子节点中没有相应的节点有存在脏页，则在寻找脏页的过程中可以绕过该节点所对应的所有子节点，而不用遍历整棵树，提高了查找的效率；tag[1]=0（PAGE_WRITEBACK标志全为0)。</p>
<h3 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h3><p>中断使得硬件得以发出通知给处理器。中断本质上是一种特殊的电信号，由硬件设备发向处理器，处理器接收到中断后，会马上向操作系统反映此信号到来，然后就由操作系统负责处理这些新到来的数据。</p>
<p>中断本质上是一种电信号，由硬件设备生成，并直接送入中断控制器的输入引脚中。</p>
<p>当接收到一个中断后，中断控制器会给处理器发送一个电信号。</p>
<p>不同设备对应的中断不同，而每个中断都通过一个唯一的数字标识。</p>
<p>这些中断值通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量。</p>
<ul>
<li>异常：</li>
</ul>
<p>异常与中断不同，它在产生时必须考虑与处理器时钟同步。</p>
<p>异常常被称为同步中断</p>
<p>中断与异常工作方式类似，差异在于中断是由硬件而不是由软件引起。</p>
<h4 id="中断处理程序（interrupt-handler"><a href="#中断处理程序（interrupt-handler" class="headerlink" title="中断处理程序（interrupt handler)"></a>中断处理程序（interrupt handler)</h4><p>在响应一个特定的中断时，内核会执行一个函数，该函数叫做中断处理函数。</p>
<p>一个设备的中断处理程序是它设备驱动程序的一部分。设备驱动程序是用于对设备进行管理的内核代码。</p>
<p>中断处理程序是被内核调用来响应中断的，他们运行在我们称之为中断上下文的特殊上下文中。该上下文中的执行代码不可阻塞。</p>
<h4 id="上半部下半部"><a href="#上半部下半部" class="headerlink" title="上半部下半部"></a>上半部下半部</h4><p>要求：</p>
<p>中断处理程序运行快，完成工作量多</p>
<p>处理：</p>
<p>把中断处理程序分为两个部分：</p>
<ul>
<li>上半部，接受一个中断，马上执行，只做有严格时限的工作。</li>
<li>能够被允许稍后完成的工作推迟到下半部。</li>
</ul>
<h4 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h4><p><code>&lt;linux/interrupt.h&gt;</code></p>
<p><code>int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev);</code></p>
<p>第一个参数表示要分配的中断号，对某些设备，这个值是预先确定的，对大多数设备，可以通过探测获取或者编程动态确定。</p>
<p>第二个参数handler是一个指针，指向中断处理函数。</p>
<p><code>typedef irqreturn_t (*irq_handler_t)(int, void *)</code></p>
<p>接收两个参数，返回一个<code>irqreturn_t</code></p>
<p>第三个参数flags可以为0，也可以是下列一个或多个标志的位掩码。</p>
<p><code>IRQF_DISABLED</code>: 内核在处理中断处理程序时，禁止所有其他的中断。</p>
<p><code>IRQF_SAMPLE_RANDOM</code>:表明这个设备产生的中断对内核熵池有贡献。内核熵池负责从各种随机事件中导出真正的随机数。</p>
<p><code>IRQF_TIMER</code>:系统定时器的中断处理准备的</p>
<p><code>IRQF_SHARED</code>:多个中断处理程序之间共享中断线。</p>
<p>第四个参数name是中断相关设备的ASCII文本表示。键盘中断对应<code>keyboard</code>,这些名字被<code>/proc/irq</code>和<code>/proc/interrupts</code>使用</p>
<p>第五个参数dev用于共享中断线，当一个中断处理程序需要释放时，dev将提供唯一的标志信息（cookie)，以便从共享中断线的诸多处理程序中删除指定的哪一个。</p>
<p><code>request_irq()</code>成功执行返回0，返回非零表示有错误发生。</p>
<p><code>request_irq()</code>函数可能睡眠，不能在中断上下文或其他不允许阻塞代码中调用该函数，在注册过程中，内核需要在/proc/irq文件中创建一个与中断对应的项。</p>
<p>函数<code>proc_mkdir()</code>用来创建这个<code>procfs</code>项，通过调用<code>proc_create()</code>对这个新的项进行设置，而<code>proc_create()</code>会调用<code>kmalloc()</code>,<code>kmalloc()</code>是可以睡眠的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(request_irq(irqn,my_interrupt,IRQF_SHARED,<span class="string">&quot;my_device&quot;</span>,my_dev))&#123;</span><br><span class="line">printk(KERN_ERR <span class="string">&quot;my_device:cannot register IRQ %d\n&quot;</span>,irqn);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h4><p><code>void free_irq(unsigned int irq,void * dev)</code></p>
<p>卸载驱动程序时，需要注销相应的中断处理程序，并释放总线。</p>
<p>总线非共享直接删除，共享仅删除dev对应的处理程序。</p>
<h4 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h4><p><code>static irqreturn_t intr_handler(int irq,void *dev)</code></p>
<p>第一个参数irq是这个处理程序要响应的中断的中断号。</p>
<p>第二个参数dev是一个通用指针，它与在中断处理程序注册时传递给<code>request_irq()</code>的参数dev必须一致。</p>
<p>中断处理程序返回值是一个特殊类型<code>irqreturn_t</code></p>
<p>中断处理程序可能返回两个特殊的值：<code>IRQ_NONE</code> <code>IRQ_HANDLED</code></p>
<p>当中断处理程序检测到一个中断，但该中断对应的设备并不是在注册处理函数期间产生的指定的产生源时，返回<code>IRQ_NONE</code></p>
<p>当中断处理程序被正确调用，且确是它所对应的设备产生了中断时返回<code>IRQ_HANDLED</code></p>
<p>Linux中的中断处理程序是无需重入的，当一个给定的中断处理程序正在执行，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接受另一个新的中断。但不影响其他中断线。</p>
<h4 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h4><ul>
<li>request_irq()的flags必须设为IRQF_SHARED标志</li>
<li>对于每个注册的中断处理程序，dev参数必须唯一</li>
<li>中断处理程序必须能够区分它的设备是否真的产生了中断</li>
</ul>
<p>指定IRQF_SHARED标志调用request_irq()时，只有在</p>
<ul>
<li>当前中断线未被注册</li>
<li>当前中断线所有已注册处理程序指定了IRQF_SHARED时才能成功</li>
</ul>
<p>内核在接收到一个中断后，依次调用该中断线上注册的每一个中断处理程序。因此处理程序必须知道他是否对这个中断负责。</p>
<h4 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h4><p>进程上下文是一种内核所处的操作模式，此时内核代表进程执行（执行系统调用、运行内核进程）。在进程上下文中，可以通过current宏关联当前线程。</p>
<p>中断上下文和进程无关，没有后备线程，不能睡眠，否则不能对它进行重新调度。</p>
<p>中断上下文有较为严格时间限制，因为打断了其他代码。中断上下文中的代码应该迅速简洁，尽量不使用循环。</p>
<p>中断处理程序栈是一个配置选项，（曾经共享中断进程的内核栈。</p>
<h4 id="中断处理机制的实现"><a href="#中断处理机制的实现" class="headerlink" title="中断处理机制的实现"></a>中断处理机制的实现</h4><p>设备产生中断，通过总线将电信号发送个中断控制器，如果中断线是激活的（允许被屏蔽），那么中断控制器将把中断发送给处理器。除非在处理器上禁止该中断，处理器会立刻停止正在做的事情，关闭中断系统，跳到内存中预定义位置开始执行那里的代码，这个位置是内核设置的，是中断处理的入口点。</p>
<p>对于每条中断线，处理器都会跳到对应唯一位置，这样内核就知道所接收中断的IRQ号，初始入口点只是在栈上保存这个号，并存放当前寄存器的值（这些值属于当前被中断任务）。</p>
<p>然后内核调用do_IRQ()</p>
<p><code>unsigned int do_IRQ(struct pt_regs regs)</code></p>
<p>计算出中断号，do_IRQ()对所接受的中断进行应答，禁止这条线上中断传递</p>
<p>do_IRQ()需要确保这条中断线上有一个有效的处理程序，并且这个程序已经启动，但没执行</p>
<p>调用handle_IRQ_event()来运行这条中断线所安装的中断处理程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/07/01/%E6%A0%91%E5%89%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/01/%E6%A0%91%E5%89%96/" class="post-title-link" itemprop="url">树剖</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 17:02:10" itemprop="dateCreated datePublished" datetime="2021-07-01T17:02:10+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 18:20:29" itemprop="dateModified" datetime="2021-07-02T18:20:29+08:00">2021-07-02</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/01/%E6%A0%91%E5%89%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/01/%E6%A0%91%E5%89%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="POJ-2763"><a href="#POJ-2763" class="headerlink" title="POJ 2763"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2763">POJ 2763</a></h3><ul>
<li><p>题意</p>
<p>给一棵边带权树，给定一个初始位置<code>s</code></p>
<p>有两种操作：</p>
<p>a. 从位置s转移到位置u,输出s-&gt;u距离</p>
<p>b.修改某一条边的权重</p>
</li>
<li><p>树剖，将树序列化</p>
<p>将边权转移到点上</p>
<p>树状数组支持单点修改</p>
<p>区间查询</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> son[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;G[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> n,q,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[x] = d;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    dep[x] = (f &lt;<span class="number">0</span> ? <span class="number">0</span>:dep[f]+<span class="number">1</span>);</span><br><span class="line">    son[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(a.first,x,d+a.second);</span><br><span class="line">            sz[x] += sz[a.first];</span><br><span class="line">            <span class="keyword">if</span>(son[x] == <span class="number">-1</span> || sz[son[x]] &lt; sz[a.first])</span><br><span class="line">            &#123;</span><br><span class="line">                son[x] = a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">100003</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> rev[<span class="number">100003</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">100003</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= <span class="number">100000</span>; i+= (i&amp;-i))</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i -= (i&amp;-i))</span><br><span class="line">    &#123;</span><br><span class="line">        ans += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = (f &lt; <span class="number">0</span> ? x:(son[f] == x ? top[f]:x));</span><br><span class="line">    id[x] = k;</span><br><span class="line">    rev[k++] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs1(son[x],x);</span><br><span class="line">        add(id[son[x]],dist[son[x]] - dist[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f &amp;&amp; a.first != son[x])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(a.first,x);</span><br><span class="line">            add(id[a.first],a.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">pair</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; &gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;q,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">        G[x].push_back(<span class="built_in">make_pair</span>(y,v));</span><br><span class="line">        G[y].push_back(<span class="built_in">make_pair</span>(x,v));</span><br><span class="line">        mp[i] = <span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(x,y),v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs1(s,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;v);</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; u = mp[y].first;</span><br><span class="line">            <span class="keyword">int</span> g = mp[y].second;</span><br><span class="line">            <span class="keyword">int</span> o;</span><br><span class="line">            <span class="keyword">if</span>(dep[u.first] &gt; dep[u.second])&#123;</span><br><span class="line">                o = u.first;</span><br><span class="line">            &#125;<span class="keyword">else</span> o = u.second;</span><br><span class="line"></span><br><span class="line">            add(id[o],-mp[y].second);</span><br><span class="line">            mp[y].second = v;</span><br><span class="line">            add(id[o],v);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            <span class="keyword">int</span> nxt = y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(top[s] == top[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dep[s] &lt; dep[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += ask(id[y]) - ask(id[s]);</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += ask(id[s]) - ask(id[y]);</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//比较的是top[x] top[y]的深度</span></span><br><span class="line">                <span class="keyword">if</span>(dep[top[s]] &lt; dep[top[y]])&#123;</span><br><span class="line">                    ans += ask(id[y])- ask(id[top[y]]<span class="number">-1</span>);</span><br><span class="line">                    y = fa[top[y]];</span><br><span class="line">                </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += ask(id[s]) - ask(id[top[s]]<span class="number">-1</span>);</span><br><span class="line">                    s = fa[top[s]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">5 100 1</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 5 4</span></span><br><span class="line"><span class="comment">0 3</span></span><br><span class="line"><span class="comment">0 2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="POJ-3237"><a href="#POJ-3237" class="headerlink" title="POJ 3237"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3237">POJ 3237</a></h3><ul>
<li>给一棵带权树，实现三种操作<ul>
<li>修改某一条边的权值</li>
<li>将路径u-&gt;v上所有边的权值取相反数</li>
<li>查询路径u-&gt;v上权值最大的边</li>
</ul>
</li>
<li>树链剖分</li>
<li>线段树维护单点修改，区间取反</li>
<li>注意懒标下传、上传</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> son[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;G[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[x] = d;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    dep[x] = (f &lt;<span class="number">0</span> ? <span class="number">0</span>:dep[f]+<span class="number">1</span>);</span><br><span class="line">    son[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(a.first,x,a.second);</span><br><span class="line">            sz[x] += sz[a.first];</span><br><span class="line">            <span class="keyword">if</span>(son[x] == <span class="number">-1</span> || sz[son[x]] &lt; sz[a.first])</span><br><span class="line">            &#123;</span><br><span class="line">                son[x] = a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">10003</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> rev[<span class="number">10003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">40005</span>];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P[<span class="number">40005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        P[x].first = P[x].second = dist[rev[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(<span class="number">2</span>*x,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*x+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">        P[x].first = P[x].second = v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x].second);</span><br><span class="line">        P[<span class="number">2</span>*x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x].second *= <span class="number">-1</span>;</span><br><span class="line">        swap(P[<span class="number">2</span>*x+<span class="number">1</span>].first,P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].first *= <span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">2</span>*x] ^= f[x];</span><br><span class="line">        f[<span class="number">2</span>*x+<span class="number">1</span>]^= f[x];</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        modify(<span class="number">2</span>*x, y,l,mid,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> modify(<span class="number">2</span>*x+<span class="number">1</span>,y,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">neg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= l &amp;&amp; b &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x] ^= <span class="number">1</span>;</span><br><span class="line">        swap(P[x].first,P[x].second);</span><br><span class="line">        P[x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[x].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x].second);</span><br><span class="line">        P[<span class="number">2</span>*x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x].second *= <span class="number">-1</span>;</span><br><span class="line">        swap(P[<span class="number">2</span>*x+<span class="number">1</span>].first,P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].first *= <span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">2</span>*x] ^= f[x];</span><br><span class="line">        f[<span class="number">2</span>*x+<span class="number">1</span>]^= f[x];</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        neg(<span class="number">2</span>*x,a,b,l,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        neg(<span class="number">2</span>*x+<span class="number">1</span>,a,b,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= l &amp;&amp; b &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> P[x].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x].second);</span><br><span class="line">        P[<span class="number">2</span>*x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x].second *= <span class="number">-1</span>;</span><br><span class="line">        swap(P[<span class="number">2</span>*x+<span class="number">1</span>].first,P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].first *= <span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">2</span>*x] ^= f[x];</span><br><span class="line">        f[<span class="number">2</span>*x+<span class="number">1</span>]^= f[x];</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ask(<span class="number">2</span>*x,a,b,l,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ask(<span class="number">2</span>*x+<span class="number">1</span>,a,b,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ans = max(ask(<span class="number">2</span>*x,a,b,l,mid),ask(<span class="number">2</span>*x+<span class="number">1</span>,a,b,mid+<span class="number">1</span>,r));</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = (f &lt; <span class="number">0</span> ? x:(son[f] == x ? top[f]:x));</span><br><span class="line">    id[x] = k;</span><br><span class="line">    rev[k++] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs1(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f &amp;&amp; a.first != son[x])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(a.first,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; mp;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,v,w;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        mp.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            G[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">            G[x].push_back(<span class="built_in">make_pair</span>(y,v));</span><br><span class="line">            G[y].push_back(<span class="built_in">make_pair</span>(x,v));</span><br><span class="line">            mp[i] = <span class="built_in">make_pair</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        dfs1(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;v);</span><br><span class="line">                <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; u = mp[y];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> o;</span><br><span class="line">                <span class="keyword">if</span>(dep[u.first] &gt; dep[u.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    o = u.first;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> o = u.second;</span><br><span class="line"></span><br><span class="line">                modify(<span class="number">1</span>,id[o],<span class="number">1</span>,n,v);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">-2e9</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(top[x] == top[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dep[x] &lt; dep[y])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans = max(ans,ask(<span class="number">1</span>,id[x]+<span class="number">1</span>,id[y],<span class="number">1</span>,n));</span><br><span class="line">                            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(x != y)</span><br><span class="line">                                ans = max(ans,ask(<span class="number">1</span>,id[y]+<span class="number">1</span>,id[x],<span class="number">1</span>,n));</span><br><span class="line">                            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//比较的是top[x] top[y]的深度</span></span><br><span class="line">                    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans = max(ans,ask(<span class="number">1</span>,id[top[y]],id[y],<span class="number">1</span>,n));</span><br><span class="line">                        y = fa[top[y]];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        ans = max(ans,ask(<span class="number">1</span>,id[top[x]],id[x],<span class="number">1</span>,n));</span><br><span class="line">                        x = fa[top[x]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(top[x] == top[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dep[x] &lt; dep[y])</span><br><span class="line">                        &#123;</span><br><span class="line">                            neg(<span class="number">1</span>,id[x]+<span class="number">1</span>,id[y],<span class="number">1</span>,n);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(dep[y] &lt; dep[x])</span><br><span class="line">                        &#123;</span><br><span class="line">                            neg(<span class="number">1</span>,id[y]+<span class="number">1</span>,id[x],<span class="number">1</span>,n);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        neg(<span class="number">1</span>,id[top[y]],id[y],<span class="number">1</span>,n);</span><br><span class="line">                        y = fa[top[y]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        neg(<span class="number">1</span>,id[top[x]],id[x],<span class="number">1</span>,n);</span><br><span class="line">                        x = fa[top[x]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1 2 0</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">1 4 3</span></span><br><span class="line"><span class="comment">2 5 4</span></span><br><span class="line"><span class="comment">2 6 5</span></span><br><span class="line"><span class="comment">3 7 3</span></span><br><span class="line"><span class="comment">7 8 3</span></span><br><span class="line"><span class="comment">2 9 0</span></span><br><span class="line"><span class="comment">4 10 2</span></span><br><span class="line"><span class="comment">N 4 8</span></span><br><span class="line"><span class="comment">C 2 -501</span></span><br><span class="line"><span class="comment">Q 9 4</span></span><br><span class="line"><span class="comment">Q 8 2</span></span><br><span class="line"><span class="comment">Q 1 6</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/06/20/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/20/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/" class="post-title-link" itemprop="url">协同过滤</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-20 20:58:51" itemprop="dateCreated datePublished" datetime="2021-06-20T20:58:51+08:00">2021-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 13:55:09" itemprop="dateModified" datetime="2021-06-21T13:55:09+08:00">2021-06-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/20/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/20/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="基于用户的协同过滤算法（UserCF"><a href="#基于用户的协同过滤算法（UserCF" class="headerlink" title="基于用户的协同过滤算法（UserCF)"></a>基于用户的协同过滤算法（UserCF)</h3><p>算法核心：当一个用户A需要个性化推荐时，先找和A相似兴趣的用户，把那些用户喜欢的推荐给用户A</p>
<p>a)找到和目标用户兴趣相似的用户集合</p>
<p>b)找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户</p>
<p>给定用户$u$,$v$,记$N(u)$为用户$u$给予正反馈的物品集合。</p>
<p>Jaccard公式</p>
<ul>
<li>$w<em>{uv} = \frac{\Sigma</em>{i\in N(u) \cap N(v)} \frac{1}{log(1+|N(i)|)}}{\sqrt(|N(u)||N(v)|)}$</li>
</ul>
<p>余弦公式</p>
<ul>
<li>$w_{uv} = \frac{|N(u) \cap N(v)|}{\sqrt|N(u)||N(v)|}$</li>
</ul>
<p>复杂度$O(n^2)$</p>
<p>计算$u$对物品$i$的感兴趣程度</p>
<p>$p(u,i) = \Sigma<em>{v \in S(u,K)\cap N(i)}w</em>{uv}r_{vi}$</p>
<p>其中$S(u,K)$包含和用户$u$兴趣最接近的$K$个用户，$N(i)$是对物品$i$有过行为的用户集合，$W<em>{uv}$是用户$u$与$v$的相似程度，$r</em>{vi}$是用户$v$对物品$i$的兴趣程度。</p>
<h3 id="基于物品的协同过滤算法（ItemCF"><a href="#基于物品的协同过滤算法（ItemCF" class="headerlink" title="基于物品的协同过滤算法（ItemCF)"></a>基于物品的协同过滤算法（ItemCF)</h3><p>算法思想：给用户推荐那些和他们之前喜欢的物品相似的物品</p>
<p>计算物品之间的相似度</p>
<p>$w_{ij} = \frac{|N(i)\cap N(j)|}{\sqrt|N(i)|| N(j)|} $</p>
<p>根据物品相似度和用户的历史行为给用户生成推荐列表</p>
<p>计算用户$u$对一个物品$j$的兴趣</p>
<p>$p<em>{uj} = \Sigma</em>{i\in N(u) \cap S(i,K)} W<em>{ji}r</em>{ui}$</p>
<p>$S(i,K)$表示和$i$最相似的$K$个物品集合。</p>
<p>$r_{ui}$表示用户$u$对物品$i$的感兴趣程度</p>
<p>优化：</p>
<p>1）用户活跃度对物品相似度的影响</p>
<p>$w<em>{ij} = \frac{\Sigma</em>{u \in N(i)\cap N(j)}\frac{1}{log(1+|N(u)|)}}{\sqrt(|N(i)||N(j)|)}$</p>
<p>2)物品相似度归一化</p>
<p>$w<em>{ij}’ = \frac{w</em>{ij}}{max<em>{j}w</em>{ij}}$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liulx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

      
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>












    <div class="pjax">
  

  

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"9hqrMBm5CSF4MzBqIOmG2yjR-gzGzoHsz","appKey":"cY7tkRBoQeYdaspntsGJazu2","placeholder":"Just go go","avatar":"mm","meta":["nick","mail"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"serverURLs":null,"enableQQ":true,"requiredFields":["nick"]}
    ));
  }, window.Valine);
});
</script>

    </div>
  <!-- 引用依赖 -->
          <link rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
          <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
          <script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script>

          <!-- 我使用的APlayer本体 -->
          <div class="aplayer"
            data-id="4866586492"
            data-server="netease"
            data-type="playlist"
            data-fixed="true"
            data-autoplay="true"
            data-order="random"
            data-volume="0.55"
            data-theme="#cc543a"
            data-preload="auto" >
            </div>
          <!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面-->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
<script type="text/javascript" src="/js/fire.js"></script>

</html>
