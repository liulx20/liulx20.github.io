<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="网络">
<meta property="og:url" content="https://github.com/liulx20/2021/05/24/%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="liulx">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/2021/05/24/%E7%BD%91%E7%BB%9C/flowers-6206279.jpg">
<meta property="og:image" content="https://github.com/2021/05/24/%E7%BD%91%E7%BB%9C/img1.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210529165523606.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210531135224845.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210531135257112.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210531141833815.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210601153141589.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210601154304706.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210601160148874.png">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20210601182357723.png">
<meta property="article:published_time" content="2021-05-24T06:05:43.000Z">
<meta property="article:modified_time" content="2021-06-06T10:47:50.642Z">
<meta property="article:author" content="liulx">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/2021/05/24/%E7%BD%91%E7%BB%9C/flowers-6206279.jpg">


<link rel="canonical" href="https://github.com/liulx20/2021/05/24/%E7%BD%91%E7%BB%9C/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>网络 | liulx</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">liulx</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">雪沫乳花浮午盏,蓼茸蒿笋试春盘。人间有味是清欢。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>留言板</a>

  </li>
        <li class="menu-item menu-item-dongtai">

    <a href="/dongtai/" rel="section"><i class="fa fa-th fa-fw"></i>动态</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">网络应用的体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E7%BC%96%E5%9D%80"><span class="nav-number">1.2.</span> <span class="nav-text">对进程进行编址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1-%E9%9C%80%E8%A6%81%E7%A9%BF%E8%BF%87%E5%B1%82%E9%97%B4%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.</span> <span class="nav-text">传输层提供服务-需要穿过层间的信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">如何使用传输层提供的服务实现应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.1.</span> <span class="nav-text">应用层协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E4%B8%8EHTTP"><span class="nav-number">1.5.</span> <span class="nav-text">Web与HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">1.5.1.</span> <span class="nav-text">HTTP请求报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%EF%BC%9Acookies"><span class="nav-number">1.5.2.</span> <span class="nav-text">用户-服务器状态：cookies</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Web%E7%BC%93%E5%AD%98%EF%BC%88%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">Web缓存（代理服务器）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FTP-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.6.</span> <span class="nav-text">FTP(文件传输协议)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EMail"><span class="nav-number">1.7.</span> <span class="nav-text">EMail</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MIME%E5%A4%9A%E5%AA%92%E4%BD%93%E9%82%AE%E4%BB%B6%E6%89%A9%E5%B1%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">MIME多媒体邮件扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pop3%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.7.2.</span> <span class="nav-text">Pop3协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">1.8.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="nav-number">1.8.1.</span> <span class="nav-text">主要思路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84"><span class="nav-number">1.8.2.</span> <span class="nav-text">DNS主要目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84"><span class="nav-number">1.8.3.</span> <span class="nav-text">DNS域名结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.4.</span> <span class="nav-text">解析问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DNS%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.8.5.</span> <span class="nav-text">DNS工作过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.6.</span> <span class="nav-text">提高性能 缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E9%97%AE%E9%A2%98-%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%9F%9F"><span class="nav-number">1.8.7.</span> <span class="nav-text">维护问题 新增一个域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%BB%E5%87%BBDNS"><span class="nav-number">1.8.8.</span> <span class="nav-text">攻击DNS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P2P"><span class="nav-number">1.9.</span> <span class="nav-text">P2P</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%9B%AE%E5%BD%95"><span class="nav-number">1.9.1.</span> <span class="nav-text">集中式目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%B4%AA%E6%B3%9B%EF%BC%9AGnutella"><span class="nav-number">1.9.2.</span> <span class="nav-text">查询洪泛：Gnutella</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8C%80%E7%A7%B0%E6%80%A7%EF%BC%9AKaZaA"><span class="nav-number">1.9.3.</span> <span class="nav-text">利用不匀称性：KaZaA</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN"><span class="nav-number">1.10.</span> <span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket%E7%BC%96%E7%A8%8B"><span class="nav-number">1.11.</span> <span class="nav-text">socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">1.11.1.</span> <span class="nav-text">TCP套接字编程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UDP-Socket"><span class="nav-number">1.11.2.</span> <span class="nav-text">UDP Socket</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">传输服务与协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82VS-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">传输层VS.网络层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Internet%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.3.</span> <span class="nav-text">Internet传输层协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">多路复用&#x2F;解复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.5.</span> <span class="nav-text">UDP：用户数据报协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%88rdt-%E5%8E%9F%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">可靠数据传输（rdt)原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-0-%E5%9C%A8%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%E4%B8%8A%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">2.6.1.</span> <span class="nav-text">1.0 在可靠信道上的可靠数据传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-0-%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E7%9A%84%E4%BF%A1%E9%81%93"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.0 具有比特差错的信道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-0-%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E5%92%8C%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%BF%A1%E9%81%93"><span class="nav-number">2.6.3.</span> <span class="nav-text">3.0 具有比特差错和分组丢失的信道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.6.4.</span> <span class="nav-text">流水线协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.6.5.</span> <span class="nav-text">通用：滑动窗口协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP"><span class="nav-number">2.7.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">2.7.1.</span> <span class="nav-text">TCP:可靠数据传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">2.7.2.</span> <span class="nav-text">TCP 流量控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">2.7.3.</span> <span class="nav-text">TCP连接管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.7.4.</span> <span class="nav-text">TCP 关闭连接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.8.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.9.</span> <span class="nav-text">TCP 拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6"><span class="nav-number">2.9.1.</span> <span class="nav-text">联合控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-number">2.9.2.</span> <span class="nav-text">TCP慢启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AIMD"><span class="nav-number">2.9.3.</span> <span class="nav-text">AIMD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">2.9.4.</span> <span class="nav-text">TCP拥塞控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-number">2.9.5.</span> <span class="nav-text">TCP公平性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="nav-number">3.1.</span> <span class="nav-text">数据平面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD"><span class="nav-number">3.2.</span> <span class="nav-text">网络层功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据平面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="nav-number">3.2.2.</span> <span class="nav-text">控制平面</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%93%E6%9E%84%E6%A6%82%E5%86%B5"><span class="nav-number">3.3.</span> <span class="nav-text">路由器结构概况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.</span> <span class="nav-text">交换结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.4.</span> <span class="nav-text">IP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#IP%E7%BC%96%E5%9D%80"><span class="nav-number">3.4.0.1.</span> <span class="nav-text">IP编址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%90%E7%BD%91"><span class="nav-number">3.4.0.2.</span> <span class="nav-text">子网</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IP%E7%BC%96%E5%9D%80-CIDR"><span class="nav-number">3.4.0.3.</span> <span class="nav-text">IP编址 CIDR</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88"><span class="nav-number">3.4.0.4.</span> <span class="nav-text">路由聚合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#NAT"><span class="nav-number">3.4.0.5.</span> <span class="nav-text">NAT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Nat%E7%A9%BF%E8%B6%8A"><span class="nav-number">3.4.0.6.</span> <span class="nav-text">Nat穿越</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IPv6-%E5%8A%A8%E6%9C%BA"><span class="nav-number">3.4.0.7.</span> <span class="nav-text">IPv6 动机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2-1"><span class="nav-number">3.5.</span> <span class="nav-text">控制平面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.5.1.</span> <span class="nav-text">路由协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.5.2.</span> <span class="nav-text">自治系统内部的路由选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ISP%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">3.5.3.</span> <span class="nav-text">ISP之间的路由选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E8%81%94%E7%BD%91AS%E9%97%B4%E8%B7%AF%E7%94%B1%EF%BC%9ABGP"><span class="nav-number">3.5.4.</span> <span class="nav-text">互联网AS间路由：BGP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SDN%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="nav-number">3.5.5.</span> <span class="nav-text">SDN控制平面</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.1.</span> <span class="nav-text">链路层服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B"><span class="nav-number">4.2.</span> <span class="nav-text">错误检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="nav-number">4.2.1.</span> <span class="nav-text">奇偶校验</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E9%AA%8C%E5%92%8C%EF%BC%9ACRC-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C"><span class="nav-number">4.2.2.</span> <span class="nav-text">检验和：CRC(循环冗余校验)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%82%B9%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.3.</span> <span class="nav-text">多点访问协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LANs"><span class="nav-number">4.4.</span> <span class="nav-text">LANs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MAC%E5%9C%B0%E5%9D%80%E4%B8%8EARP"><span class="nav-number">4.4.1.</span> <span class="nav-text">MAC地址与ARP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%92%8Cmac%E5%9C%B0%E5%9D%80%E5%88%86%E7%A6%BB"><span class="nav-number">4.4.2.</span> <span class="nav-text">网络地址和mac地址分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%EF%BC%9A%E6%97%A0%E8%BF%9E%E6%8E%A5%E3%80%81%E4%B8%8D%E5%8F%AF%E9%9D%A0%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.4.3.</span> <span class="nav-text">以太网：无连接、不可靠服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hubs"><span class="nav-number">4.4.4.</span> <span class="nav-text">Hubs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">4.4.5.</span> <span class="nav-text">交换机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="nav-number">5.</span> <span class="nav-text">网络安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E8%AF%AD%E8%A8%80"><span class="nav-number">5.1.</span> <span class="nav-text">加密语言</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liulx"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">liulx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liulx20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liulx20"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liulex@buaa.edu.cn" title="E-Mail → mailto:liulex@buaa.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/05/24/%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网络
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 14:05:43" itemprop="dateCreated datePublished" datetime="2021-05-24T14:05:43+08:00">2021-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 18:47:50" itemprop="dateModified" datetime="2021-06-06T18:47:50+08:00">2021-06-06</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="far fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/24/%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/24/%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <img src="/2021/05/24/%E7%BD%91%E7%BB%9C/flowers-6206279.jpg" class="">
<a id="more"></a>
<ul>
<li><p>节点</p>
<p>主机或运行在其上面的应用程序</p>
<p>路由器（网络层）交换机（链路层）等网络交换设备</p>
</li>
<li><p>边：(通讯链路)</p>
<p>接入网链路</p>
<p>主干链路</p>
</li>
<li><p>协议</p>
<p>对等层实体在通信过程中应遵守的规则集合。</p>
<p>协议定义了在两个或多个通信实体之间交换的报文<strong>格式</strong>和<strong>次序</strong>，以及在报文传输和/或接收或其他事件方面所采取的<strong>动作</strong>。</p>
</li>
<li><p>互联网</p>
</li>
</ul>
<p>​       分布式应用，以及为分布式应用提供通信服务的基础设施。</p>
<ul>
<li><p>网络结构</p>
<ul>
<li><p>网络边缘</p>
<p>主机、应用程序</p>
</li>
<li><p>网络核心</p>
<p>互联着的路由器、网络的网络</p>
</li>
<li><p>接入网、物理媒体</p>
<p>有线或者无线通信链路</p>
</li>
</ul>
</li>
<li><p>网络边缘</p>
<ul>
<li>客户端、服务器模式</li>
</ul>
<p>客户端向服务器请求、接收服务</p>
<p>问题：可扩展性差，随着请求载荷增加，性能变差。</p>
<ul>
<li>对等（peer-peer）模式</li>
</ul>
<p>面向连接的通信方式（仅端系统连接）</p>
<p>有连接</p>
<p><strong>TCP</strong></p>
<p>可靠、保序</p>
<p>流量控制</p>
<p>拥塞控制</p>
<p><strong>UDP</strong></p>
<p>无连接、不可靠、无流量、拥塞控制</p>
</li>
<li><p>网络核心</p>
<p>路由器的网状网络</p>
<p>数据怎么通过网络进行传输？</p>
<ul>
<li>电路交换</li>
</ul>
<p>端到端的资源被分配给从源端到目标端的呼叫</p>
<p>独享资源（每个呼叫一旦建立起来就能保证性能）</p>
<p>如果呼叫没有数据发送，被分配的资源会被浪费</p>
<p>通常被传统电话网络采用</p>
<p>网络资源（如带宽）被分成片</p>
<p>为呼叫分配片</p>
<p>如果某个呼叫没有数据，则其资源片处于空闲状态</p>
<p>将带宽分成片</p>
<p>频分、时分、波分</p>
<p>连接建立时间长</p>
<p>计算机通信有突发性，如果使用线路交换则浪费的片较多</p>
<p>可靠性不高</p>
<ul>
<li>分组交换</li>
</ul>
<p>以分组为单位存储转发方式</p>
<p>被传输到下一个链路之前，整个分组必须到达路由器，<strong>存储转发</strong></p>
<p>在一个速率为R bps的链路，一个长度为L bits的分组的存储转发延时：L/R s.</p>
<p>排队与延迟</p>
<p><strong>如果到达速率&gt;链路传输速率</strong>：</p>
<p>分组将会排队，等待传输</p>
<p>如果路由器缓存用完了，分组将会被抛弃</p>
<ul>
<li><p>网络核心的关键功能</p>
<p>路由：决定分组采用的源到目标的路径</p>
<p>转发：将分组从路由器的输入链路转移到输出链路。</p>
<p>统计多路复用</p>
</li>
</ul>
<p>分组交换允许更多用户使用网络。</p>
<p>适合于对突发式数据传输</p>
<ul>
<li>资源共享</li>
<li>简单、不必建立呼叫</li>
</ul>
<p>过度使用会造成网络拥塞</p>
<p>分组交换网络按照有无网络层连接：</p>
<ul>
<li><p>数据报网络(不建立连接)</p>
<p>分组的目标地址决定下一跳</p>
<p>在不同阶段，路由可以改变</p>
</li>
<li><p>虚电路网络（有连接）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>接入网与物理媒体</p>
<p>住宅接入：modem</p>
<p>企业接入网络</p>
<p>无线接入网络</p>
<p>(无线LANs、广域无线接入)</p>
<p>物理媒体</p>
<p>物理链路：在每个传输-接收对，跨越一种物理媒体</p>
<ul>
<li><p>导引型媒体</p>
<p>信号沿着固体媒介被导引，（同轴电缆、光纤、双绞线、光缆）</p>
</li>
<li><p>非导引型媒体</p>
<p>信号自由传播，如无线电</p>
</li>
</ul>
</li>
<li><p>Internet结构和ISP</p>
<p>端系统通过接入ISPs（Internet Service Providers）接入到互联网</p>
<p>接入ISPs相应的必须是互联的</p>
</li>
<li><p>在路由器缓存区得分组队列</p>
<p>分组到达链路得速率超过了链路输出能力</p>
<p>分组等待排到队头，被输出</p>
<ul>
<li><p>节点处理延时</p>
<p>检查bit级差错</p>
<p>检查分组首部和决定将分组导向何处</p>
</li>
<li><p>排队延时</p>
<p>在输出链路上等待输出的时间</p>
<p>依赖于路由器的拥塞程度</p>
</li>
<li><p>传输延时</p>
<p>R = 链路带宽（bps)</p>
<p>L = 分组长度（bits)</p>
<p>将分组发送到链路上的时间L/R</p>
<p>存储转发延时</p>
</li>
<li><p>传播延时</p>
<p>d = 物理链路长度</p>
<p>s = 在媒体上的传播速度$(2*10^8m/s)$</p>
<p>传播延时 = d/s</p>
</li>
<li><p>流量强度</p>
<p>$I = La/R$</p>
<p>$R$=链路带宽（bps)</p>
<p>$L$=分组长度（bits)</p>
<p>$a$=分组到达队列的平均速率</p>
</li>
<li><p>分组丢失</p>
<p>链路队列缓冲区容量有限</p>
<p>当分组到达一个满的队列时，该分组会丢失</p>
<p>丢失的分组可能会被前一个节点或源端系统重传或根本不重传。</p>
</li>
<li><p>吞吐量</p>
<p>在源端和目标端之间传输的速率（数据量/单位时间）</p>
<p>瞬间吞吐量：在一个时间点的速率</p>
<p>平均吞吐量：在一个长时间内的平均值</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>协议层次及服务模型</p>
<p>将网络复杂功能分成功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务。</p>
<p>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务。</p>
<p>在实现本层协议的时候，直接利用了下层所提供的服务。</p>
<p>本层的服务：借助下层服务实现的本层协议实体之间的交互带来的新功能（上层可以利用的）+更下层所提供的服务。</p>
<ul>
<li><p>服务（Service):底层实体向上层实体提供它们之间的通信能力。服务用户（service user) 服务提供者（service provider)</p>
</li>
<li><p>原语（primitive):上层使用下层服务的形式，高层使用低层提供的服务，以及底层向高层提供服务都是通过服务访问源于来进行交互的—形式</p>
</li>
<li><p>服务访问点SAP(Services Access Point):上层使用下层提供的服务通过层间的接口—地点：</p>
<p>地址（address)：下层的一个实体支撑着上层的多个实体，SAP有标志不同上层实体的作用。 </p>
<p>传输层的SAP、端口</p>
</li>
<li><p>面向连接的服务、无连接的服务。</p>
</li>
<li><p><strong>服务与协议的区别</strong></p>
<p>服务(service)：底层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</p>
<p>协议（protocol）：对等层(peer entity)实体之间在互相通信过程中需要遵循的规则的集合，水平</p>
</li>
<li><p>服务与协议的联系</p>
<p>本层的协议实现要靠下层提供的服务来实现。</p>
<p>本层实体通过协议为上层提供更高级的服务。</p>
</li>
<li><p>数据单元（SDU,ICI,PDU)</p>
</li>
<li><p>Internet协议栈</p>
<p><strong>应用层</strong>：网络应用（应用报文与应用报文交互</p>
<p>为人类用户或其他应用进程提供网络应用服务。</p>
<p>FTP,SMTP,HTTP,DNS</p>
<p><strong>传输层</strong>：主机之间的数据传输(进程到进程传输、不可靠变为可靠</p>
<p>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠通信变成可靠地通信。</p>
<p>TCP,UDP</p>
<p><strong>网络层</strong>：为数据报从源到目的选择路由（传输以分组为单位端到端的数据 E2E</p>
<p>主机主机之间的通信、端到端通信，不可靠</p>
<p>IP、路由协议</p>
<p><strong>链路层</strong>：相邻网络节点之间的数据传输（在相邻两点之间传输以帧为单位的数据 P2P</p>
<p>2个相邻2点的通信，点到点的通信，可靠或不可靠。</p>
<p>点对对协议PPP,802.11(Wifi),Ethernet</p>
<p><strong>物理层</strong>：在线路上传送bit,（把输入数据转成物理信号</p>
</li>
<li><p>ISO/OSI参考模型：</p>
<p>表示层：允许应用解释传输的数据 e.g.加密、压缩、机器相关的表示转换</p>
<p>会话层：数据交换的同步、检查点、恢复(建立会话、维持会话)</p>
</li>
<li><p>各层次的协议数据单元</p>
<p>应用层：报文（message)</p>
<p>传输层：报文段（segment); TCP段，UDP数据报</p>
<p>网络层：分组packet(如果无连接方式：数据报（datagram))</p>
<p>数据链路层：帧（frame）</p>
<p>物理层：位（bit)</p>
</li>
</ul>
</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h4><p><strong>可能的应用架构</strong></p>
<p>  客户-服务器模式（C/S:Client/Serve)</p>
<ul>
<li><p>服务器</p>
<p>一直运行</p>
<p>固定的IP地址和周知的端口号（约定）</p>
<p>扩展性：服务器场（数据中心进行扩展，扩展性差，可靠性差）</p>
</li>
<li><p>客户端</p>
<p>主动与服务器通信</p>
<p>与互联网有间歇性的连接</p>
<p>可能是动态IP地址</p>
<p>不直接与其他客户端通信</p>
<p>对等模式（P2P:Peer to Peer)</p>
</li>
<li><p>几乎没有一直运行的服务器</p>
</li>
<li>任意端系统之间可以通信</li>
<li>每一个节点既是客户端又是服务器</li>
<li><p>参与的主机间歇性连接且可以改变IP地址</p>
<p>(难以管理)</p>
<p>混合体：客户-服务器和对等体系结构</p>
</li>
</ul>
<p><strong>进程通信</strong></p>
<p>  客户端进程：发起通信的进程</p>
<p>  服务器进程：等待连接的进程</p>
<p>不同主机，通过交换报文（Message)来通信</p>
<p>使用OS提供的通信服务</p>
<p>按照应用协议交换报文（借助传输层提供的服务）</p>
<p>（P2P架构之间也有客户端服务器进程之分）</p>
<p>问题：</p>
<p>进程表示与寻址问题（服务用户）</p>
<p>传输层-应用层提供服务是如何（服务）</p>
<ul>
<li>位置：层间界面的SAP(TCP/IP: socket)</li>
<li>形式：应用程序接口API(TCP/IP: socket API)</li>
</ul>
<p>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）</p>
<p>定义应用层协议：报文格式、解释、时序等</p>
<p>编制程序，使用OS提供的API,调用网络基础设施提供的通信服务传报文，实现应用时序。</p>
<h4 id="对进程进行编址"><a href="#对进程进行编址" class="headerlink" title="对进程进行编址"></a>对进程进行编址</h4><p>进程为了接受报文，必须有一个唯一标识。</p>
<p>即:SAP</p>
<ul>
<li><p>主机：唯一的32位IP地址</p>
</li>
<li><p>所采用的传输层协议TCP or UDP</p>
</li>
<li><p>端口号（Port Number)$(2^{16})$</p>
<p>web应用HTTP tcp 80，ftp tcp 2, Mail: tcp 25</p>
</li>
<li><p>一个进程：用IP+port标识，端节点</p>
</li>
</ul>
<h4 id="传输层提供服务-需要穿过层间的信息"><a href="#传输层提供服务-需要穿过层间的信息" class="headerlink" title="传输层提供服务-需要穿过层间的信息"></a>传输层提供服务-需要穿过层间的信息</h4><ul>
<li>要传输的报文（SDU)</li>
<li>谁传的：自己应用进程标识</li>
<li>传给谁：对方应用进程标识（IP+TCP(UDP)端口号</li>
</ul>
<p>传输层实体（tcp或udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装</p>
<ul>
<li>源端口号、目标端口号、数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报，源IP,目标IP.</li>
</ul>
<p>如果Socket API每次传输报文都携带如此多的信息，太繁琐易错，不便于管理。</p>
<p>用个代号标示通信的双方或者单方：socket</p>
<p>就像OS打开文件返回的句柄</p>
<ul>
<li><p>TCP socket:</p>
<ul>
<li>TCP服务。两个进程之间的通信要先建立连接</li>
<li>可以用一个整数表示两个应用实体之间的通信关系，本地标识。</li>
<li>穿过层间接口的信息量最小</li>
<li>TCP socket :源IP，源端口，目标IP,目标端口</li>
</ul>
<p>对于面向连接服务TCP的应用而言，套接字是4元组的一个具有本地意义的标示。</p>
<ul>
<li>4元组（:源IP，源port，目标IP,目标port</li>
<li>唯一指定了一个会话（2个进程之间的会话关系</li>
<li>应用这个标识，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都指定这四元组</li>
<li>简单、便于管理。</li>
</ul>
</li>
<li><p>UDP socket</p>
<ul>
<li>UDP服务，两个进程之间通信无需建立连接</li>
<li>每个报文都是独立传输</li>
<li>前后报文可能给不同的分布式进程</li>
<li>只能用一个整数标识本应用实体的标识</li>
<li>穿过层间接口的信息大小最小</li>
<li>UPD socket:本IP,本端口</li>
<li>传输报文时，必须提供对方IP、port</li>
</ul>
<p>对于UDP,套接字是2元组的一个具有本地意义的标识。</p>
<p>2元组：IP、port</p>
<p>UDP套接字制定了应用所在的一个端节点（end point)</p>
</li>
</ul>
<p><strong>套接字</strong>（socket)</p>
<p>进程向套接字发送报文或从套接字接受报文</p>
<p>套接字&lt;-&gt;门户</p>
<p>发送进程将报文推出门户，发送进程依赖于传输层设施在另一侧的门将报文交付给接受进程</p>
<p>接收进程从另外一端的门户收到报文（依赖于传输层设施）</p>
<h4 id="如何使用传输层提供的服务实现应用"><a href="#如何使用传输层提供的服务实现应用" class="headerlink" title="如何使用传输层提供的服务实现应用"></a>如何使用传输层提供的服务实现应用</h4><p>定义应用层协议：报文格式、解释、时序等</p>
<p>编制程序，使用API调用网络基础设施提供的通信服务传报文，解析报文、实现应用时序等。</p>
<h5 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h5><p>定义了：运行在不同端系统上的应用<strong>进程</strong>如何相互交换报文</p>
<p>交换报文类型：请求与应答报文</p>
<p>各种报文类型语法：报文中的各个字段及其描述</p>
<p>字段的语义：即字段取值的含义</p>
<p>进程何时、如何发送报文及对报文进行响应的规则</p>
<ul>
<li><p>应用协议仅仅是应用的一个组成部分。</p>
<p>Web应用：HTTP协议，web客户端、web服务器、HTML</p>
</li>
<li><p>公开协议</p>
<p>由RFC文档定义</p>
<p>允许互操作</p>
<p>如HTTP,SMTP</p>
</li>
<li><p>专用协议</p>
<p>协议不公开 Skype</p>
</li>
</ul>
<p>性能要求：</p>
<ul>
<li>数据丢失率</li>
<li>延迟</li>
<li>吞吐</li>
<li>安全性（机密性、完整性、可认证性</li>
</ul>
<p>Internet传输层提供的服务</p>
<p><strong>TCP服务</strong></p>
<ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接受方</li>
<li>拥塞控制：当网络出现拥塞，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全</li>
<li>面向连接：要求在客户端进程与服务器进程之间建立连接</li>
</ul>
<p><strong>UDP服务</strong></p>
<ul>
<li>不可靠数据传输</li>
<li>不提供服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接</li>
</ul>
<p>UDP存在的必要性</p>
<ul>
<li><p>能够区分不同的进程，而IP服务不能</p>
<ul>
<li>在IP提供的主机到主机端到端功能基础上，区分了主机的应用进程。</li>
</ul>
</li>
<li><p>无需建立连接、省去了建立连接时间、适合事务性应用</p>
</li>
<li><p>不做可靠性工作，如检错重发，适合于实时性要求高正确性要求低的应用</p>
</li>
<li><p>没用拥塞流量控制、应用能够按照设定的速度发送数据</p>
<ul>
<li>在TCP上的应用，应用发送数据的速度和主机向网络发送的实际速度不一样，因为由流量、拥塞控制。</li>
</ul>
</li>
</ul>
<p>安全TCP</p>
<p>TCP&amp;UDP</p>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输</li>
</ul>
<p>SSL</p>
<ul>
<li><p>在TCP上面实现，提供加密的TCP连接</p>
</li>
<li><p>私密性</p>
</li>
<li><p>数据完整性</p>
</li>
<li><p>端到端的鉴别</p>
</li>
<li><p>SSL在应用层，应用采用SSL库，SSL库采用TCP通信</p>
</li>
<li><p>应用通过API将明文给socket,SSL将其加密在互联网上传播</p>
</li>
</ul>
<h4 id="Web与HTTP"><a href="#Web与HTTP" class="headerlink" title="Web与HTTP"></a>Web与HTTP</h4><p>Web页：由一些对象组成</p>
<p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p>
<p>Web页含有一个基本的HTML文件、该基本HTML文件又包含若干对象的引用（链接）</p>
<p>通过URL对每个对象进行引用</p>
<ul>
<li>访问协议、用户名、口令字、端口等</li>
</ul>
<p>URL格式：</p>
<p>Prot://user:psw@www.someSchool.edu/someDept/pic.gif:port</p>
<p>协议名 用户名:口令 主机名[:port]                             路径名     端口</p>
<p>HTTP概况</p>
<p>HTTP:超文本传输协议</p>
<ul>
<li><p>Web的应用层协议</p>
</li>
<li><p>客户/服务器模式</p>
<ul>
<li>客户：请求、接收和显示Web对象的浏览器</li>
<li>服务器：对请求进行响应，发送对象的Web服务器</li>
</ul>
<p>HTTP request HTTP response</p>
</li>
<li><p>使用TCP</p>
<ul>
<li>客户发起一个与服务器的TCP链接（建立套接字）端口号为80</li>
<li>服务器接受客户的TCP链接</li>
<li>在浏览器（HTTP客户端）与Web服务器（HTTP服务器server)交换HTTP报文（应用层协议报文）</li>
<li>TCP连接关闭</li>
</ul>
</li>
<li><p>HTTP是无状态的</p>
<p>服务器不维护关于客户的任何信息</p>
<p>维护状态的协议很复杂，必须维护历史信息</p>
<p>如果服务器、客户端死机，他们的状态信息不一致</p>
<p>无状态的服务器能支持更多的客户端</p>
</li>
<li><p>HTTP链接</p>
<ul>
<li><p>非持久HTTP</p>
<p>最多只有一个对象在TCP连接上发送</p>
<p>下载多个对象需要多个TCP链接</p>
<p>HTTP/1.0使用非持久连接</p>
</li>
<li><p>持久HTTP</p>
<p>多个对象可以在一个TCP连接上传输</p>
<p>HTTP/1.1默认采用持久连接</p>
</li>
</ul>
</li>
<li><p>响应时间模型：</p>
<p>往返时间RTT(round-trip time):一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）</p>
<p><strong>响应时间</strong>：</p>
<p>一个RTT用来发起TCP连接</p>
<p>一个RTT用来HTTP请求并等待HTTP响应</p>
<p>文件传输时间：</p>
<p>2*RTT+传输时间</p>
</li>
<li><p>非持久HTTP缺点：</p>
<ul>
<li>每个对象要2个RTT</li>
<li>操作系统必须为每个TCP连接分配资源</li>
<li>但浏览器通常打开并行TCP连接、以获取引用对象</li>
</ul>
</li>
<li><p>持久HTTP</p>
<ul>
<li>服务器在发送响应后仍保持TCP链接</li>
<li>在相同客户端服务器之间的后续请求和响应报文通过相同的链接进行传送。</li>
<li>客户端在遇到一个引用对象的时候，可以尽快发送该对象的请求</li>
<li>非流水方式的持久HTTP:<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
</li>
<li>流水方式的持久HTTP<ul>
<li>HTTP/1.1默认模式</li>
<li>客户端遇到一个引用对象就立即发送一个请求</li>
<li>所有引用对象只花费一个RTT是可能的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><ul>
<li><p>两种类型的HTTP报文：请求、响应</p>
</li>
<li><p>HTTP请求报文</p>
<ul>
<li><p>ASCII</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1 /*请求行（GET、POST（上载）、HEAD（头）命令*/</span><br><span class="line">/*首部行*/</span><br><span class="line">Host: www.someschool.edu 主机名</span><br><span class="line">User-agent:Mozilla/4.0 用户代理程序、浏览器版本</span><br><span class="line">Connection:close 关连接</span><br><span class="line">Accept-language:fr</span><br><span class="line"></span><br><span class="line">（一个额外的换行回车符，标识报文结束</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>提交表单输入</strong></p>
<ul>
<li><p>Post方式</p>
<ul>
<li>网页通常包括表单输入</li>
<li>包含在实体主体（entity body)中输入被提交到服务器</li>
</ul>
</li>
<li><p>URL方式</p>
<ul>
<li><p>方法：GET</p>
</li>
<li><p>输入通过请求行的URL字段上载</p>
<p>www.somesite.com/animalsearch?monkeys&amp;banana</p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3</a></p>
<p>参数：wd.cl</p>
<p>参数值XX+YY+zzz, 3</p>
</li>
</ul>
</li>
</ul>
<p>HTTP/1.1</p>
<ul>
<li>PUT 将实体主体中的文件载到URL字段规定的路径</li>
<li>DELETE删除URL字段规定的文件</li>
</ul>
<img src="/2021/05/24/%E7%BD%91%E7%BB%9C/img1.png" class="">
<p>HTTP响应状态码：</p>
<p>200 OK</p>
<p>301 Moved Permanently</p>
<p>400 Bad Request</p>
<p>404 Not Found</p>
<p>505 HTTP Version Not Supported</p>
<h5 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a>用户-服务器状态：cookies</h5><p>4个组成部分：</p>
<p>1）在HTTP响应报文中有一个cookie的首部行</p>
<p>2）在HTTP请求报文中含有一个cookie首部行</p>
<p>3）在用户端系统中保留有一个cookie文件，由用户的浏览器管理</p>
<p>4）在Web站点有一个后端数据库</p>
<ul>
<li>Cookies能<ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态（Web e-mail)</li>
</ul>
</li>
<li>如何维持状态<ul>
<li>协议端节点：在多个事务上，发送端和接收端维持状态</li>
<li>cookies: http报文携带状态信息</li>
</ul>
</li>
</ul>
<h5 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h5><p>目标：不访问原始服务器，就满足客户请求</p>
<p>用户设置浏览器：通过缓存访问Web</p>
<p>浏览器将所有HTTP请求发给缓存</p>
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>不在缓存中，缓存请求原始服务器</li>
</ul>
<p>缓存既是客户端又是服务器</p>
<p>通常缓存是由ISP安装</p>
<p>为什么要使用缓存？</p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li>
<li>互联网大量采用了缓存，可以是较弱的ICP也能有效提供内容。</li>
</ul>
<p>条件GET方法</p>
<ul>
<li><p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</p>
</li>
<li><p>缓存器：在HTTP请求中指定缓存拷贝的日期</p>
<p>If-modified-since <date></p>
</li>
<li><p>服务器：如果缓存拷贝陈旧，则响应报文没包含对象：</p>
<p>HTTP/1.0 304 Not Modified</p>
</li>
</ul>
<h4 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h4><ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户/服务器模式<ul>
<li>客户端：发起传输的一端</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>ftp:RFC 959</li>
<li>ftp服务器：端口号21</li>
</ul>
<p>FTP客户端与FTP服务器通过端口21联系、并使用TCP作为传输协议</p>
<p>客户端通过控制连接获得身份确认</p>
<p>客户端通过控制连接发送命令浏览远程目录</p>
<p>收到一个文件传输命令，服务器打开一个客户端的数据连接（客户端20号端口）</p>
<p>一个文件传输完成，服务器关闭连接</p>
<p>服务器打开第二个TCP数据连接用来传输另一个文件</p>
<p>控制连接：带外（out of band) 传送 （带内传数据</p>
<p>FTP服务器维护用户的状态信息、当前路径、用户账户与控制连接对应</p>
<ul>
<li><p>与HTTP区别：</p>
<p>有状态，控制、数据在两个TCP连接上进行</p>
</li>
</ul>
<h4 id="EMail"><a href="#EMail" class="headerlink" title="EMail"></a>EMail</h4><p>三个主要组成部分：</p>
<ul>
<li><p>用户代理</p>
<p>邮件软件（Outlook,Foxmail</p>
</li>
<li><p>邮件服务器</p>
<p><strong>邮箱</strong>中管理和维护发送给用户的邮件</p>
<p>输出<strong>报文队列</strong>保持待发送邮件报文</p>
<p>邮件服务器之间的<strong>SMTP</strong>协议：发送email报文</p>
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接受端邮件服务器</li>
</ul>
</li>
<li><p>简单邮件传输协议SMTP(发送), 拉取：POP3,IMAP,HTTP</p>
</li>
</ul>
<p>使用TCP在客户端与服务器之间传输报文，端口号为25</p>
<p>直接传输：从发送方服务器到接收方服务器</p>
<p>传输的3个阶段</p>
<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
<p>命令/响应交互</p>
<ul>
<li>命令:ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
<p>报文必须为7位ASCII码。</p>
<ul>
<li>SMTP使用持久连接</li>
<li>SMTP要求报文（首部和主体）为7位ASCII编码</li>
<li>SMTP服务器使用CRLF,CRLF决定报文的尾部</li>
</ul>
<p><strong>HTTP比较</strong></p>
<ul>
<li>HTTP:拉（pull)</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令/响应交互、状态码</li>
<li>HTTP:每个对象封装在各自的响应报文中</li>
<li>SMTP:多个对象包含在一个报文中</li>
</ul>
<h5 id="MIME多媒体邮件扩展"><a href="#MIME多媒体邮件扩展" class="headerlink" title="MIME多媒体邮件扩展"></a>MIME多媒体邮件扩展</h5><p>在报文首部用额外的行申明MIME内容类型</p>
<p>base64：把不在ASCII码范围内的字符转位ASCII字符</p>
<h5 id="Pop3协议"><a href="#Pop3协议" class="headerlink" title="Pop3协议"></a>Pop3协议</h5><p>用户确认阶段</p>
<ul>
<li><p>客户端命令</p>
<p>user:声明用户名</p>
<p>pass:口令</p>
</li>
<li><p>服务器响应</p>
</li>
</ul>
<p>事务处理阶段（客户端</p>
<p>list:报文号列表</p>
<p>retr:根据报文号检索报文</p>
<p>dele:删除</p>
<p>quit</p>
<ul>
<li>Pop3本地管理文件夹，无状态</li>
<li>IMAP远程管理文件夹，保留用户状态</li>
</ul>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>域名到IP转换</p>
<p><strong>DNS的必要性</strong></p>
<ul>
<li>IP地址标识主机、路由器</li>
<li>IP地址不好记忆、不便于使用</li>
<li>倾向于字符串标识Internet上的设备</li>
<li>存在字符串-IP地址转换的必要性</li>
<li>人类用户提供要访问机器的字符串名称</li>
<li>由DNS负责转换为二进制网络地址</li>
</ul>
<p>问题：</p>
<ul>
<li>如何命名设备</li>
<li>如何完成名字到IP地址转换</li>
<li>如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ul>
<h5 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h5><ul>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址转换</li>
<li>运行在UDP之上端口号为53的应用服务</li>
<li>核心Internet功能、但以应用层协议实现</li>
</ul>
<h5 id="DNS主要目的"><a href="#DNS主要目的" class="headerlink" title="DNS主要目的"></a>DNS主要目的</h5><p>实现主机名-IP地址转换</p>
<p>其他目的：</p>
<p>主机别名到规范名字转换</p>
<p>邮件服务器别名到邮件服务器正规名字的转换</p>
<p>负载均衡</p>
<h5 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h5><ul>
<li><p>一个层面命名设备会有很多重名</p>
</li>
<li><p>NDS采用层次树状结构命名法</p>
</li>
<li><p>Internet根被划为几百个顶级域名</p>
<ul>
<li><p>通用</p>
<p>.com .edu .gov .int .mil .net .org .firm .hsop .wed .arts .rec</p>
</li>
<li><p>国家</p>
<p>.cn .us .nl .jp</p>
</li>
</ul>
</li>
<li><p>每个（子）域下面可划分为若干个子域</p>
</li>
<li><p>树叶是主机</p>
</li>
</ul>
<p>DNS:根名字服务器</p>
<ul>
<li><p>域名</p>
<p>从本域往上，直到树根</p>
<p>中间使用.间隔不同的级别</p>
<ul>
<li>域的域名：可以用来表示一个域</li>
<li>主机的域名：一个域上的一个主机</li>
</ul>
</li>
<li><p>域名的管理：</p>
<ul>
<li>一个域管理其下的子域</li>
<li>创建一个新的域，须征得它所属域的同意。</li>
</ul>
</li>
<li><p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
</li>
</ul>
<h5 id="解析问题"><a href="#解析问题" class="headerlink" title="解析问题"></a>解析问题</h5><ul>
<li><p>一个名字服务器的问题</p>
<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离集中式数据库</li>
</ul>
</li>
<li><p>区域（Zone)</p>
<ul>
<li>区域的划分由区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分。</li>
<li>名字服务器<ul>
<li>每个区域都有一个名字服务器，维护着它所管辖区域的权威信息</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
<li>权威DNS服务器：组织机构的DNS服务器，提供组织机构服务器（如Web和mail)可访问的主机与IP之间的映射。</li>
<li>组织机构可以选择实现自己维护或由某个服务器提供商来维护</li>
</ul>
</li>
<li><p>TLD服务器</p>
<ul>
<li>顶级域（TLD)服务器：负责顶级域名（如com,org,net,edu,gov)和所有国家级的顶级域名（如cn,uk,fr,ca,jp)</li>
</ul>
</li>
<li><p>区域名字服务器维护资源记录</p>
<ul>
<li>资源记录（resource records)<ul>
<li>作用：维护域名-IP地址（其他）的映射关系</li>
<li>位置：Name Server的分布式服务器中</li>
</ul>
</li>
<li>RR格式：（domain_name,ttl,type,class,Value)<ul>
<li>Domain_name 域名</li>
<li>Ttl: time to live:生存时间(权威记录：ttl时间很长，时间较短则为缓冲记录)</li>
<li>Class类别（internet 为IN)</li>
<li>Value值(IP地址)</li>
<li>Type类别</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS记录</p>
<p>DNS保存资源记录（RR)的分布式数据库</p>
<ul>
<li>Type = A<ul>
<li>Name为主机</li>
<li>Value为IP地址</li>
</ul>
</li>
<li>Type=NS<ul>
<li>Name为域名</li>
<li>Value为该域名的权威服务器域名</li>
</ul>
</li>
<li>Type = CNAME<ul>
<li>Name为规范名字的别名</li>
<li>value为规范名字</li>
</ul>
</li>
<li>Type = MX<ul>
<li>Value为name对应的邮件服务器名字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="DNS工作过程"><a href="#DNS工作过程" class="headerlink" title="DNS工作过程"></a>DNS工作过程</h5><ul>
<li>应用调用解析器（resolver)</li>
<li>解析器作为客户向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文（Name/ip)</li>
</ul>
<p>本地名字服务器（Local Name Server)</p>
<ul>
<li><p>并不严格属于层次结构</p>
</li>
<li><p>每个ISP都有一个本地DNS服务器</p>
</li>
<li><p>当一个主机发起一个DNS查询时，查询被送到本地DNS服务器</p>
<ul>
<li>起着代理的作用、将查询转发到层次结构中</li>
</ul>
</li>
<li><p>名字解析过程：</p>
<ul>
<li>目标名字在Local Name Server中<ul>
<li>case 1：查询的名字在该区域内部</li>
<li>case 2: 缓存（cashing)</li>
</ul>
</li>
</ul>
<p>当与本地名字服务器不能解析的名字时、联系根名字服务器，顺着根-TLD一直找到权威名字服务器</p>
<ul>
<li>递归查询<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器负担太重</li>
<li>解决：迭代查询</li>
</ul>
</li>
<li>迭代查询<ul>
<li>根（及各级域名）服务器返回的不是查询结果，而是下一个NS地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务器给出可以联系的服务器名字</li>
<li>我不知道这个名字，但可以向这个服务器请求</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS协议、报文</p>
<p>DNS协议：查询与响应报文报文格式相同</p>
<p>报文首部：</p>
<ul>
<li>标识符（ID)：16位</li>
<li>flags:</li>
</ul>
</li>
</ul>
<h5 id="提高性能-缓存"><a href="#提高性能-缓存" class="headerlink" title="提高性能 缓存"></a>提高性能 缓存</h5><ul>
<li>一旦名字服务器学到了一个映射，就将映射缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着<ul>
<li>使得根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>存在问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案TTL(默认2天)</li>
</ul>
<h5 id="维护问题-新增一个域"><a href="#维护问题-新增一个域" class="headerlink" title="维护问题 新增一个域"></a>维护问题 新增一个域</h5><ul>
<li>在上级名字服务器中增加两条记录，指向这个新增的子域域名和域名服务器地址</li>
<li>在新增子域名字服务器上运行名字服务器，负责本域的名字解析：名字-&gt;IP地址</li>
</ul>
<p>例子：在com域中建立一个 Netwirk Utopia</p>
<ul>
<li>到注册登记机构注册域名networkutopia.com<ul>
<li>需要向该机构提供权威DNS服务器（基本的、辅助的）名字和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录<ul>
<li>(networkutopia.com,dnsl.networkutopia.com,NS)</li>
<li>(dnsl.networkutopia.com,212.212.212.1, A)</li>
</ul>
</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有<ul>
<li>用于Web服务器的www.networkuptopia.com的类型为A的记录</li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
<h5 id="攻击DNS"><a href="#攻击DNS" class="headerlink" title="攻击DNS"></a>攻击DNS</h5><p>DDoS攻击</p>
<ul>
<li>对根服务器进行流量轰炸攻击：发送大量Ping<ul>
<li>没有成功</li>
<li>根目录服务器配置了流量过滤器，防火墙</li>
<li>Local DNS服务器缓存了TLD服务器的IP地址，因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击：发送大量查询<ul>
<li>可能更危险</li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<p>重定向攻击</p>
<ul>
<li>中间人攻击<ul>
<li>截获查询、伪造回答、从而攻击某个（DNS回答指定ip）站点</li>
</ul>
</li>
<li>DNS中毒<ul>
<li>发送伪造的应答给DNS服务器，希望他缓存这个虚假结果</li>
</ul>
</li>
<li>技术上较困难：分布式截获与伪造</li>
</ul>
<p>利用DNS基础设施进行DDoS</p>
<ul>
<li>伪造某个IP进行查询、攻击这个目标ip</li>
<li>查询放大，响应报文币查询报文大</li>
<li>效果有限</li>
</ul>
<h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p>纯P2P架构</p>
<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>peer节点间歇上网，每次IP地址都可能变化</li>
</ul>
<p>例子：</p>
<ul>
<li>文件分发</li>
<li>流媒体</li>
<li>VoIP</li>
</ul>
<p>文件分发时间：C/S模式</p>
<ul>
<li><p>服务器传输:都是由服务器发给peer，服务器必须顺序传输（上载）N个文件的拷贝</p>
<ul>
<li>发送一个copy $F/u_{s}$</li>
<li>发送N个copy $NF/u_{s}$</li>
</ul>
</li>
<li><p>客户端：每个客户端必须下载一个文件拷贝</p>
<ul>
<li>$d_{min}$ = 客户端最小的下载速率</li>
<li>下载带宽最小的客户端下载时间：$F/d_{min}$</li>
</ul>
</li>
<li><p>采用C/S方法将一个F大小的文件分发给N个客户端耗时</p>
<p>$D<em>{c/s}\geq max{NF/u</em>{s},F/d_{min}}$</p>
</li>
</ul>
<p>文件分发时间：P2P模式</p>
<ul>
<li>服务器传输：最少需要上载一份拷贝</li>
</ul>
<p>发送一个拷贝时间：$F/u_{s}$</p>
<ul>
<li>客户端：每个客户端必须下载一个拷贝</li>
</ul>
<p>最小下载带宽客户耗时：$F/d_{min}$</p>
<p>客户端：所有客户端总体下载量NF</p>
<ul>
<li>最大上载带宽$u<em>{s} + \Sigma u</em>{i}$</li>
<li>除了服务器可以上载，其他所有peer节点也可以上载</li>
</ul>
<p>采用P2P方法将一个F大小的文件分发给N个客户端耗时</p>
<p>$D<em>{p2p} \geq max{F/u</em>{s},F/d<em>{min},NF/(u</em>{s} + \Sigma u_{i}}$</p>
<p>分子随着N线性变化，每个节点需要下载，整体下载量随着N增大</p>
<ul>
<li><p>非结构化P2P</p>
<p>集中化目录</p>
<p>完全分布式</p>
<p>混合体</p>
</li>
<li><p>DHT(结构化)P2P</p>
</li>
</ul>
<ul>
<li><p>两大问题</p>
<ul>
<li>如何定位所需资源</li>
<li>如何处理对等方的加入与离开</li>
</ul>
</li>
<li><p>可能的方案</p>
<ul>
<li><p>集中</p>
</li>
<li><p>分散</p>
</li>
<li><p>半分散</p>
</li>
</ul>
</li>
</ul>
<h5 id="集中式目录"><a href="#集中式目录" class="headerlink" title="集中式目录"></a>集中式目录</h5><ul>
<li><p>当对等方连接时，它告知中心服务器：</p>
<ul>
<li>IP地址</li>
<li>内容</li>
</ul>
</li>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<h5 id="查询洪泛：Gnutella"><a href="#查询洪泛：Gnutella" class="headerlink" title="查询洪泛：Gnutella"></a>查询洪泛：Gnutella</h5><ul>
<li>全分布式<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多Gnutella客户端实现了Gnutella协议<ul>
<li>类似HTTP有许多的浏览器</li>
</ul>
</li>
<li>覆盖网络：图<ul>
<li>如果X与Y之间有一个TCP连接，则二者之间存在一条边</li>
<li>所有活动对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于10个</li>
</ul>
</li>
<li>Gnutella协议：<ul>
<li>在已有的TCP连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
</li>
<li><p>可扩展性：限制范围的洪泛查询</p>
</li>
<li><p>Gnutella:对等方加入</p>
<ul>
<li><p>对等方X必须首先发现某些已经在覆盖网络中的其他对等方，使用可用对等方列表。</p>
<p>自己维持一张对等方列表（经常开机的对等方IP)</p>
<p>联系维持列表的Gnutella站点</p>
</li>
<li><p>X接着试图与列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</p>
</li>
<li><p>X向Y发送一个Ping报文，Y转发该Ping报文</p>
</li>
<li><p>所有收到ping报文的对等方以pong报文响应</p>
<p>IP地址、共享文件数量、总字节数</p>
</li>
<li><p>X收到许多pong报文，然后它能建立其他TCP连接</p>
</li>
</ul>
</li>
</ul>
<h5 id="利用不匀称性：KaZaA"><a href="#利用不匀称性：KaZaA" class="headerlink" title="利用不匀称性：KaZaA"></a>利用不匀称性：KaZaA</h5><ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长。<ul>
<li>对等方与其组长之间有TCP连接</li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有孩子的内容</li>
<li>组长与其他组长联系<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
</li>
<li>查询<ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应：<ul>
<li>对每个匹配：元数据、散列标识码、IP地址</li>
</ul>
</li>
<li>如果组长将查询转发给其他组长、其他组长也以匹配进行响应。</li>
<li>客户端选择要下载的文件<ul>
<li>向拥有文件的对等体发送一个带散列标识码的HTTP请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>通过CDN，全网部署缓存节点，存储服务内容就近为用户提供服务，提高用户体验。</p>
<ul>
<li><p>enter deep :将CDN服务器深入到许多接入网</p>
<p>在Local ISP内部署，离用户近</p>
</li>
<li><p>bring home:部署在少数关键位置，如将服务器簇安装于POP附近</p>
</li>
<li><p>CDN：在CDN节点中存储内容的多个拷贝</p>
</li>
<li><p>用户从CDN中请求内容</p>
<ul>
<li>重定向到最近的拷贝，请求内容</li>
</ul>
</li>
<li><p>域名解析重定向</p>
</li>
</ul>
<h4 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h4><p>应用进程使用传输层提供的服务才能交换报文，实现应用协议，实现应用</p>
<p>TCP/IP：应用进程使用Socket API访问传输服务</p>
<p>地点：界面上的SAP，方式：Socket API</p>
<p><strong>Socket</strong> 分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
<p>TCP:可靠的、字节流服务</p>
<p>UDP:不可靠、数据UDP数据报服务</p>
<p>TCP套接字编程：</p>
<p>==套接字==:应用进程与端到端传输协议（TCP,UDP）之间的门户</p>
<p>TCP服务：从一个进程向另一个进程可靠地传输字节流</p>
<h5 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h5><ul>
<li>服务器首先运行，等待连接建立<ul>
<li>创建欢迎socket</li>
<li>和本地端口捆绑</li>
<li>在欢迎socket上阻塞式等待接受用户的连接(调用accept</li>
</ul>
</li>
<li>客户端主动和服务器建立连接<ul>
<li>指定服务器进程IP地址与端口号，与服务器进程连接（调用connect</li>
</ul>
</li>
<li>当客户端连接请求到来时<ul>
<li>服务器接受来自客户端的请求，解除阻塞式等待，返回一个新的socket(与欢迎socket不一样)，与客户端通信<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口区分不同的客户端</li>
</ul>
</li>
</ul>
</li>
<li>连接API调用有效时，客户端P与服务器建立了TCP连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IP地址与port捆绑关系数据结构（标识进程的端节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> sim_family; <span class="comment">// AF_INET地址族</span></span><br><span class="line">  u_short sin_port; <span class="comment">//port</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//IP address unsigned long</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//align对齐</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//完成域名到IP地址解析</span></span><br><span class="line"><span class="comment">//域名与IP地址的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;<span class="comment">//主机域名</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;<span class="comment">//主机别名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;</span><br><span class="line">    <span class="keyword">int</span> h_length;<span class="comment">//地址长度</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list;<span class="comment">//IP地址列表</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作为调用域名解析函数时的参数</span></span><br><span class="line"><span class="comment">//返回后，将IP地址拷贝到sockaddr_in的IP地址部分</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span><span class="comment">/*structure to hold an IP address of server*/</span></span><br><span class="line">    <span class="keyword">int</span> clientSocket;<span class="comment">/*socket descriptor*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span><span class="comment">/*pointer to a host table entry*/</span></span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    host = argv[<span class="number">1</span>];<span class="comment">/*服务器端域名*/</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);<span class="comment">/*服务器端端口号*/</span></span><br><span class="line">    clientSocket = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));<span class="comment">/*clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET;<span class="comment">/*set family to Internet*/</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">//解决大端小端问题</span></span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line">    <span class="comment">/*Convert host name to IP address*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr,ptrh-&gt;h_addr,ptrh-&gt;h_length);</span><br><span class="line">    <span class="comment">//将IP地址拷贝到sad.sin_addr</span></span><br><span class="line">    connect(clientSocket,(struct sockaddr *)&amp;sad,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    gets(Sentence);<span class="comment">/*get input stream from usr*/</span></span><br><span class="line">    n = write(clientSocket, Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>);</span><br><span class="line">    n = read(clientSocket, modifiedSentence,<span class="keyword">sizeof</span>(modifiedSentence));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER %s\n&quot;</span>,modifiedSentence);</span><br><span class="line">    <span class="comment">/*close socket*/</span></span><br><span class="line">    close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*server.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span><span class="comment">/*client*/</span></span><br><span class="line">    <span class="keyword">int</span> welcomeSocket, connectionSocket;<span class="comment">/*socket descriptor*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span><span class="comment">/*pointer to a host table entry*/</span></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    welcomeSocket = socket(PF_INTE,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY;<span class="comment">/*set the local IP address*/</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">/*set the port number*/</span></span><br><span class="line">    bind(welcomeSocket, (struct sockaddr*)&amp;sad,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="comment">/*specify the maximum number of clients that can be queued*/</span></span><br><span class="line">    listen(welcomeSocket,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        connectionSocket = accept(welcomeSocket,(struct sockaddr *)&amp;cad,&amp;alen);</span><br><span class="line">        n = read(connectionSocket,clientSentence,<span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line">        n = write(connectionSocket,capitalizedSentence,<span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>);</span><br><span class="line">        close(connectionSocket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h5><p>UDP：在客户端与服务器之间没有连接</p>
<p>没有握手</p>
<p>发送端在每一个报文中明确指定目标的IP地址与端口号</p>
<p>服务器必须从收到的分组中提取出发送端的IP地址和端口号</p>
<p>UDP：传送数据可能乱序，也可能丢失</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210529165523606.png" alt="image-20210529165523606"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socketaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientSocket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span></span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//创建客户端，没有连接</span></span><br><span class="line">    clientSocket = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*determine the server&#x27;s address*/</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr,ptrh-&gt;h_addr,ptrh-&gt;h_length);</span><br><span class="line">    gets(Sentence);</span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    n = sendto(clientSocket,Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>,</span><br><span class="line">              (struct sockaddr *)&amp;sad,&amp;addr_len);</span><br><span class="line">    </span><br><span class="line">    n = recvfrom(clientSocket,modifiedSentence,<span class="keyword">sizeof</span>(modifiedSentence),(struct sockaddr *)&amp;sad,&amp;addr_len);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER :%s\n&quot;</span>,modifiedSentence);</span><br><span class="line">    close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*server.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="keyword">int</span> serverSocket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    serverSocket = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    bind(serverSocket,(struct sockaddr *)&amp;sad,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n = recvfrom(serverSocket,clientSentence,<span class="keyword">sizeof</span>(clientSentence),<span class="number">0</span>,(struct sockaddr *)&amp;cad,&amp;addr_len);</span><br><span class="line">        </span><br><span class="line">        n = sendto(serverSocket,capitalizedSentence,<span class="built_in">strlen</span>(capitalizedSentence),(struct sockaddr *)&amp;cad,&amp;addr_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="传输服务与协议"><a href="#传输服务与协议" class="headerlink" title="传输服务与协议"></a>传输服务与协议</h4><ul>
<li>为运行在不同主机上的应用进程提供逻辑通信</li>
<li>传输协议运行在端系统<ul>
<li>发送方：将应用层报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供选择<ul>
<li>Internet TCP、UDP</li>
</ul>
</li>
</ul>
<h4 id="传输层VS-网络层"><a href="#传输层VS-网络层" class="headerlink" title="传输层VS.网络层"></a>传输层VS.网络层</h4><p>网络层服务：主机之间的逻辑通信</p>
<p>传输层服务：进程之间的逻辑通信</p>
<ul>
<li>依赖于网络层服务<ul>
<li>延时带宽</li>
</ul>
</li>
<li>对网络层服务进行加强<ul>
<li>数据丢失、顺序混乱、加密</li>
</ul>
</li>
</ul>
<h4 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h4><ul>
<li>可靠的、保序的传输：TCP<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序传输：UDP<ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的IP服务添加更多的其他额外服务</li>
</ul>
</li>
<li>都不提供<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<h4 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h4><ul>
<li><p>在发送方主机多路复用</p>
<p>从多个套接字接收来自多个应用进程的报文，根据套接字对应的IP地址和端口号等信息对报文段的用头部加以封装（该头部信息用于以后的解复用</p>
</li>
<li><p>在接收方主机多路解复用</p>
<p>根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字（和对应的应用进程）</p>
</li>
<li><p>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确socket,从而交给正确的进程</p>
</li>
<li><p>主机收到IP数据报</p>
<ul>
<li><p>每个数据报有源IP地址和目标地址</p>
</li>
<li><p>每个数据包承载一个传输层报文段</p>
</li>
<li><p>每个报文段有一个源端口号和目标端口号</p>
<p>（特定应用有著名端口号</p>
</li>
</ul>
</li>
<li><p>主机联合使用IP地址和端口号将报文段发送给合适的套接字</p>
</li>
</ul>
<h4 id="UDP：用户数据报协议"><a href="#UDP：用户数据报协议" class="headerlink" title="UDP：用户数据报协议"></a>UDP：用户数据报协议</h4><ul>
<li><p>尽力而为的服务，报文段可能</p>
<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序</li>
</ul>
</li>
<li><p>无连接</p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li><p>UDP被用于</p>
<ul>
<li>流媒体（丢失不敏感、速率敏感、应用可控制传输速率</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li><p>在UDP上实现可靠传输</p>
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
</li>
<li><p>为什么要有UDP?</p>
<ul>
<li><p>不建立连接，（会增加延时</p>
</li>
<li><p>简单，在发送端与客户端没有连接状态</p>
</li>
<li><p>报文段头部很小（开销小）</p>
</li>
<li><p>无拥塞控制和流量控制</p>
<p>UDP可以尽可能快地发送报文段</p>
<p>应用-&gt;传输速率 = 主机-&gt;网络速率</p>
</li>
</ul>
</li>
<li><p>UDP报文段头部8个字节</p>
<ul>
<li>源端口号、目标端口号、长度、校验和</li>
</ul>
</li>
<li><p>UDP校验和</p>
<ul>
<li><p>目标：检测在被传输报文段的查错（如比特翻转</p>
</li>
<li><p>发送方</p>
<ul>
<li>将报文段的内容视为16比特整数</li>
<li>检验和：报文段的加法和（1的补运算</li>
<li>发送方将检验和放在UDP的检验和字段</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li><p>计算接收到的报文段校验和</p>
</li>
<li><p>检查计算出的校验和与校验和字段内容是否相等</p>
<ul>
<li><p>不相等—检测到差错</p>
</li>
<li><p>相等：没有检测到差错，但也许还是有差错</p>
<p>残存错误</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可靠数据传输（rdt-原理"><a href="#可靠数据传输（rdt-原理" class="headerlink" title="可靠数据传输（rdt)原理"></a>可靠数据传输（rdt)原理</h4><ul>
<li><p>rdt在应用层、传输层、数据链路层都很重要</p>
</li>
<li><p>信道的不可靠特点决定了可靠数据传输协议的复杂性</p>
</li>
<li><p>问题描述</p>
<p>rdt_send()被上层（如应用层）调用，以将数据交付给下方的发送实体</p>
<p>udt_send():被rdt调用，用以将分组放到不可靠的信道上传输到接收方</p>
<p>udt_rev():当分组通过信道到达接收方时被调用</p>
<p>deliver_data():被rdt调用，将数据交付给上层</p>
</li>
<li><p>渐增式地开发可靠数据传输协议（rdt)的发送方和接收方</p>
</li>
<li><p>只考虑单向数据传输</p>
<ul>
<li>控制信息是双向流动的</li>
</ul>
</li>
<li><p>双向的数据传输实际上是2个单向数据传输实现的</p>
</li>
<li><p>使用有限状态机（FSM)来描述发送方和接收方）</p>
</li>
</ul>
<h5 id="1-0-在可靠信道上的可靠数据传输"><a href="#1-0-在可靠信道上的可靠数据传输" class="headerlink" title="1.0 在可靠信道上的可靠数据传输"></a>1.0 在可靠信道上的可靠数据传输</h5><ul>
<li>下层信道是完全可靠的<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的FSM<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<h5 id="2-0-具有比特差错的信道"><a href="#2-0-具有比特差错的信道" class="headerlink" title="2.0 具有比特差错的信道"></a>2.0 具有比特差错的信道</h5><ul>
<li>下层信道可能会出错：将分组中的比特翻转<ul>
<li>用检验和来检测比特差错</li>
</ul>
</li>
<li>怎么从差错中恢复<ul>
<li>确认(ACK):接收方显式地告诉发送方分组已被正确接收</li>
<li>否认确定（NAK):接收方显式地告诉发送方分组发生了差错</li>
</ul>
</li>
<li>rdt2.0:采用差错控制编码进行差错检测<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK,NAK)接收方-&gt;发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
<li>rdt 2.1:发送方处理出错的ACK/NAK<ul>
<li>发送方<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAL是否出错（EDC)</li>
<li>状态数变成了两倍（必须记住当前分组序列号是0还是1</li>
</ul>
</li>
<li>接收方<ul>
<li>必须检测收到的分组是否是重复的<ul>
<li>状态会只是希望收到的分组序号是0还是1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了ACK/NAK</li>
</ul>
</li>
</ul>
</li>
<li>rdt2.2 无NAK协议<ul>
<li>只使用NAK</li>
<li>接收方对最后正确接受的分组发ACK,以代替NAK<ul>
<li>接收方必须显式地包含被正确接受分组的序号</li>
</ul>
</li>
<li>当收到重复的ACK时，发送方与收到NAK采取相同动作，重传该分组</li>
<li>为后面的一次发送多个数据单位做一个准备<ul>
<li>一次能够发送多个</li>
<li>每一个应道都有ACK,NAK(麻烦)</li>
<li>使用对前一个数据单位的ACK,代替本单位的NAK</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-0-具有比特差错和分组丢失的信道"><a href="#3-0-具有比特差错和分组丢失的信道" class="headerlink" title="3.0 具有比特差错和分组丢失的信道"></a>3.0 具有比特差错和分组丢失的信道</h5><p>新的假设：下层信道可能会丢失分组（数据或ACK)</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状况<ul>
<li>检验和</li>
<li>序列号</li>
<li>ACK</li>
<li>重传</li>
</ul>
</li>
<li>方法：发送方等待ACK一段合理的时间<ul>
<li>发送端超时重传：如果到时没有收到ACK-&gt;重传</li>
<li>问题:如果分组（ACK)只是被延迟了<ul>
<li>重传会导致数据重复。序列号</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
</li>
<li>rdt3.0性能<ul>
<li>rdt3.0可以工作、但链路容量比较大的情况下，性能很大<ul>
<li>链路容量比较大，一次发一个PDU的不能充分利用链路传输能力</li>
</ul>
</li>
<li>瓶颈在于：网络协议限制了物理资源的利用</li>
</ul>
</li>
</ul>
<h5 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h5><p>流水线：允许发送方在未得到对方确认情况下一个发送多个分组</p>
<ul>
<li><p>必须增加序号的范围，用多个bit表示分组的序号</p>
</li>
<li><p>在发送方、接收方要有缓存区</p>
<ul>
<li><p>发送方缓冲：未得到确认，可能需要重传</p>
</li>
<li><p>接收方缓存：上层用户去用数据速率$\neq$接收到数据速率：接收到的数据可能乱序、排序交付（可靠）</p>
</li>
<li><p>两种通用的流水线协议：</p>
<p>回退N步（GBN）sw &gt; 1 rw = 1</p>
<p>选择重传（SR）sw &gt; 1 rw &gt; 1</p>
</li>
</ul>
</li>
</ul>
<h5 id="通用：滑动窗口协议"><a href="#通用：滑动窗口协议" class="headerlink" title="通用：滑动窗口协议"></a>通用：滑动窗口协议</h5><ul>
<li>发送缓存区<ul>
<li>形式：内存中的一个区域，落入缓存区的分组可以发送</li>
<li>功能：用于存放已发送、未确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li>发送缓冲区大小：一次最多可以发送多少个未经确认的分组<ul>
<li>停止等待协议 = 1</li>
<li>流水线协议&gt;1,合理的值，不能很大，链路利用率不能超100%</li>
</ul>
</li>
<li><p>发送缓冲区的分组</p>
<ul>
<li>未发送的：落入缓冲区的分组，可以连续发送出去</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能被删除</li>
</ul>
</li>
<li><p>发送窗口：发送缓冲区内容的一个范围</p>
<p>那些已发送但是未经确认的分组序号构成的空间</p>
</li>
<li><p>发送窗口的最大值$\leq$发送缓存区的值</p>
</li>
<li><p>一开始：没有发送任何一个分组</p>
<p>后沿 = 前沿</p>
<p>之后为发送窗口的尺寸</p>
</li>
<li><p>每发送一个分组，前沿前移一个单位</p>
</li>
<li><p>发送窗口前沿移动的极限：不能超过发送缓存区</p>
</li>
<li><p>接收窗口用于控制哪些分组可以接收</p>
<ul>
<li>只有收到的分组序号落入接收窗口才允许被接受</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li><p>接收窗口尺寸Wr = 1,则只能顺序接收</p>
</li>
<li><p>接收窗口尺寸Wr &gt; 1，则可以乱序接收</p>
<p>但提交给上层的分组，需按序</p>
</li>
<li><p>正常情况下2个窗口互动：</p>
<ul>
<li>发送窗口<ul>
<li>有新的分组落入缓冲区范围，发送-&gt;前沿滑动</li>
<li>来了老的低序号分组确认-&gt;后沿前移-&gt;新的分组落入发送缓冲区范围</li>
</ul>
</li>
<li>接受窗口<ul>
<li>收到分组，落入到接受窗口范围，接受</li>
<li>是低序号，发送确认给对方</li>
</ul>
</li>
</ul>
</li>
<li>异常情况下GBN的2窗口互动<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿移动</li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去</li>
<li>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区范围</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，没有落入到接受窗口范围内，抛弃</li>
<li>(重复)发送老分组的确认，累计确认</li>
</ul>
</li>
</ul>
</li>
<li>SR<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿移动</li>
<li>超时重发机制让发送端将超时的分组重新发送出去</li>
<li>来了乱序的分组确认-&gt;后沿不向前滑动-&gt;新的分组无法落入缓冲区的范围</li>
</ul>
</li>
<li>接受窗口<ul>
<li>收到乱序分组，落入到接收窗口范围内，接受</li>
<li>发送该分组的确认，单独确认</li>
</ul>
</li>
</ul>
</li>
<li>GBN : 简单、所需资源少,一旦出错，回退N步代价大</li>
<li>SR:出错时、重传一个代价小，复杂，所需资源多</li>
<li>适用范围：<ul>
<li>出错率低：比较适合GBN,出错罕见、没必要用复杂的SR</li>
<li>链路容量大，比较适合SR而不是GBN</li>
</ul>
</li>
</ul>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li><p>点到点</p>
<p>一个发送方，一个接收方</p>
</li>
<li><p>可靠的、按顺序的字节流</p>
<p>没有报文边界</p>
</li>
<li><p>管道化（流水线）</p>
<p>TCP拥塞控制和流量控制设置窗口大小</p>
</li>
<li><p>发送与接受缓存</p>
</li>
<li><p>全双工数据</p>
<ul>
<li>在同一链接中数据双向流动</li>
<li>MSS:最大报文段大小</li>
</ul>
</li>
<li><p>面向连接</p>
<ul>
<li>在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方状态变量</li>
</ul>
</li>
<li><p>有流量控制</p>
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
<li><p>TCP序号</p>
<p>报文段首字节的在字节流的编号</p>
</li>
<li><p>确认号</p>
<p>期望从发送方收到的下一字节的序号</p>
<p>累计确认</p>
</li>
<li><p>TCP往返延时、超时</p>
<p>怎么设置TCP超时</p>
<ul>
<li>比RTT要长<ul>
<li>但RTT是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
</li>
<li><p>怎么估计RTT</p>
<ul>
<li>SampleRTT：测量从报文段发出到收到确认的时间<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li>SampleRTT会变化，因此估计的RTT应该比较平滑<ul>
<li>多次测量取均值</li>
</ul>
</li>
<li>$EstimatedRTT = (1-\alpha)<em>EstimatedRTT + \alpha </em> SampleRTT$<ul>
<li>指数加权移动平均</li>
<li>过去样本的影响成指数衰减</li>
<li>推荐值：$\alpha = 0.125$</li>
</ul>
</li>
</ul>
</li>
<li><p>设置超时</p>
<ul>
<li><p>EstimatedRTT + 安全边界时间</p>
<ul>
<li>EstimatedRTT变化大（方差大）-&gt;较大的安全边界时间</li>
</ul>
</li>
<li><p>SampleRTT会偏离EstimatedRTT多远</p>
<p>$DevRTT = (1-\beta)<em>DevRTT + \beta </em> |SampleRTT - EstimatedRTT|$</p>
<p>推荐值：$\beta = 0.25$</p>
</li>
<li><p>超时时间间隔设置：</p>
<p>$TimeoutInterval = EstimatedRTT + 4*DevRTT$</p>
</li>
</ul>
</li>
</ul>
<h5 id="TCP-可靠数据传输"><a href="#TCP-可靠数据传输" class="headerlink" title="TCP:可靠数据传输"></a>TCP:可靠数据传输</h5><ul>
<li><p>TCP在IP不可靠服务基础上建立了rdf</p>
<ul>
<li>管道化的报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累计确认（像GBN</li>
<li>单个重传定时器（GBN</li>
<li>是否可以接受乱序，没有规范</li>
</ul>
</li>
<li><p>通过以下事件触发重传</p>
<ul>
<li>超时（只重发那个最早未确认的</li>
<li>重复的确认</li>
</ul>
</li>
<li><p>考虑简化的TCP发送方</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制与拥塞控制</li>
</ul>
</li>
<li><p>TCP发送方事件</p>
<ul>
<li><p>从应用层接受数据</p>
<p>用nextseq创建报文段</p>
<p>序号nextseq为报文段首字节的字节流编号</p>
<p>如果还没有运行，启动定时器</p>
<ul>
<li><p>定时器与最早未确认的报文段关联</p>
</li>
<li><p>过期间隔</p>
<p>TimeOutInterval</p>
</li>
</ul>
</li>
<li><p>超时：</p>
<p>重传后沿最老的报文段</p>
<p>重启定时器</p>
</li>
<li><p>收到确认：</p>
<p>如果是对尚未确认的报文段确认</p>
<p>更新已被确认的报文序号</p>
<p>如果当前还有未被确认的报文段，重启定时器</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210531135224845.png" alt="image-20210531135224845"></p>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210531135257112.png" alt="image-20210531135257112"></p>
<h5 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h5><p>缓冲区TCP往里面写，app从当中读</p>
<p>流量控制：接收方控制发送方，不让发送方发送太多太快以至于让接收方的缓存区溢出</p>
<ul>
<li>接收方在其向发送方的TCP段头部的rwnd字段通告其空闲buffer大小<ul>
<li>RcvBuffer 大小通过socket选项设置（典型默认大小为4096字节</li>
<li>很多操作系统自动调整RcvBuffer</li>
</ul>
</li>
<li>发送方限制未确认字节数$\leq$ 接收方发送过来的rwnd值</li>
<li>保证接收方不被淹没</li>
</ul>
<h5 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h5><p>在正式交换数据之前，发送方和接受方握手建立通信关系</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接</li>
<li>同意连接参数</li>
</ul>
<ul>
<li><p>同意建立连接</p>
<ul>
<li>变化的延迟（连接请求没有丢、但可能超时</li>
<li>由于丢失造成的重传</li>
<li>报文乱序</li>
<li>互相看不到对方</li>
</ul>
</li>
<li><p>半连接</p>
<p>（只在服务器端维护了连接） 服务器发回的同意建立连接报文丢失</p>
</li>
<li><p>老数据被当成新的数据接收了</p>
</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210531141833815.png" alt="image-20210531141833815"></p>
<h5 id="TCP-关闭连接"><a href="#TCP-关闭连接" class="headerlink" title="TCP 关闭连接"></a>TCP 关闭连接</h5><p>客户端，服务器分别关闭它自己这一侧的连接</p>
<ul>
<li>发送FIN bit = 1的TCP段</li>
</ul>
<p>一旦接受到FIN,用ACK回应</p>
<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li>
</ul>
<p>可以处理同时的FIN交换</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li>拥塞<ul>
<li>太多的数据需要网络传输，超过了网络处理能力</li>
<li>与流量控制不同</li>
<li>拥塞的表现<ul>
<li>分组丢失（路由器缓冲区溢出</li>
<li>分组经历比较长的延迟（在路由器的队列中排队</li>
</ul>
</li>
<li>代价：<ul>
<li>延迟大</li>
<li>为了达到一个有效输出、网络需要做更多的工作（重传</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝<ul>
<li>没有丢失却超时的分组</li>
<li>降低了的goodput</li>
</ul>
</li>
<li>当分组丢失时，任何关于这个分组的上游传输能力都被浪费了</li>
</ul>
</li>
</ul>
</li>
<li>2种常用拥塞控制方法<ul>
<li>端到端拥塞控制<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否拥塞</li>
<li>TCP采用的方法</li>
</ul>
</li>
<li>网络辅助拥塞控制<ul>
<li>路由器提供给端系统以反馈信息<ul>
<li>单个bit置位，显示有拥塞</li>
<li>显示提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><ul>
<li><p>端到端的拥塞控制机制</p>
<ul>
<li>路由器不向主机提供拥塞反馈信息<ul>
<li>路由器负担轻</li>
<li>符合网络核心简单的TCP/IP架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息判断是否发生拥塞，从而采取动作</li>
</ul>
</li>
<li><p>拥塞控制的几个问题</p>
<ul>
<li>如何检测拥塞<ul>
<li>轻微拥塞</li>
<li>拥塞</li>
</ul>
</li>
<li>控制策略<ul>
<li>在拥塞发生时，降低速率</li>
<li>在拥塞缓解时，增加速率</li>
</ul>
</li>
</ul>
</li>
<li><p>检测拥塞</p>
<ul>
<li>某个段超时了（丢失事件）：拥塞</li>
<li>有关某个段的3次重复ACK：轻微拥塞</li>
</ul>
</li>
<li><p>速率控制方法</p>
<ul>
<li><p>维持一个拥塞窗口的值CongWin</p>
</li>
<li><p>发送端限制已发送但是未确认的数据量的上线</p>
<p>$LatsByteSent - LastByteAcked \leq CongWin$</p>
</li>
<li><p>从而粗略地控制发送方的往网络中注入的速率</p>
</li>
<li><p>$rate = \frac{CongWin}{RTT} bytes/sec$</p>
</li>
<li><p>congwin是动态的，是感知到的网络拥塞程度的函数</p>
<p>超时或者3个重复ACK，Congwin:</p>
<ul>
<li>超时：CongWin 将为1MSS,进入SS阶段然后再倍增到CongWin/2(每个RTT),从进入CA阶段</li>
<li>3个重复ack,CongWin将为CongWin/2,CA阶段</li>
</ul>
<p>否则（正常收到ACK),CongWin跃跃欲试</p>
<ul>
<li>SS阶段：加倍增加（每个RTT)</li>
<li>CA阶段：线性增加（每个RTT)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="联合控制"><a href="#联合控制" class="headerlink" title="联合控制"></a>联合控制</h5><ul>
<li>发送端控制发送但是未确认的量的同时，也不能够超过接收窗口，满足流量控制要求<ul>
<li>sendWin = min(CongWin,RecvWin)</li>
<li>同时满足拥塞控制、流量控制要求</li>
</ul>
</li>
<li>拥塞控制策略<ul>
<li>慢启动</li>
<li>AIMD:线性增、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
</li>
</ul>
<h5 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h5><ul>
<li><p>连接刚建立，CongWin = 1MSS</p>
<p>MSS = 1460bytes &amp; RTT = 200 msec</p>
<p>初始速率=58.4kbps</p>
</li>
<li><p>可用带宽可能$&gt;&gt;$MSS/RTT</p>
</li>
<li><p>当链接开始时，指数性增加发送速率，直到发生丢失的事件</p>
<ul>
<li>启动初值很低</li>
<li>速度很快</li>
</ul>
</li>
<li><p>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件</p>
<ul>
<li>每一个RTT，CongWin加倍</li>
<li>每收到一个ACK，CongWin+1</li>
<li>慢启动阶段，只要不超时或者3个重复ACK,一个RTT,CongWin加倍</li>
</ul>
</li>
<li><p>总结：初始速率很慢，但是加速确实指数性的</p>
<ul>
<li>指数增加，SS时间很短</li>
</ul>
</li>
</ul>
<h5 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h5><ul>
<li><p>乘性减</p>
<p>丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段</p>
</li>
<li><p>加性增</p>
<p>当CongWin大于阈值时，一个RTT如没有发生丢失事件，将CongWin加1MSS:探测</p>
</li>
<li><p>当收到3个重复的ACKs</p>
<ul>
<li>COngWin减半</li>
<li>窗口（缓冲区大小）之后线性增长</li>
</ul>
</li>
<li><p>当超时事件发生</p>
<ul>
<li>CongWin被设置为1MSS,进入SS阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值（上次发生拥塞窗口的一半），线性增加</li>
</ul>
</li>
</ul>
<h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><ul>
<li><p>当CongWin &lt; Threshold,发送端处于慢启动阶段（slow-start),窗口指数性增长</p>
</li>
<li><p>当CongWin &gt; Threshold,发送端处于拥塞避免阶段，窗口线性增长</p>
</li>
<li><p>当收到三个重复的ACKs,Threshold设置为 CongWin/2,</p>
<p>CongWin = Threshold + 3</p>
</li>
<li><p>当超时事件发生时，Threshold = COngWin/2</p>
<p>CongWin = 1MSS，进入SS阶段</p>
</li>
</ul>
<h5 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h5><p>公平性目标：如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R/K</p>
<p>2个竞争的TCP会话：</p>
<ul>
<li>加性增加，斜率为1，吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><p>网络层服务</p>
<ul>
<li>在发送主机和接收主机对之间传送段（segment)</li>
<li>在发送端将段封装到数据报中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报头部</li>
</ul>
<h4 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h4><p>转发：将分组从路由器的输入接口转发到合适的输出端口</p>
<p>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径</p>
<ul>
<li>路由选择算法</li>
<li>路由选择协议</li>
</ul>
<h5 id="数据平面-1"><a href="#数据平面-1" class="headerlink" title="数据平面"></a>数据平面</h5><ul>
<li>本地，每个路由器功能</li>
<li>决定从路由器输入端口到达的分组如何转发到输出端口</li>
<li>转发功能：<ul>
<li>传统方式：基于目标地址+转发表</li>
<li>SDN:基于多个字段+流表</li>
</ul>
</li>
</ul>
<h5 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h5><ul>
<li>网络范围内的逻辑</li>
<li>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</li>
<li>2个控制平面方法：<ul>
<li>传统路由算法：在路由器中被实现</li>
<li>SDN:在远程服务器中实现</li>
</ul>
</li>
</ul>
<p>传统方式：路由与转发的相互作用</p>
<p>==控制平面==：路由算法决定端到端的路径</p>
<p>==数据平面==：IP协议根据转发表决定了IP数据报在此路由器上的局部转发</p>
<p>SDN方式：逻辑集中的控制平面</p>
<p>一个不同的控制器与本地控制代理交互</p>
<p>网络服务模型</p>
<p>对于单个数据报的服务</p>
<ul>
<li>可靠传送</li>
<li>延迟保证</li>
</ul>
<p>对于数据报流的服务</p>
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟差</li>
</ul>
<p>连接建立</p>
<ul>
<li>在某些网络架构中是第三个重要的功能</li>
<li>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接<ul>
<li>涉及路由器</li>
</ul>
</li>
<li>网络层与传输层连接服务的区别<ul>
<li>网络层：2个主机之间、涉及路径上的一些路由器</li>
<li>传输层：2个进程之间，只体现在端系统</li>
</ul>
</li>
</ul>
<h4 id="路由器结构概况"><a href="#路由器结构概况" class="headerlink" title="路由器结构概况"></a>路由器结构概况</h4><p>高层面通用路由器体系架构</p>
<ul>
<li>路由：运行路由选择算法/协议（RIP,OSPF,BGP）生成路由表</li>
<li>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</li>
<li>分布式交换<ul>
<li>根据数据报头部信息，如目标地址，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动</li>
<li>基于目标的转发：仅仅依赖于IP数据报的目标地址</li>
<li>通用转发：基于头部字段的任意集合进行转发</li>
</ul>
</li>
<li>当交换机构的速率小于输入端口的汇聚速率时-&gt;在输入端口可能要排队<ul>
<li>排队延迟以及由于输入缓存溢出造成丢失</li>
</ul>
</li>
<li>Head-of-the-Line(HOL) blocking:排在队头的数据报阻止了队列中其他数据报向前移动</li>
</ul>
<h5 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h5><ul>
<li>将分组从输入缓冲区传输到合适的输出端口</li>
<li>交换速率：分组可以按照该速率从输入传输到输出<ul>
<li>运行速度经常是输入、输出链路速率的若干倍</li>
<li>N个输入端口，交换机构的速率是输入线路的N倍比较理想、才不会成为瓶颈</li>
</ul>
</li>
<li>memory<ul>
<li>在CPU直接控制下交换</li>
<li>分组被拷贝到系统内存，CPU从头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li>
<li>转发速率被内存的带宽限制（数据报通过BUS两遍）</li>
<li>一次只能转发一个分组</li>
</ul>
</li>
<li>bus<ul>
<li>数据报通过共享总线、从输入端转发到输出端口</li>
<li>总线竞争：交换速度受限于总线带宽</li>
<li>一次处理一个分组</li>
<li>对于接入、企业级路由器，速度足够（但不适合区域或骨干网络</li>
</ul>
</li>
<li>crossbar<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
<li>Banyan网络，crossbar和其他的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口y,控制器短接相应的两个总线</li>
<li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li>
</ul>
</li>
<li>输出端口排队<ul>
<li>假设交换速率$R<em>{switch}$是$R</em>{line}$的N倍</li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存</li>
<li>排队带来延迟、由于输出端口缓存溢出则丢弃数据报</li>
</ul>
</li>
<li>调度机制<ul>
<li>选择下一个要通过链路传输的分组</li>
<li>FIFO按照分组到来的次序发送<ul>
<li>丢弃策略：<ul>
<li>tail drop</li>
<li>proiority</li>
<li>random</li>
</ul>
</li>
</ul>
</li>
<li>优先权调度</li>
<li>RR</li>
<li>Weighted Fair Queuing(WFQ)</li>
</ul>
</li>
</ul>
<h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p>网络层：</p>
<p>路由选择协议</p>
<ul>
<li>路径选择</li>
<li>RIP,OSPF,BGP</li>
</ul>
<p>IP协议</p>
<ul>
<li>地址约定</li>
<li>数据报格式</li>
<li>分组处理的约定</li>
</ul>
<p>ICMP协议</p>
<ul>
<li>错误报告</li>
<li>路由器命令</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601153141589.png" alt="image-20210601153141589"></p>
<ul>
<li><p>网络链路有MTU(最大传输单元)</p>
<p>-链路层帧所携带的最大数据长度</p>
<ul>
<li>不同的链路类型</li>
<li>不同的MTU</li>
</ul>
</li>
<li><p>大的IP数据报在网络上被分片</p>
<ul>
<li>一个数据报被分割成若干个小的数据报<ul>
<li>相同的ID</li>
<li>不同的偏移量</li>
<li>最后一个分片被标记为0</li>
</ul>
</li>
<li>重组只在最终得目标主机上进行</li>
<li>IP头部信息用于标识，排序相关分片</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601154304706.png" alt="image-20210601154304706"></p>
</li>
</ul>
<h6 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h6><ul>
<li>IP地址：32位标识，对主机或路由器接口编址</li>
<li>接口：主机、路由器和物理链路得连接处<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也可能有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
</li>
<li>一个IP地址和一个接口相关联</li>
</ul>
<h6 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h6><ul>
<li>IP地址<ul>
<li>子网部分：（高位bits)</li>
<li>主机部分：（低位bits)</li>
</ul>
</li>
<li>什么是子网（subnet)<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的高位相同，这些节点构成的网络的一部分叫做子网</li>
<li>无需路由器介入，子网内各主机可以在物理上相互可达</li>
</ul>
</li>
<li>要判断一个子网，将每一个接口从主机或路由器上分开，构成了一个个的网络孤岛</li>
<li>每一个孤岛（网络）都是一个可以被称之为subset</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601160148874.png" alt="image-20210601160148874"></p>
<p>（全零网络号、全1网络号不用）</p>
<p>（A，B,C类地址为单播地址，D类为组播地址，E类预留）</p>
<ul>
<li>特殊的IP地址<ul>
<li>子网部分：全为0—本网络</li>
<li>主机部分：全为0—本主机</li>
<li>主机部分：全为1—广播地址，这个网络的所有主机</li>
<li>127.x.x.x回路地址</li>
</ul>
</li>
<li>专用地址：地址空间的一部分供专用地址使用</li>
<li>永远不会当作共用地址来分配，不会与公用地址重复<ul>
<li>只在局部网络有意义，区分不同的设备</li>
</ul>
</li>
<li>路由器不对目标地址是专用地址的分组进行转发</li>
<li>专用地址范围：<ul>
<li>Class A 10.0.0.0 -10.255.255.255 MASK 255.0.0.0</li>
<li>Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0</li>
<li>Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0</li>
</ul>
</li>
</ul>
<h6 id="IP编址-CIDR"><a href="#IP编址-CIDR" class="headerlink" title="IP编址 CIDR"></a>IP编址 CIDR</h6><p>CIDR(Classless InterDomain Routing)</p>
<p>无类域间路由</p>
<ul>
<li>子网部分可以在任意的位置</li>
<li>地址格式： a.b.c.d/x,其中x为地址中的子网号长度</li>
</ul>
<p>转发表和转发算法</p>
<ul>
<li>获得IP数据报的目标地址</li>
<li>对于转发表中的每一个选项，如果（IP Des addr)&amp;(mask) == destination,则按照表项对应的接口转发该数据报</li>
<li>如果都没有，则使用默认表项转发数据报</li>
</ul>
<p>如何获得一个IP地址</p>
<ul>
<li><p>主机如何获得一个IP地址？</p>
<ul>
<li><p>系统管理员将地址配置在一个文件中</p>
<p>Wintel:control-panel-&gt;network-&gt;configuration-&gt;tcp/ip-&gt;properties（IP地址、字码掩码、默认网关、local name server)</p>
<p>Unix:/etc/rc.config</p>
</li>
<li><p>DHCP： Dynamic Host Configuration Protocol</p>
<p>从服务器中动态获得一个IP地址</p>
<ul>
<li>目标：允许主机在加入网络的时候，动态地从服务器那里获得IP地址<ul>
<li>可以更新对主机用IP地址的租用期</li>
<li>重新启动时，允许重新使用以前用过的IP地址</li>
<li>支持移动用户加入到该网络（短期在网）</li>
</ul>
</li>
<li>DHCP工作概况<ul>
<li>主机广播 DHCP discover 报文</li>
<li>DHCP服务器用DHCP offer提供报文响应</li>
<li>主机请求IP地址，发送DHCP request报文</li>
<li>DHCP服务器发送地址：DHCP Ack 报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何获得一个网络的子网部分？</p>
<ul>
<li>从ISP获得地址块中分配一个小地址块</li>
</ul>
</li>
<li><p>一个ISP如何获得一个地址块</p>
<p>ICANN：Internet Corporation for Assigned Names and Numbers</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名、解决冲突</li>
</ul>
</li>
</ul>
<h6 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h6><p>层次编址允许路由信息的有效广播</p>
<h6 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h6><p>所有离开本地网络的数据报具有一个相同的源地址NAT IP address ,但具有不同端口号</p>
<p>动机：本地网络只有一个有效IP地址</p>
<ul>
<li>不需要从ISP分配一块地址、可用一个IP地址用于所有的（局域网设备）—省钱</li>
<li>可以在局域网改变设备地址的情况下无需通知外界</li>
<li>可以改变ISP(地址变化)而不需改变内部的设备地址</li>
<li>局域网内部的设备没有明确地址，对外是不可见的（安全</li>
</ul>
<p>NAT路由器必须：</p>
<ul>
<li><p>外出数据包：替换源地址和端口号为Nat IP地址和新的端口号，目标IP和端口号不变</p>
<p>远端的C/S将会使用NAT IP地址，新端口号作为目标地址</p>
</li>
<li><p>记住每个轮换替换对（在NAT转换表中</p>
<p>源IP,端口 vs NAT ip 新端口</p>
</li>
<li><p>进入数据包：替换目标IP地址端口号，采用存储在NAT表中的mapping表项，用（源IP、端口</p>
</li>
</ul>
<p>NAT: Network Address Translation</p>
<ul>
<li>16-bit端口字段<ul>
<li>6万多个同时连接、一个局域网</li>
</ul>
</li>
<li>对NAT是有争议的<ul>
<li>路由器只应该对第三层信息做处理，而这里对端口号（4层）做了处理</li>
<li>违反了end-to-end原则<ul>
<li>端到端的原则，复杂性放到网络边缘<ul>
<li>无需借助中转和变换，就可以直接传送到目标主机</li>
</ul>
</li>
<li>NAT可能要被一些应用设计者考虑</li>
<li>外网的机器无法主动连接到内网机器上</li>
</ul>
</li>
<li>地址短缺可以被ipv6解决</li>
<li>Nat穿越</li>
</ul>
</li>
</ul>
<h6 id="Nat穿越"><a href="#Nat穿越" class="headerlink" title="Nat穿越"></a>Nat穿越</h6><ul>
<li><p>客户端需要连接地址为10.0.0.1的服务器</p>
<ul>
<li>服务器地址10.0.0.1LAN本地地址（客户端不能够使用其作为目标地址</li>
<li>整网只有一个外部可见地址</li>
</ul>
</li>
<li><p>方案1:静态配置NAT,转发进来的对服务器特定端口的连接请求</p>
</li>
<li><p>方案2:(IGD)协议:允许NATed主机可以：</p>
<ul>
<li>获知网络的公共IP地址</li>
<li>列举存在的端口映射</li>
<li>增删端口映射</li>
</ul>
<p>自动化静态NAT端口映射配置</p>
</li>
<li><p>方案3：中继</p>
<ul>
<li>NAT后面的服务器建立和中继的连接</li>
<li>外部的客户端链接到中继</li>
<li>中继在2个连接之间桥接</li>
</ul>
</li>
</ul>
<h6 id="IPv6-动机"><a href="#IPv6-动机" class="headerlink" title="IPv6 动机"></a>IPv6 动机</h6><ul>
<li>初始动机 32-bit地址空间将会很快被用完</li>
<li>另外的动机<ul>
<li>头部格式改变帮助加速处理和转发<ul>
<li>TTL-1</li>
<li>头部checksum</li>
<li>分片</li>
</ul>
</li>
<li>头部格式改变帮助QoS</li>
</ul>
</li>
<li>IPv6数据报格式<ul>
<li>固定的40字节头部</li>
<li>数据报传输过程中，不允许分片</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601182357723.png" alt="image-20210601182357723"></p>
<p>TLV格式 T:type L:lenght V:Value</p>
<ul>
<li>CheckSum被移除掉，降低在每一段中处理速度</li>
<li>Options:允许，但在头部之外，被Next header字段标识</li>
<li>ICMPv6:ICMP的新报本<ul>
<li>附加了报文类型，e.g. Packet Too Big</li>
<li>多播组管理功能</li>
</ul>
</li>
<li>从IPv4到IPv6的平移<ul>
<li>不是所有的路由器能够同时升级的</li>
</ul>
</li>
<li>隧道：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报</li>
</ul>
<p>每个路由器上都有实现路由算法元件（他们之间需要相互交互）-形成传统IP实现方式的控制平面</p>
<p>1.每台设备上既实现控制功能又实现数据平面</p>
<p>2.控制功能分布式实现</p>
<p>3.路由表-粘连</p>
<ul>
<li><p>数量众多、功能各异的中间盒</p>
<ul>
<li>路由器的网络层功能<ul>
<li>IP转发：对于到来的分组按照路由表决定如何转发，数据平面</li>
<li>路由：决定路径、计算路由表、处在控制平面</li>
</ul>
</li>
<li>还有其他种类繁多的网络设备（中间盒<ul>
<li>交换机；防火墙；NAT;IDS;负载均衡设备</li>
</ul>
</li>
</ul>
</li>
<li><p>互联网网络设备：传统方式都是通过分布式、每台设备的方法来实现数据平面和控制平面</p>
</li>
<li><p>垂直集成：每台路由器或其他网络设备</p>
<ul>
<li>硬件、在私有的操作系统</li>
<li>互联网标准协议的私有实现</li>
<li>每个设备都实现了数据平面和控制平面的功能<ul>
<li>控制平面的功能是分布式实现的</li>
</ul>
</li>
<li>设备基本上只能按照固定方式工作，控制逻辑固化，不同的网络功能需要不同的middleboxes</li>
<li>(数据+控制平面)集成&gt;(控制逻辑)分布-&gt;固化<ul>
<li>代价大，升级困难，管理困难</li>
</ul>
</li>
</ul>
</li>
<li><p>SDN:逻辑上集中的控制平面</p>
<ul>
<li>一个不同的控制器与CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑</li>
</ul>
</li>
<li><p>主要思路：</p>
<ul>
<li>网络设备数据平面、控制平面分离</li>
<li>数据平面-分组交换机<ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽象：按照流表（有控制平面设置的控制逻辑)进行PDU(帧、分组)的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</li>
<li>统一化设备功能：SDN交换机（分组交换机），执行控制功能</li>
</ul>
</li>
<li>控制平面-控制器+网络应用<ul>
<li>分离、集中</li>
<li>计算、下发控制逻辑:流表</li>
</ul>
</li>
<li>水平集成控制平面的开放实现，创造了好的产业生态、促进发展</li>
<li>集中式实现控制逻辑、网络管理容易</li>
<li><p>基于流表的匹配+行动的工作方式允许可编程的分组交换机</p>
</li>
<li><p>流量工程：传统路由比较困难</p>
<ul>
<li>需要定义链路的代价、流量路由算法以此运算</li>
</ul>
</li>
<li><p>SDN特点</p>
<ul>
<li>通用的flow-based基于流的匹配+行动</li>
<li>控制平面和数据平面分离</li>
<li>控制平面功能在数据交换设备之外实现</li>
<li>可编程控制应用<ul>
<li>在控制器之上以网络应用形式实现各种网络功能</li>
</ul>
</li>
</ul>
</li>
<li><p>SDN架构：</p>
<ul>
<li>数据平面交换机<ul>
<li>快速、简单、商业化交换设备，采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li>基于南向API(例如OpenFlow),SDN控制器访问基于流的交换机</li>
<li>也定义了和控制器的协议</li>
</ul>
</li>
<li>SDN控制器（网络OS)<ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式实现</li>
</ul>
</li>
<li>网络控制应用<ul>
<li>控制的大脑：采用下层提供的服务（SDN控制器提供的API)，实现网络功能<ul>
<li>路由器、交换机</li>
<li>接入控制、防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供、与控制器厂商通常不同、与分组交换机厂商也可以不同</li>
</ul>
</li>
</ul>
</li>
<li><p>通用转发和SDN</p>
<p>每个路由器包含一个流表（被逻辑上集中的控制器计算和分发</p>
</li>
<li><p>OpenFlow数据平面抽象</p>
<ul>
<li><p>流：由分组（帧）头部字段所定义</p>
</li>
<li><p>通用转发：简单的分组处理规则</p>
<ul>
<li>模式：将分组头部字段和流表匹配</li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器</li>
<li>优先权Priority:几个模式匹配了优先采用哪个，消除歧义</li>
<li>计算器Counters#bytes以及#packets</li>
</ul>
<p>路由器中的流表定义了路由器的匹配+行动规则</p>
<p>match+action:统一化各种网络设备提供的功能</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制平面-1"><a href="#控制平面-1" class="headerlink" title="控制平面"></a>控制平面</h4><h5 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h5><p>路由协议的目标：确定从发送主机到接收主机之间、通过路由器网络较好的路径（等价于路由器序列</p>
<ul>
<li>路径：路由器序列,分组将会沿着该序列从源主机到达最后的目标主机</li>
<li>较好：最小代价、最快的、最不拥塞</li>
</ul>
<p>路由（route）的概念</p>
<ul>
<li><p>路由：按照某种指标（传输延迟、所经过的站点数目等）找到一条从源节点到目标结点的较好路径</p>
<ul>
<li><p>较好路径：按照某种指标较小的路径</p>
</li>
<li><p>指标：站数，延迟、费用、队列长度等、或者是一些单纯的指标加权</p>
</li>
<li><p>采用什么样的指标，标识网络使用者网络在什么方面表现突出、什么指标网络使用者比较重视</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>路由器-路由器最优路径=主机对之间的最优路径</p>
<ul>
<li>路由器连接子网、子网到路由器之间的跳数就一跳，必须要走</li>
<li>路由器到下一跳路由器（节点到节点）之间的最优路径找到了</li>
<li>也就找到了从源子网到目标子网所有主机对之间的最优路径</li>
<li>大大降低了路由计算的规模</li>
<li>在路由计算中按照子网到子网的路径计算为目标，而不是主机到主机</li>
</ul>
</li>
<li><p>路由选择算法（routing algorithm)网络层软件的一部分，完成路由功能</p>
</li>
</ul>
<ul>
<li><p>最优化原则</p>
<ul>
<li>汇集树（sink tree)<ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
</ul>
</li>
</ul>
</li>
<li><p>路由选择算法的原则</p>
<ul>
<li><p>正确性：算法必须是正确的和完整的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应表项；没有处理不了的目标站地址</p>
</li>
<li><p>简单：算法在计算机上应简单、最优但复杂的算法、时间上延迟大、不实用、不应为了获取路由信息增加很多的通信量</p>
</li>
<li><p>健壮性：算法能适应通信量和网络拓扑的变化</p>
<p>通信量变化、网络拓扑的变化算法能很快适应</p>
<p>不向拥挤的链路发数据、不向断了的链路发数据</p>
</li>
<li><p>稳定性：产生的路由不应该摇摆</p>
</li>
<li>公平性：对每一个站点都公平</li>
<li>最优性：某一个指标的最优，时间上，费用上、等指标，或综合指标，实际上获取最优的结果代价较高，可以是次优的</li>
</ul>
</li>
<li><p>路由算法的分类</p>
<ul>
<li><p>全局</p>
<p>所有路由器拥有完整的拓扑和边的代价信息</p>
<p>link state算法</p>
</li>
<li><p>分布式</p>
<p>路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价</p>
<p>迭代地与邻居交换路由信息</p>
<p>distance vector算法</p>
</li>
<li><p>静态或动态</p>
<ul>
<li><p>静态：路由随时间变化缓慢</p>
<p>非自适应算法：不能适应网络拓扑和通信量的变化，路由表是事先计算好的</p>
</li>
<li><p>动态：路有变化很快</p>
<p>自适应路由选择、能适应网络拓扑和通信量的变化</p>
<ul>
<li><p>周期性更新</p>
</li>
<li><p>根据链路代价的变化而变化</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LS路由工作过程</p>
<ul>
<li><p>配置LS路由选择算法的路由工作过程</p>
<ul>
<li>各点通过各种渠道获得整个网络拓扑，网络中所有链路代价信息（这部分与算法无关，属于协议和实现）</li>
<li>使用LS路由算法，计算本站点到其他站点的最优路径（汇集树），得到路由表</li>
<li>按照此路由表转发分组(datagram方式)<ul>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
</li>
<li><p>LS路由的基本工作过程</p>
<p>1.发现相邻节点，获知对方网络地址</p>
<p>2.测量到相邻节点的代价（延迟、开销</p>
<p>3.组装一个LS分组，描述它到相邻节点的代价情况</p>
<p>4.将分组通过扩散的方式发送到所有其他路由器</p>
<ul>
<li>顺序号：用于控制无穷的扩散，每个路由器记录（源路由器、顺序号）发现重复的或老的就不扩散</li>
<li>解决问题的方法：年龄字段（age)<ul>
<li>生成一个分组时，年龄字段不为0</li>
<li>每过一个时间段，AGE字段-1</li>
<li>AGE字段为0的分组被抛弃</li>
</ul>
</li>
</ul>
<p>5.通过Dijkstra算法找到最短路径</p>
<ul>
<li>可能带来路径的震荡e.g. 链路代价=链路承载的流量</li>
</ul>
<p>路由器获得各站点LS分组和整个网络的拓扑</p>
<p>通过Dijkstra算法计算出到其他各路由器的最短路径（汇集树</p>
<p>将计算结果安装到路由表中</p>
<ul>
<li><p>每个节点独立算出到其他节点的最短路径</p>
</li>
<li><p>迭代算法：第k步直到本节点到k个其他节点的最短路径</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LS的应用情况</p>
<ul>
<li>OSPF是一种LS协议。被用于Internet上</li>
<li>IS-IS，被用于Internet主干上，Netware</li>
</ul>
</li>
<li><p>距离矢量路由选择(Bellman Ford)</p>
<p>动态路由选择算法之一</p>
<ul>
<li>距离矢量路由选择</li>
<li>链路状态路由选择</li>
</ul>
<p>距离矢量路由选择基本思想</p>
<ul>
<li>各路由器维护一张路由表</li>
<li>各路由器与相邻路由器交换路由表</li>
<li>根据获得的路由信息，更新路由表</li>
</ul>
</li>
<li><p>代价及相邻节点代价的获得</p>
<ul>
<li>跳数、延迟、队列长度</li>
<li>相邻节点间的代价获得、通过实测</li>
</ul>
</li>
<li><p>路由信息的更新</p>
<ul>
<li>根据实测，得到本节点A到相邻节点的代价（如延迟</li>
<li>根据各相邻节点声称他们到目标节点B的代价</li>
<li>计算出本站点A经过各相邻站点到目标节点B的代价</li>
<li>找到一个最小的代价、和相应的下一个节点Z，到达节点B经过此节点Z,并且代价为A-Z-B的代价</li>
<li>其他所有的目标节点一个计算法</li>
</ul>
<p>定期测量</p>
<p>定期交换</p>
</li>
<li><p>异步、迭代式：每次本地迭代被以下事件触发</p>
<ul>
<li>本地链路代价变化了</li>
<li>从邻居来了DV更新消息</li>
</ul>
</li>
<li><p>分布式</p>
<ul>
<li>每个节点只是在自己的DV改变之后向邻居通告</li>
<li>然后邻居们在有必要的时候通知他们的邻居</li>
</ul>
<p>每个节点</p>
<ul>
<li>等待（本地链路代价变化或者从邻居传送新的DV报文</li>
<li>重新计算各目标代价估计值</li>
<li>如果到任何目标的DV发生变化，通告邻居</li>
</ul>
</li>
<li><p>DV的无穷计算问题</p>
<ul>
<li>DV的特点<ul>
<li>好消息传得快，坏消息传得慢</li>
</ul>
</li>
<li>好消息的传播以每一个交换周期前进一个路由器的速度进行<ul>
<li>好消息：某个路由器接入或有更短的路径</li>
<li>坏消息传播速度非常慢（无穷计算问题）</li>
</ul>
</li>
<li>水平分裂算法<ul>
<li>C直到要经过B才能到达A,所以C向B报告A的距离为INF,C告诉D它到A的真实距离</li>
</ul>
</li>
</ul>
</li>
<li><p>LS和DV算法比较</p>
<ul>
<li><p>消息复杂度</p>
<ul>
<li><p>LS：有n节点、E条链路，发送报文O(nE)个</p>
<p>局部路由信息，全网传播</p>
</li>
<li><p>DV: 只与邻居交换信息</p>
<p>全网路由信息，局部传播</p>
</li>
</ul>
</li>
<li><p>收敛时间</p>
<ul>
<li>LS $O(n^2)$算法<ul>
<li>有可能震荡</li>
</ul>
</li>
<li>DV:收敛较慢<ul>
<li>可能存在路由环路</li>
<li>count-to-infinity问题</li>
</ul>
</li>
</ul>
</li>
<li><p>健壮性</p>
<p>路由器故障会发生什么</p>
<ul>
<li><p>LS:</p>
<p>节点会通告不正常的链路代价</p>
<p>每个节点只计算自己的路由表</p>
<p>错误信息影响较小，局部，路由比较健壮</p>
</li>
<li><p>DV:</p>
<p>DV节点可能通告对全网所有节点的不正确路径代价</p>
<ul>
<li><p>距离矢量</p>
</li>
<li><p>每一个节点的路由表可能被其他的节点使用</p>
<ul>
<li>错误可以扩散到全网</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="自治系统内部的路由选择"><a href="#自治系统内部的路由选择" class="headerlink" title="自治系统内部的路由选择"></a>自治系统内部的路由选择</h5><ul>
<li><p>RIP 距离矢量算法</p>
<ul>
<li>距离矢量：每条链路cost = 1,# of hops(max = 15hops）跳数</li>
<li>DV每隔30秒和邻居交换DV,通告</li>
<li>每个通告包括，最多25个目标子网</li>
</ul>
</li>
<li><p>链路失效与恢复</p>
<p>如果180s没有收到通告信息-&gt;邻居或者链路失效</p>
<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告（如果路由变化的话</li>
<li>链路失效快速地在整网中传输</li>
<li>使用毒性逆转（poison reverse)阻止ping-pong回路（不可达距离：跳数无限=16段）</li>
</ul>
</li>
<li><p>RIP以应用进程的形式实现（route-d)</p>
</li>
<li><p>通告报文通过UDP报文传输，周期性重复</p>
</li>
<li><p>网络层协议使用了传输层的服务，以应用层实体的形式实现</p>
</li>
<li><p>OSPF</p>
<ul>
<li><p>使用LS算法</p>
<ul>
<li>LS分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑，代价在每一个节点中都保持</li>
<li>路由计算采用dijkstra算法</li>
</ul>
</li>
<li><p>OSPF通告信息携带：每一个邻居路由器的表项</p>
</li>
<li><p>通告信息会传遍AS全部（通过泛洪）</p>
<ul>
<li>在IP数据报上直接传送OSPF报文</li>
</ul>
</li>
<li><p>IS-IS路由协议：几乎和OSPF一样</p>
</li>
<li><p>安全：所有OSPF报文都是经过认证的</p>
</li>
<li><p>允许有多个代价相同的路径存在（在RIP协议中只有一个）</p>
</li>
<li><p>对每一个链路，对于不同的TOS有多重代价矩阵</p>
<ul>
<li>卫星链路代价对尽力而为的服务代价设置较低，对实时服务代价设置较高</li>
<li>支持按照不同代价计算最优路径</li>
</ul>
</li>
<li><p>对单播和多播的集成支持</p>
<ul>
<li>Multicast OSPF使用相同的拓扑数据库</li>
</ul>
</li>
<li><p>在大型网络中支持层次性的OSPF</p>
</li>
</ul>
</li>
</ul>
<h5 id="ISP之间的路由选择"><a href="#ISP之间的路由选择" class="headerlink" title="ISP之间的路由选择"></a>ISP之间的路由选择</h5><ul>
<li><p>层次路由</p>
<ul>
<li>一个平面路由：<ul>
<li>一个网络中的所有路由器地位一样</li>
<li>通过LS、DV,或者其他路由算法，所有路由器都要知道其他所有路由器（子网）怎么走</li>
<li>所有路由器在一个平面</li>
</ul>
</li>
<li>平面路由的问题<ul>
<li>规模巨大的网络中，路由信息的存储、传输、计算代价巨大<ul>
<li>DV距离矢量很大，且不能收敛</li>
<li>LS:几百万个节点的LS分组泛洪传输，存储以及最短路径计算</li>
</ul>
</li>
<li>管理问题：<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己的网络细节</li>
<li>还希望与其他网络互联</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>层次路由：将互联网分成一个一个的AS(路由器区域)</p>
<ul>
<li>某个区域内的路由器集合，自治系统）autonomous systems (AS)</li>
<li>一个AS用AS Number (ASN)唯一标识</li>
<li>一个ISP可能包括一个或者多个AS</li>
</ul>
</li>
<li>路由变成了：2个层次路由<ul>
<li>AS内部路由：在同一个AS内路由器运行相同的路由协议<ul>
<li>intra-AS routing protocol：内部网关协议</li>
<li>不同的AS可能运行着不同的内部网关协议</li>
<li>能够解决规模和管理问题</li>
<li>如RIP,OSPF,IGRP</li>
<li>网关路由器：AS边缘路由器，可以连接到其他AS</li>
</ul>
</li>
<li>AS间运行AS间路由协议<ul>
<li>inter-AS routing protocol:外部网关协议</li>
<li>解决AS之间的路由问题，完成AS之间互联互通</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>解决了规模问题<ul>
<li>内部网关协议解决：AS内部数量有限的路由器互相到达问题。AS内部规模可控<ul>
<li>AS节点太多，可分割AS,使得AS内部节点有限</li>
</ul>
</li>
<li>AS之间的路由规模<ul>
<li>增加一个AS，对于AS之间的路由从总体上来说，只是增加了一个节点=子网（每个AS可以用一个点标识</li>
<li>对于其他AS只是增加一个表项，就是这个新增的路由怎么走的问题</li>
<li>扩展性强：规模增大，性能不会减太多</li>
</ul>
</li>
</ul>
</li>
<li>解决了管理问题<ul>
<li>各个AS可以运行不同的内部网关协议</li>
<li>可以使自己网络的细节不向外透露</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="互联网AS间路由：BGP"><a href="#互联网AS间路由：BGP" class="headerlink" title="互联网AS间路由：BGP"></a>互联网AS间路由：BGP</h5><ul>
<li>BGP：自治区域间路由协议事实上的标准<ul>
<li>将互联网各个AS粘在一起的胶水</li>
</ul>
</li>
<li>BGP提供给每个AS以下方法<ul>
<li>eBGP:从相邻的ASes那里获得子网可达信息</li>
<li>iBGP:将获得的子网可达信息传遍到AS内部所有路由器</li>
<li>根据子网可达信息和策略来决定到达子网的好路径</li>
</ul>
</li>
<li>允许子网向互联网其他网络通告我在这里</li>
<li><p>基于距离矢量算法（路径矢量</p>
<ul>
<li>不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS序号的列表）能够避免简单DV算法的路由环路问题</li>
</ul>
</li>
<li><p>BGP会话：</p>
<p>2个BGP路由器（peers)在一个半永久的TCP连接上交换BGP报文</p>
<ul>
<li>通告向不同目标子网前缀的路径（BGP是一个路径矢量协议</li>
</ul>
</li>
<li><p>当通告一个子网前缀时，通告包括BGP属性</p>
<ul>
<li>prefix+attributes = ‘route’</li>
</ul>
</li>
<li><p>2个重要属性</p>
<ul>
<li>AS-PATH：前缀的通告所经过的AS列表：AS 67 AS 17<ul>
<li>检测回路：多路径选择</li>
<li>在向其他AS转发时，需要将自己的AS号加在路径上</li>
</ul>
</li>
<li>NEXT-HOP：从当前AS到下一跳AS有多个链路，在NEXT-HOP属性中，告诉对方通过哪个I转发</li>
<li>其他属性：路由偏好指标，如何被插入的属性</li>
</ul>
</li>
<li><p>基于策略的路由</p>
<ul>
<li>当一个网关路由器接收到了一个路由通告，使用输入策略来接受或过滤（accept/decline)<ul>
<li>过滤原因1：不想经过某个AS，转发某些前缀的分组</li>
<li>过滤原因2：已经有了一条往某前缀的偏好路径</li>
</ul>
</li>
<li>策略也决定了是否向它别的邻居通告收到的这个路由信息</li>
</ul>
</li>
<li><p>BGP报文</p>
<ul>
<li>使用TCP协议交换BGP报文</li>
<li>BGP报文：<ul>
<li>OPEN打开TCP链接，认证发送方</li>
<li>UPDATE：通告新路径（或者撤销原路径）</li>
<li>KEEPALIVE:在没有更新时保持连接、也用于对OPEN请求的确认</li>
<li>NOTIFICATION:报告以前消息的错误，也用来关闭连接</li>
</ul>
</li>
</ul>
</li>
<li><p>BGP路径选择</p>
<ul>
<li>路由器可能获得一个网络前缀的多个路径、路由器必须进行路径的选择，路由选择可以基于：<ul>
<li>本地偏好设置：偏好策略的决定</li>
<li>最短AS-PATH:AS的跳数</li>
<li>最近的NEXT-HOP路由器：热土豆路由</li>
<li>附加的判据：使用BGP标示</li>
</ul>
</li>
<li>一个前缀对应着多种路径，采用消除规则直到留下一条路径</li>
</ul>
</li>
<li><p>为什么内部网关协议与外部网关协议不同</p>
<ul>
<li><p>策略：</p>
<ul>
<li>Inter-AS管理员需要控制通信路径，谁在使用它的网络进行数据传输</li>
</ul>
</li>
<li><p>规模</p>
<ul>
<li>Intra-AS一个管理者，所以无需策略<ul>
<li>AS内部各子网的主机尽可能地利用资源进行快速路由</li>
<li>AS内部路由规模不是一个大的问题<ul>
<li>如果AS太大，可将AS分成小的AS:规模可控</li>
<li>AS之间只不过多了一个点</li>
<li>或者AS内部路由支持层次性、层次性路由节省了表空间、降低了更新的数据流量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>性能：<ul>
<li>Intra-AS关注性能</li>
<li>Inter-AS:策略比性能更重要</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h5><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>网络节点连接方式</p>
<ul>
<li>点到点连接</li>
<li>多点连接<ul>
<li>共享介质</li>
<li>通过网络交换机</li>
</ul>
</li>
</ul>
<p>WAN:网络形式采用点到点链路</p>
<ul>
<li>带宽大、距离远（延迟大）带宽延迟积大</li>
<li>如果采用多点连接方式<ul>
<li>竞争方式：一旦冲突代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
</ul>
<p>点到点链路的链路层服务</p>
<p>实现简单、封装与解封装</p>
<p>LAN一般采用多点连接方式</p>
<ul>
<li>连接节点方便</li>
<li>接到共享性介质上（或网络交换机）就可以连接所有其他节点</li>
</ul>
<p>多点连接方式网络的链路层功能实现复杂</p>
<ul>
<li>多点接入：协调各节点对共享型介质的访问与使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生、占有和释放</li>
</ul>
<ul>
<li>主机和路由器是节点（网桥和交换机也是）nodes</li>
<li>沿着通信路径，连接各相邻节点通信信道是链路（links)<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li>第二层协议数据单元帧（frame),封装数据报</li>
<li>数据链路层负责从一个节点通过链路将帧中的数据报发送到物理相邻节点</li>
<li>数据报（分组）在不同链路上以不同的链路协议传送<ul>
<li>第一条链路：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳802.11</li>
</ul>
</li>
<li>不同的链路协议提供不同的服务<ul>
<li>e.g.在链路层上提供（或没有）可靠数据传送</li>
</ul>
</li>
</ul>
<h4 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h4><ul>
<li><p>成帧，链路接入</p>
<ul>
<li>将数据报装入帧中，加上帧头，帧尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用MAC物理地址来标识源和目的<ul>
<li>不同于IP地址</li>
</ul>
</li>
</ul>
</li>
<li><p>在相邻两个节点完成可靠数据传递</p>
<ul>
<li>在低出错率的链路（光纤、双绞线电缆）上很少使用</li>
<li>在无线链路经常使用、出错率高</li>
</ul>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务，一个特定的链路层只是提供其中的一部分服务</p>
</li>
<li><p>流量控制：</p>
<p>使得相邻的发送和接收方节点速度匹配</p>
</li>
<li><p>错误检测</p>
<ul>
<li><p>差错由信号衰减和噪声引起</p>
</li>
<li><p>接收方检测出的错误</p>
<p>通知发送端进行重传或者丢弃帧</p>
</li>
</ul>
</li>
<li><p>差错纠正</p>
<ul>
<li>接收端检查和纠正bit错误，不通过重传来纠正错误</li>
</ul>
</li>
<li><p>半双工和全双工</p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<p>链路层在哪里实现？</p>
<ul>
<li>在每一个主机上<ul>
<li>也在每个路由器上</li>
<li>交换机每个端口上</li>
</ul>
</li>
<li>链路层功能在适配器上实现（或者在一个芯片组上<ul>
<li>以太网卡，802.11网卡，以太网芯片组</li>
<li>实现链路层和相应的物理层功能</li>
</ul>
</li>
<li>接到主机的系统总线上</li>
<li>硬件、软件和固件的综合体</li>
</ul>
<p>发送方：</p>
<ul>
<li>在帧中封装数据报</li>
<li>加上差错控制编码，实现RDT和流量控制功能</li>
</ul>
<p>接收方：</p>
<ul>
<li>检查有无出错，执行rdt和流量控制功能等</li>
<li>解封装数据报，将之交给上层</li>
</ul>
<h4 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h4><p>EDC = 差错检测和纠正位（冗余位）</p>
<p>D= 数据由差错检测保护，可以包含头部字段</p>
<p>错误检测不是100%可靠</p>
<ul>
<li>协议会漏检一些错误</li>
<li>更长的EDC字段可以得到更好的检测和纠正效果</li>
</ul>
<h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><ul>
<li>单bit奇偶校验</li>
</ul>
<p>检测单个bit级错误</p>
<ul>
<li>2维奇偶校验</li>
</ul>
<p>检测和纠正单个bit错误</p>
<h5 id="检验和：CRC-循环冗余校验"><a href="#检验和：CRC-循环冗余校验" class="headerlink" title="检验和：CRC(循环冗余校验)"></a>检验和：CRC(循环冗余校验)</h5><ul>
<li><p>强大的差错检测码</p>
</li>
<li><p>将数据比特D看成二进制数据</p>
</li>
<li><p>生成多项式G,双方协商r+1位模式（r次方）</p>
<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li><p>目标：选择r位CRC附加位R，使得</p>
<ul>
<li><D,R>正好能被G整除（module 2)</li>
<li>接收方知道G,将<D,R>除以G,如果非0余数，检查出错</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul>
</li>
<li><p>CRC性能分析</p>
<ul>
<li><p>突发错误和突发长度</p>
</li>
<li><p>CRC检错性能描述</p>
<ul>
<li><p>能够检查出所有的1bit错误</p>
</li>
<li><p>能够检查出所有的双bits错误</p>
</li>
<li><p>能够检查出所有长度=r或者小于r位的错误</p>
</li>
<li><p>出现长度为r+1的突发错误，检查不出的概率为</p>
<p>$1/2^{r-1}$</p>
</li>
<li><p>出现长度大于r+1的突发错误，检查不出的概率为</p>
<p>$1/2^{r}$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h4><p>两种类型的链路：（一个子网内部链路连接形式）</p>
<ul>
<li>点对点<ul>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点到点链路</li>
</ul>
</li>
<li>广播（共享线路或媒体）<ul>
<li>传统以太网</li>
<li>HFC上行链路</li>
<li>802.11无线局域网</li>
</ul>
</li>
<li>多路访问协议<ul>
<li>单个共享的广播型链路</li>
<li>2个或更多站点同时传送：冲突<ul>
<li>多个节点同时发送、则会收到2个或多个信号的叠加</li>
</ul>
</li>
</ul>
</li>
<li>多路访问协议（介质访问控制协议：MAC）<ul>
<li>分布式算法-决定节点如何使用共享信道</li>
<li>关于共享控制的通信必须借助信道本身进行传输<ul>
<li>没有带外的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
</li>
<li>理想的多路访问协议<ul>
<li>给定Rbps的广播信道</li>
<li>必要条件：<ul>
<li>当一个节点要发送时，可以R速率发送</li>
<li>当M个节点要发送，每个可以以R/M的平均速率发送</li>
<li>完全分布的<ul>
<li>没有特殊节点协调发送</li>
<li>没有时钟和时隙同步</li>
</ul>
</li>
<li>简单</li>
</ul>
</li>
</ul>
</li>
<li>3大类<ul>
<li>信道划分<ul>
<li>将信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul>
</li>
<li>随机访问<ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li>依次轮流<ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
</li>
<li><p>信道划分MAC协议:TDMA</p>
<ul>
<li>TDMA time division multiple access<ul>
<li>轮流使用信道，信道的时间分成周期</li>
<li>每个站点使用每周其中固定的时隙（长度=帧传输时间）传输帧</li>
<li>如果站点无帧传输，时隙空闲-&gt;浪费</li>
</ul>
</li>
<li>FDMA :frequency division multiple access<ul>
<li>信道的有效频率范围被分成一个个小的频段</li>
<li>每个站点被分配一个固定的频段</li>
<li>分配给站点的频段没有被使用-&gt;空闲</li>
</ul>
</li>
<li>码分多路访问（CDMA) code division multiple access<ul>
<li>所有站点在整个频段上同时传输，采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>假定：信号同步很好，线性叠加</li>
</ul>
</li>
</ul>
</li>
<li><p>随机存取协议</p>
<ul>
<li>当节点有帧要发送时<ul>
<li>以信道带宽的全部R bps发送</li>
<li>没有结点间的预先协调</li>
</ul>
</li>
<li>两个或者更多节点同时传输，会发生冲突</li>
<li>随机存取协议规定<ul>
<li>如何检测冲突</li>
<li>如何从冲突中恢复</li>
</ul>
</li>
</ul>
</li>
<li><p>时隙ALOHA</p>
<p>假设</p>
<ul>
<li>所有帧都是等长的</li>
<li>时间被划分成相等的时隙，每个时隙可发送一帧</li>
<li>节点只在时隙开始时发送帧</li>
<li>节点在时钟上是同步的</li>
<li>如果两个或多个节点在同一时隙传输，所有的节点都能检测到冲突</li>
</ul>
<p>运行</p>
<ul>
<li><p>当节点获取到新的帧，在下一个时隙传输</p>
</li>
<li><p>传输时没有检测到冲突，成功</p>
</li>
<li><p>检测时如果检测到冲突，失败</p>
<p>节点在每一个随后的时隙以概率p重传帧直到成功</p>
</li>
</ul>
<p>优点</p>
<ul>
<li>节点可以以信道带宽全速连续传输</li>
<li>高度分布，仅需要节点之间在时隙上同步</li>
<li>简单</li>
</ul>
<p>缺点</p>
<ul>
<li>存在冲突、浪费时隙</li>
<li>即使有帧要发送，仍然可能存在空闲的时隙</li>
<li>节点检测冲突的时间&lt;帧传输的时间<ul>
<li>必须传完</li>
</ul>
</li>
<li>需要始终上同步</li>
</ul>
<p>效率：当有很多节点，每个节点有很多帧要发送时，x%的时隙时成功传输帧的时隙</p>
<ul>
<li><p>假设N个节点，每个节点都有很多帧要发送，在每个时隙中传输的概率是p</p>
</li>
<li><p>一个节点成功传输的概率为$p(1-p)^{N-1}$</p>
</li>
<li><p>任意一个节点成功的概率为$Np(1-p)^{N-1}$</p>
</li>
<li><p>N个结点的最大效率：</p>
<p>使得$f(P)=Np(1-p)^{N-1}$最大的$p^{*}$</p>
</li>
<li><p>N为无穷大时极限为$1/e = 0.37$</p>
</li>
</ul>
</li>
<li><p>纯ALOHA(非时隙)</p>
<ul>
<li>无时隙ALOHA:简单、无需节点间在时间上同步</li>
<li>当有帧需要传输，马上传输</li>
<li>冲突的概率增加</li>
</ul>
</li>
<li><p>CSMA冲突</p>
<ul>
<li><p>冲突仍然可能发生</p>
<p>由传播延迟造成：两个节点可能侦听不到正在进行的传输</p>
</li>
<li><p>冲突：</p>
<p>整个冲突帧的传输时间都被浪费了，是无效的传输</p>
</li>
<li><p>传播延迟决定了冲突的概率</p>
</li>
</ul>
<p>节点根据本地信道使用情况来判断全部信道使用情况</p>
</li>
<li><p>CSMA/CD(冲突检测)</p>
<p>CSMA/CD</p>
<ul>
<li>载波侦听CSMA:和在CSMA中一样发送侦听信道</li>
<li>没有传完一个帧就可以在短时间内检测到冲突</li>
<li>冲突发生时传输终止，减少对信道的浪费</li>
</ul>
</li>
<li><p>冲突检测CD技术，有线局域网中容易实现</p>
<ul>
<li>检测信号强度、比较传输与接收到的信号是否相同</li>
<li>通过周期的过零点检测</li>
</ul>
</li>
<li><p>以太网CSMA/CD算法</p>
<ul>
<li><p>适配器获取数据报，创建帧</p>
</li>
<li><p>发送前：侦听信道CS</p>
<p>闲：开始传输帧</p>
<p>忙：一直等到闲再发送</p>
</li>
<li><p>发送过程中，冲突检测CD</p>
<p>没有冲突：成功</p>
<p>检测到冲突放弃，之后尝试重发</p>
</li>
<li><p>发送方适配器检测到冲突</p>
<p>除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此，让所有站点都知道冲突</p>
</li>
<li><p>如果放弃，适配器进入指数退避状态</p>
</li>
<li><p>在第m次失败后，适配器随机选择一个${0,1,2,\cdots,2^{m-1}}$中的K，等待K*512位时，然后转步骤2</p>
</li>
</ul>
</li>
<li><p>无线局域网CSMA/CA</p>
<p>WLAN构成</p>
<ul>
<li>基站 ：AP</li>
<li>无线链路</li>
<li>移动主机节点</li>
</ul>
</li>
<li><p>冲突：2+站点（AP或者站点）在同一时刻发送</p>
<ul>
<li><p>802.11 CSMA- 发送前侦听信道</p>
<p>不会和其它节点正在进行的传输发生冲突</p>
</li>
<li><p>802.11：没有冲突检测</p>
<ul>
<li>无法检测冲突：自身信号远大于其他节点信号</li>
<li>即使能CD，冲突和成功没有关系</li>
<li>目标avoid collisions CSMA/C(ollision)A(voidance)<ul>
<li>无法CD,一旦发送全部发完，不CD</li>
<li>为了避免无CD带来信道利用率低的问题，事前进行冲突避免</li>
</ul>
</li>
</ul>
</li>
<li><p>发送方：</p>
<ul>
<li><p>如果站点侦听到信道空闲持续DIFS长，则传输整个帧</p>
</li>
<li><p>如果侦测到信道忙碌，那么选择一个随机会退值，并在信道空闲时递减该值，如果信道忙碌，回退值不会变化</p>
<p>当数到0时（只发生在信道闲时）发送整个帧</p>
<p>如果没有收到ACK，增加回退值，重复2</p>
</li>
</ul>
</li>
<li><p>接收方</p>
<p>如果帧正确，则在SIFS后发送ACK</p>
</li>
</ul>
<p>无线链路特性，需要每帧确认</p>
<p>无法完全避免冲突</p>
<ul>
<li><p>两个站点相互隐藏</p>
<p>A,B相互隐藏，C在传输</p>
<p>A，B选择了随机回退值</p>
<p>一个节点A先发</p>
<p>而B收不到，将count down减到0，发送</p>
<p>A,B的发送在C附近形成了干扰</p>
</li>
<li><p>选择了非常靠近的随机回退值</p>
<p>A,B选择的值比较近</p>
<p>A到0发送</p>
<p>信号没传到B，B减到0,发送</p>
<p>冲突</p>
</li>
</ul>
</li>
<li><p>冲突避免：</p>
<p>思想：允许发送方预约信道，而不是随机访问该信道</p>
<p>避免长数据帧的冲突</p>
<ul>
<li>发送方首先使用CSMA向BS发送一个小的RTS分组<ul>
<li>RTS可能冲突，但是短，浪费信道少</li>
</ul>
</li>
<li>BS广播clear-to-send CTS,作为RTS的响应</li>
<li>CTS能够被所有涉及的节点听到<ul>
<li>发送方发送数据帧</li>
<li>其他节点抑制发送</li>
</ul>
</li>
</ul>
</li>
<li><p>线缆接入网络</p>
<ul>
<li><p>多个40Mbps下行（广播）信道,FDM</p>
<ul>
<li>下行：通过FDM分成若干信道，互联网、数字电视</li>
<li>互联网信道：只有一个CMTS在其上传输</li>
</ul>
</li>
<li><p>多个30Mbps上行信道FDM</p>
<ul>
<li>多路访问：所有用户使用：接着TDM分成微时隙</li>
<li>部分时隙：分配，部分时隙：竞争</li>
</ul>
<p>预约，CMTS将预约结果通过下行信道下发</p>
</li>
</ul>
</li>
<li><p>轮流（Taking Turns) MAC协议</p>
<ul>
<li><p>信道划分MAC协议</p>
<ul>
<li><p>共享信道在高负载时时有效和公平的</p>
</li>
<li><p>在低负载时效率低下</p>
<p>只能等到自己的时隙开始发送或者利用1/N信道频率发送</p>
<p>当只有一个节点有帧传时，也只能得到1/N带宽分配</p>
</li>
</ul>
</li>
<li><p>随机访问MAC协议</p>
<ul>
<li>低负载时效率高，单个节点可以完全利用信道的全部带宽</li>
<li>高负载时效率低，冲突开销大，效率极低，时间很多浪费在冲突中</li>
</ul>
</li>
<li><p>轮流协议</p>
<p>有2者的优点</p>
</li>
</ul>
</li>
<li><p>轮流MAC协议</p>
<ul>
<li>轮询<ul>
<li>主节点邀请从节点一次传送</li>
<li>从节点一般比较dumb</li>
<li>缺点<ul>
<li>轮询开销:轮询本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传送，即使只有一个节点，也要等到轮询一周后发送</li>
<li>单点故障：主节点失效造成整个系统无法使用</li>
</ul>
</li>
</ul>
</li>
<li>令牌传递<ul>
<li>控制令牌（token)循环从一个节点到下一个节点传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点：<ul>
<li>令牌开销：本身消耗的带宽</li>
<li>延迟：只有等到抓到令牌，才能传输</li>
<li>单点故障（token）<ul>
<li>令牌丢失系统级故障，整个系统无法传输</li>
<li>复杂机制重新生成令牌</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h4><h5 id="MAC地址与ARP"><a href="#MAC地址与ARP" class="headerlink" title="MAC地址与ARP"></a>MAC地址与ARP</h5><ul>
<li>32bitIP地址<ul>
<li>网络层地址</li>
<li>用与使数据报到达目的IP子网：前n-1跳</li>
<li>从而到达子网中的目标节点：最后一跳</li>
</ul>
</li>
<li>LAN(MAC/物理/以太网)地址：<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（同一物理网络中</li>
<li>48bit MAC地址固化在适配器的ROM，也可通过软件设定</li>
<li>理论上全球任意两个网卡的MAC地址都不相同</li>
<li>e.g. 1A-2F-BB-76-09-AD</li>
</ul>
</li>
</ul>
<h5 id="网络地址和mac地址分离"><a href="#网络地址和mac地址分离" class="headerlink" title="网络地址和mac地址分离"></a>网络地址和mac地址分离</h5><ul>
<li><p>IP地址和MAC地址作用不同</p>
<ul>
<li>IP地址是分层的<ul>
<li>一个子网所有的站点网络号一致，路由聚集，减少路由表<ul>
<li>需要一个网络中的站点地址网络号一致，如果捆绑需要定制网卡非常麻烦</li>
</ul>
</li>
<li>希望网络层地址是配置的，IP地址完成网络到网络的交付</li>
</ul>
</li>
<li>mac地址是一个平面的<ul>
<li>网卡在生产的时候不知道被用于哪个网络，因此网卡一个唯一的标志，用于区分一个网络内部不同的网卡即可</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付</li>
</ul>
</li>
</ul>
</li>
<li><p>分离好处</p>
<ul>
<li>网卡坏了，ip不变，可以捆绑到另一个网卡的mac上</li>
<li>物理网络还可以除IP之外支持其他网络层协议，链路协议为任意上层网络协议服务，如IPX等</li>
</ul>
</li>
<li><p>捆绑的问题</p>
<ul>
<li>如果仅仅使用IP地址，不使用mac地址,那么他仅支持IP协议</li>
<li>每次上电都要重新写入网卡IP地址</li>
<li>另外一个选择是不使用任何地址，不用mac地址,则每到来一个帧都要上传到IP层次，由他判断是否接收</li>
</ul>
</li>
<li><p>局域网每个适配器都有一个唯一的mac地址</p>
<p>FF-FF-FF-FF-FF-FF 广播地址</p>
</li>
<li><p>MAC地址由IEEE管理和分配</p>
</li>
<li><p>制造商购入MAC地址空间（保证唯一</p>
</li>
<li><p>类比：</p>
<ul>
<li>MAC地址：社会安全号</li>
<li>IP地址：通信地址</li>
</ul>
</li>
<li><p>MAC平面地址-&gt;支持移动</p>
<ul>
<li>可以将网卡连到其他网络</li>
</ul>
</li>
<li><p>IP地址有层次-不能移动</p>
<ul>
<li>依赖于节点连接的IP子网，与子网网络号相同（有与其相连的子网相同的网络前缀</li>
</ul>
</li>
<li><p>已知IP地址，如何确定mac地址</p>
<ul>
<li><p>在LAN上的每个IP节点都有一个ARP表</p>
</li>
<li><p>ARP表：包括一些LAN节点IP/MAC地址映射</p>
<IP address:mac address:TTL>

<p>TTL时间为地址映射失效时间，典型是20min</p>
</li>
</ul>
</li>
<li><p>ARP协议：在同一个LAN(网络)</p>
<ul>
<li>A要发送帧给B(B的IP地址已知)，但B的MAC地址不在A的ARP表中</li>
<li>A广播包含B的IP地址的ARP查询包<ul>
<li>Dest MAC Address = FF-FF-FF-FF-FF-FF</li>
<li>LAN上所有节点收到查询包</li>
</ul>
</li>
<li>B接收到ARP包，回复A自己的MAC地址<ul>
<li>帧发送给A</li>
<li>用A的MAC地址（单播）</li>
</ul>
</li>
<li>A在自己的ARP表中缓存IP-to-MAC地址转换关系，直到信息超时<ul>
<li>软状态：靠定期刷新维持的系统状态</li>
<li>定期刷新周期之间维护的状态信息可能和原有系统不一致</li>
</ul>
</li>
<li>ARP是即插即用的<ul>
<li>节点自己创建ARP表项</li>
<li>无需网络管理员干预</li>
</ul>
</li>
</ul>
</li>
<li><p>以太帧结构</p>
<ul>
<li><p>发送方适配器在以太网帧中封装IP数据报，或其他网络层协议数据单元</p>
</li>
<li><p>前导码：</p>
<ul>
<li>7B10101010 + 1B 10101011</li>
<li>用来同步接收方与发送方的时钟速率<ul>
<li>使得接收方将自己的时钟跳到发送端的时钟</li>
<li>从而按照发送端时钟来接收所发送的帧</li>
</ul>
</li>
</ul>
</li>
<li><p>地址：6字节源MAC地址、目标MAC地址</p>
<ul>
<li>帧目标地址=本站MAC地址或是广播地址，递交帧中的数据到网络层</li>
<li>否则，忽略</li>
</ul>
</li>
<li><p>类型：指出高层协议（大多数情况是IP</p>
</li>
<li><p>CRC：在接受方校验</p>
<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="以太网：无连接、不可靠服务"><a href="#以太网：无连接、不可靠服务" class="headerlink" title="以太网：无连接、不可靠服务"></a>以太网：无连接、不可靠服务</h5><ul>
<li>无连接：帧传输前，没有接收方与发送方握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul>
<li>递交给网络层的数据流报可能有gap</li>
<li>如上层使用像传输层TCP协议这样的rdt,gap会被补上（源主机，TCP实体</li>
<li>否则应用层会看到gap</li>
</ul>
</li>
<li>以太网MAC协议：采用二进制退避的CSMA/CD介质访问控制形式</li>
<li>很多不同的以太网标准<ul>
<li>相同的MAC协议（介质访问控制）和帧结构</li>
<li>不同的速率</li>
<li>不同的物理层标准</li>
<li>不同的物理层媒介：光纤，同轴电缆，双绞线</li>
</ul>
</li>
<li>CSMA/CD<ul>
<li>没有时隙</li>
<li>NIC如果侦听到其他NIC在发送就不发送（载波侦听</li>
<li>发送时，适配器侦听到其他适配器在发送就放弃对当前真的发送，冲突检测</li>
<li>冲突后重传，重传前适配器等待一个随机时间</li>
</ul>
</li>
</ul>
<h5 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a>Hubs</h5><ul>
<li>hubs本质上是一个物理层的中继器<ul>
<li>从一个端口收，转发到其他所有端口</li>
<li>速率一致</li>
<li>没有帧的缓存</li>
<li>在hub端口没有CSMA/CD机制</li>
<li>提供网络管理功能</li>
</ul>
</li>
<li>Manchester编码<ul>
<li>在10BaseT中使用</li>
<li>每一个bit位时中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步<ul>
<li>节点间不需要集中和全局时钟</li>
</ul>
</li>
<li>10Mbps,使用20M带宽，效率50%</li>
</ul>
</li>
<li>网段（LAN segments):可以允许一个站点发送的网络范围<ul>
<li>在一个碰撞域，同时只允许一个站点在发送</li>
<li>如果2个节点同时发送，则会碰撞</li>
<li>通常具有相同的前缀，比IP子网更详细的前缀</li>
</ul>
</li>
<li>所有以hub连到一起的站点处于同一个网段，处在一个碰撞域<ul>
<li>骨干hub将所有网段连到了一起</li>
</ul>
</li>
<li>通过hub可扩展节点之间的最大距离</li>
<li>通过hub，不能将10baseT和100BaseT的网络连接到一起</li>
</ul>
<h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><ul>
<li>链路层设备：扮演主动角色（端口执行以太网协议<ul>
<li>对帧进行存储转发</li>
<li>对于到来的帧，检查帧头。根据MAC地址进行选择性转发</li>
<li>当帧需要向某个网段进行转发，需要使用CSMA/CD进行控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul>
</li>
<li>透明，主机对交换机的存在可以不关心<ul>
<li>通过交换机相连的个节点好像这些站点直接相连一样</li>
<li>有MAC地址，无IP地址</li>
</ul>
</li>
<li>即插即用，自学习<ul>
<li>交换机无须配置</li>
</ul>
</li>
<li>多路同时传输<ul>
<li>主机有一个专用和直接到交换机的连接</li>
<li>交换机缓存到来的帧</li>
<li>对每个帧进入的链路使用以太网协议，没有碰撞，全双工<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC协议在其中的作用弱化了</li>
</ul>
</li>
</ul>
</li>
<li>每个交换机都有一个交换表switch table，每个表项<ul>
<li>（主机MAC地址，到达该MAC经过的接口，时戳）</li>
</ul>
</li>
<li>交换机通过学习得到哪些主机可以通过哪些端口到达<ul>
<li>当接收到帧，交换机学习到发送站点所在端口</li>
<li>记录发送方MAC地址/进入端口映射关系，在交换表中</li>
</ul>
</li>
</ul>
<p>交换机 vs.路由器</p>
<ul>
<li><p>都是存储转发设备，但是层次不同</p>
<ul>
<li>交换机：链路层设备（检查链路层头部）</li>
<li>路由器：网络层设备（检查网络层头部）</li>
</ul>
</li>
<li><p>都有转发表</p>
<ul>
<li>交换机：维护交换表，按照MAC地址转发<ul>
<li>执行过滤自学习生成树算法</li>
<li>即插即用，二层设备，速率高</li>
<li>执行生成树算法，限制广播帧转发</li>
<li>ARP表项随着站点数量增多而增多</li>
</ul>
</li>
<li>路由器维护路由表，执行路由算法<ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li>
<li>对广播分组做限制</li>
<li>不是即插即用，配置网络地址（子网前缀</li>
<li>三层设备，速率低</li>
</ul>
</li>
</ul>
</li>
<li><p>LAN 不碰撞=成功</p>
<p>帧长度$\geq 2\tau$ $\tau$最远两个站点之间的传播延时</p>
</li>
</ul>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p>机密性：只有发送方和预定的接收方能理解传输的报文内容</p>
<ul>
<li>发送方加密报文</li>
<li>接收方解密报文</li>
</ul>
<p>认证：发送方接收方需要确认对方身份</p>
<p>报文完整性：发送方、接收方需要确认报文在传输过程中或者时候没有被改变</p>
<p>访问控制和服务的可用性：服务可以接入以及对用户而言是可用的</p>
<h4 id="加密语言"><a href="#加密语言" class="headerlink" title="加密语言"></a>加密语言</h4><ul>
<li>对称密钥密码学：发送方和接收方密钥相同</li>
<li>公开密钥密码学：发送方使用接收方的公钥进行加密，接收方使用自己的私玥进行解密</li>
</ul>
<p>对称密钥加密</p>
<p>替换密码：将一个事情替换为另一个事情</p>
<p>单词替换密码：将一个字母替换成另外一个字母</p>
<p>加密$K<em>{A-B}(m)$，解密$K</em>{A-B}(K_{A-B}(m))$</p>
<ul>
<li>key分发？</li>
</ul>
<p>DES</p>
<p>初始替换</p>
<p>16轮一样的函数应用</p>
<p>每一轮使用不同的48bit密钥</p>
<p>最终替换</p>
<p>AES</p>
<p>块密码</p>
<p>密码块链</p>
<ul>
<li>密码块：如果输入块重复，将会得到相同的密文块</li>
<li>密码块链：异或第i轮的输入m(i),与前一轮的密文c(i-1)</li>
</ul>
<p>公开密钥密码学</p>
<ul>
<li>发送方接收方无需共享密钥</li>
<li>一个实体的公钥公诸于众</li>
<li>私玥只有自己知道</li>
</ul>
<p>RSA</p>
<p>认证</p>
<p>目标：避免重放攻击</p>
<ul>
<li>Nonce一生只用一次整数R</li>
<li>ap4.0 为了证明Alice的活跃性，Bob发送给Alice一个nonce R</li>
<li>Alice必须返回加密之后的R,使用双方约定好的key</li>
</ul>
<p>ap4.0需要双方共享一个对称式的密钥</p>
<p>ap5.0:使用nonce，公开加密技术</p>
<p>用Alice公钥解密</p>
<p>中间攻击</p>
<p>报文完整性</p>
<ul>
<li>数字签名</li>
</ul>
<p>数字签名类比于手写签名</p>
<ul>
<li>发送方Bob数字签署了文件，前提时它时文件拥有者，创建者</li>
<li>可验证性、不可伪造性、不可抵赖性<ul>
<li>谁签署：接收方可以向他人证明，而不是其他人签署了这个文件</li>
<li>签署了什么：这份文件而不是其他文件</li>
</ul>
</li>
<li>报文摘要</li>
</ul>
<p>对长报文进行公开密钥加密算法的实施需要耗费大量时间</p>
<p>Goal：固定长度，容易计算</p>
<ul>
<li>对m使用散列函数，得到固定长度报文摘要H(m)</li>
</ul>
<p>散列函数特性：</p>
<ul>
<li>多对一</li>
<li>结果固定长度</li>
<li>给定一个报文摘要x，反向计算原报文是不可行的</li>
</ul>
<p>散列函数算法MD5，SHA-1</p>
<p>可信赖中介</p>
<ul>
<li><p>对称密钥问题</p>
<ul>
<li><p>共享对称式密钥</p>
</li>
<li><p>trusted key distribution center (KDC)在实体之间扮演可信赖中介角色</p>
<ul>
<li>KDC:服务器和每一个注册用户都共享一个对称式的密钥</li>
<li>Alice,Bob和KDC通信时，知道他们自己的对称式密钥$K<em>{A-KDC} $,$K</em>{B-KDC}$</li>
</ul>
</li>
</ul>
</li>
<li><p>公共密钥问题</p>
<ul>
<li><p>如何保证获取的是对方公钥</p>
</li>
<li><p>可信赖的certification authority(CA)</p>
<ul>
<li>CA将每一个注册实体E和它的公钥捆绑</li>
<li>E到CA哪里注册它的公钥<ul>
<li>E提供给CA，自己身份的证据</li>
<li>CA创建一个证书，捆绑了实体信息和它的公钥</li>
<li>Certificate包括了E的公钥，而且是被CA签署的（被CA用自己的密钥加了密的）</li>
</ul>
</li>
<li>当Alice需要拿到Bob公钥<ul>
<li>获得Bob证书certificate(从Bob或者其他地方)</li>
<li>对Bob的证书，使用CA的公钥验证</li>
</ul>
</li>
</ul>
</li>
<li>证书包括<ul>
<li>串号（证书发布者唯一</li>
<li>证书拥有者信息，包括算法和密钥值</li>
</ul>
</li>
</ul>
</li>
<li><p>信任树</p>
<ul>
<li>根证书：根证书是未被签名的公钥证书或自签名证书<ul>
<li>拿到一些CA的公钥</li>
<li>渠道：安装OS自带的数字证书：从网上下载，你信任的数字证书</li>
</ul>
</li>
<li>信任树<ul>
<li>信任根证书CA颁发的证书，拿到了根CA的公钥（信任了根</li>
<li>由根CA签署的给一些机构的数字证书，包含了这些机构的数字证书</li>
<li>由于你信任了根，从而能够可靠地拿到根CA签发的证书，可靠地拿到这些机构的公钥</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 计算机网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/16/iterator/" rel="prev" title="iterator">
                  <i class="fa fa-chevron-left"></i> iterator
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
                  操作系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  



      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liulx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

      
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>












    <div class="pjax">
  

  

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"9hqrMBm5CSF4MzBqIOmG2yjR-gzGzoHsz","appKey":"cY7tkRBoQeYdaspntsGJazu2","placeholder":"Just go go","avatar":"mm","meta":["nick","mail"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"serverURLs":null,"enableQQ":true,"requiredFields":["nick"]}
    ));
  }, window.Valine);
});
</script>

    </div>
  <!-- 引用依赖 -->
          <link rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
          <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
          <script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script>

          <!-- 我使用的APlayer本体 -->
          <div class="aplayer"
            data-id="4866586492"
            data-server="netease"
            data-type="playlist"
            data-fixed="true"
            data-autoplay="true"
            data-order="random"
            data-volume="0.55"
            data-theme="#cc543a"
            data-preload="auto" >
            </div>
          <!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面-->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
<script type="text/javascript" src="/js/fire.js"></script>

</html>
