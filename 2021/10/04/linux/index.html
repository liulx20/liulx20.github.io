<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Linux 系统目录  bin 二进制可执行文件 boot 开机启动程序 dev 设备文件 home 普通用户 etc:用户信息和系统配置文件 password group lib 库文件 root 管理员宿主目录 usr用户资源目录  文件类型：  普通文件 - 目录文件 d 字符设备文件 c 块设备文件 b 软连接 l 管道文件 p 套接字 s 未知文件  常用命令 which:查看指定命令所">
<meta property="og:type" content="article">
<meta property="og:title" content="linux">
<meta property="og:url" content="https://github.com/liulx20/2021/10/04/linux/index.html">
<meta property="og:site_name" content="liulx">
<meta property="og:description" content="Linux 系统目录  bin 二进制可执行文件 boot 开机启动程序 dev 设备文件 home 普通用户 etc:用户信息和系统配置文件 password group lib 库文件 root 管理员宿主目录 usr用户资源目录  文件类型：  普通文件 - 目录文件 d 字符设备文件 c 块设备文件 b 软连接 l 管道文件 p 套接字 s 未知文件  常用命令 which:查看指定命令所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20211004203908020.png">
<meta property="article:published_time" content="2021-10-04T06:04:05.000Z">
<meta property="article:modified_time" content="2021-11-07T06:35:10.452Z">
<meta property="article:author" content="liulx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/liule/AppData/Roaming/Typora/typora-user-images/image-20211004203908020.png">


<link rel="canonical" href="https://github.com/liulx20/2021/10/04/linux/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>linux | liulx</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">liulx</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">雪沫乳花浮午盏,蓼茸蒿笋试春盘。人间有味是清欢。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>留言板</a>

  </li>
        <li class="menu-item menu-item-dongtai">

    <a href="/dongtai/" rel="section"><i class="fa fa-th fa-fw"></i>动态</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vim"><span class="nav-number">2.</span> <span class="nav-text">vim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcc%E7%BC%96%E8%AF%91"><span class="nav-number">3.</span> <span class="nav-text">gcc编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E3%80%81%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">动态库、静态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb"><span class="nav-number">5.</span> <span class="nav-text">gdb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Makefile"><span class="nav-number">6.</span> <span class="nav-text">Makefile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO"><span class="nav-number">7.</span> <span class="nav-text">文件IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC"><span class="nav-number">9.</span> <span class="nav-text">IPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">10.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="nav-number">12.1.</span> <span class="nav-text">线程控制原语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">13.</span> <span class="nav-text">同步</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liulx"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">liulx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/liulx20" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liulx20"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liulex@buaa.edu.cn" title="E-Mail → mailto:liulex@buaa.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liulx20/2021/10/04/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="liulx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liulx">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-04 14:04:05" itemprop="dateCreated datePublished" datetime="2021-10-04T14:04:05+08:00">2021-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-07 14:35:10" itemprop="dateModified" datetime="2021-11-07T14:35:10+08:00">2021-11-07</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="far fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/04/linux/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/04/linux/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Linux 系统目录</p>
<ul>
<li>bin 二进制可执行文件</li>
<li>boot 开机启动程序</li>
<li>dev 设备文件</li>
<li>home 普通用户</li>
<li>etc:用户信息和系统配置文件 password group</li>
<li>lib 库文件</li>
<li>root 管理员宿主目录</li>
<li>usr用户资源目录</li>
</ul>
<p>文件类型：</p>
<ul>
<li>普通文件 -</li>
<li>目录文件 d</li>
<li>字符设备文件 c</li>
<li>块设备文件 b</li>
<li>软连接 l</li>
<li>管道文件 p</li>
<li>套接字 s</li>
<li>未知文件</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>which:查看指定命令所在路径</li>
<li>pwd： 查看当前所在路径</li>
<li>rmdir:删除空目录</li>
<li>rm : rm file <code>rm dir -rf</code> f强制删除</li>
<li>cp </li>
<li>mv</li>
<li>cat</li>
<li>tac</li>
</ul>
<p>软连接：快捷方式</p>
<p><code>ln -s file file.s</code>创建软连接</p>
<p>为保证软连接可以随意移动，需保证用绝对路径创建</p>
<p>硬链接：</p>
<p><code>ln file file.h</code>增加硬链接文件计数，共享Inode</p>
<ul>
<li><p>whoami</p>
<p><code>sudo su</code>切换root用户</p>
</li>
<li><p>chmod </p>
<p><code>chmod u+x a.c</code>给所有者添加可执行权限</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u表示用户</span><br><span class="line">g表示同组用户</span><br><span class="line">o表示其他用户</span><br><span class="line"><span class="keyword">a</span>表示所有用户</span><br></pre></td></tr></table></figure>
<p>rwx r:4 w:2 x:1</p>
<p><code>chmod 471 a.c</code></p>
</li>
<li><p>chown</p>
<p><code>sudo chown new_user a.c</code>更改文件所有者</p>
</li>
<li><p>adduser</p>
<p>sudo adduser 新用户名</p>
</li>
<li><p>addgroup 创建用户组</p>
<p><code>sudo addgroup g88</code></p>
</li>
<li><p>chgrp</p>
<p><code>sudo chgrp g88 a.c</code></p>
<p><code>sudo chown nobody:nogroup a.c</code>同时修改用户和用户组</p>
</li>
<li><p>deluser</p>
<p><code>sudo deluser wangwu</code></p>
</li>
<li><p>find</p>
</li>
</ul>
<p><code>find ./ -type &#39;l&#39;</code>查找当前目录下软连接</p>
<p><code>find ./ -name &#39;*.jpg&#39;</code>按文件名搜索</p>
<p><code>find ./ -maxdepth 1 - name &#39;*.jpg&#39;</code>指定搜索层级</p>
<p><code>find ./ -size +20M -size -50M</code>文件大小</p>
<p><code>-atime -mtime -ctime</code></p>
<p><code>find ./ -ctime 1</code> 当天内修改过</p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -exec ls -l &#123;&#125; \;</code></p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -ok rm -r &#123;&#125; \;</code></p>
<ul>
<li><p>grep 找文件内容</p>
<p><code>grep -r &#39;copy&#39; ./ -n</code> -n显示行号</p>
</li>
<li><p>ps</p>
<p><code>ps aux</code> </p>
<p><code>ps aux |grep &#39;kernel&#39;</code></p>
</li>
</ul>
<p>find ./ -type f | xargs ls -l </p>
<p>-xargs :将find搜索的结果集执行某一命令，当结果集数量过大时，可以分片映射</p>
<p>-print0:</p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -print0 | xargs print0 ls -l</code></p>
<p>awk 按列拆分，sed按行拆分</p>
<ul>
<li>软件安装：</li>
</ul>
<p><code>sudo apt-get update</code>更新软件源列表</p>
<p>卸载<code>sudo apt-get remove</code></p>
<p>安装deb文件</p>
<p>sudo dpkg -i xx.deb</p>
<p>源码安装：</p>
<p>   1.解压缩代码包</p>
<ol>
<li><p>cd dir</p>
</li>
<li><p>./configure</p>
<p>检测文件是否缺失，创建makefile，检测编译环境</p>
</li>
<li><p>make</p>
<p>编译源码，生成库和可执行文件</p>
</li>
<li><p>sudo make install</p>
<p>把库和可执行程序安装到系统路径下</p>
</li>
<li><p>sudo make distclean</p>
<p>删除和卸载软件</p>
</li>
</ol>
<p>压缩</p>
<ul>
<li><p>tar</p>
<p><code>tar zcvf 要生成的压缩包名 压缩材料</code> z: 调用gzip, c： creat, v：显示压缩过程，可以没有，f生成文件名</p>
<p>先调用gzip 然后调用tar打包</p>
</li>
<li><p>gzip</p>
<p><code>gzip 文件名</code>压缩一个文件</p>
<p><code>gzip a.c</code> 得到a.c.gz</p>
</li>
<li><p>bzip2</p>
<p><code>tar jcvf test.tar.gz file1 dir2</code></p>
</li>
<li><p>解压，将压缩命令中的c替换为x</p>
</li>
<li><p>rar </p>
<p><code>rar a -r newdir dir</code></p>
<p>解压</p>
<p><code>unrar x rartest.rar</code></p>
</li>
</ul>
<p><code>sudo aptitude show tree</code>显示软件是否安装</p>
<ul>
<li><p>zip </p>
<p><code>zip -r dir.zip dir</code></p>
<p>解压</p>
<p>unzip dir.zip</p>
</li>
<li><p>who </p>
</li>
<li>jobs当前后台运行的作业</li>
<li>fg 前台</li>
<li>bg后台</li>
<li>kill</li>
<li>env 环境变量</li>
<li>top 任务管理器</li>
</ul>
<p>设置密码</p>
<p>sudo passwd 用户名</p>
<p>切换用户</p>
<p>su 用户名</p>
<ul>
<li>ifconfig 查看ip地址</li>
<li>man 查看手册</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.可执行程序或<span class="keyword">shell</span><span class="bash">命令</span></span><br><span class="line"><span class="number">2</span>.系统调用</span><br><span class="line"><span class="number">3</span>.库调用</span><br><span class="line"><span class="number">5</span>.文件格式、规范</span><br><span class="line"><span class="number">9</span>.内核例程</span><br></pre></td></tr></table></figure>
<ul>
<li>alias 起别名</li>
<li>unmask 指定用户创建文件时的掩码</li>
<li>创建终端Ctrl+Shift +t</li>
<li>切换标签Alt+n</li>
<li>新开终端Ctrl+Shift + n</li>
</ul>
<p>光标移动到第一个字符contrl+a</p>
<p>移动到最后一个字符contrl+e</p>
<p>清空输入control+u</p>
<p>空目录大小4096</p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><ul>
<li><p>命令模式i a o,I A O,s S切换到文本模式,:切换到末行模式，zz保存退出</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i:</span>插入光标前一个字符</span><br><span class="line"><span class="symbol">I:</span>插入行首</span><br><span class="line"><span class="symbol">a:</span>插入光标后一个字符</span><br><span class="line"><span class="symbol">A:</span>插入行末</span><br><span class="line"><span class="symbol">o:</span>向下新开一行，插入行首</span><br><span class="line"><span class="symbol">O:</span>向上新开一行，插入行首</span><br><span class="line"><span class="symbol">s:</span>删除当前字符，插入</span><br><span class="line"><span class="symbol">S:</span>删除当前行，插入</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>文本模式ESC切换到文本模式</p>
</li>
<li><p>末行模式w:保存 q:退出，两次ESC回到命令模式</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">h：左移</span><br><span class="line"><span class="symbol">j:</span>下移</span><br><span class="line"><span class="symbol">k:</span>上移</span><br><span class="line"><span class="symbol">l:</span>右移</span><br><span class="line"></span><br><span class="line">跳转到指定行</span><br><span class="line"><span class="number">1</span>.88G(命令模式)</span><br><span class="line"><span class="number">2</span>.<span class="symbol">:</span><span class="number">88</span>(末行模式)</span><br><span class="line"></span><br><span class="line">跳转文件首：</span><br><span class="line">gg(命令模式)</span><br><span class="line"></span><br><span class="line">跳转文件尾</span><br><span class="line">G(命令模式)</span><br><span class="line"></span><br><span class="line">自动格式化程序：</span><br><span class="line">gg=G(命令模式)</span><br><span class="line"></span><br><span class="line">括号对应：</span><br><span class="line"><span class="string">%(命令模式)</span></span><br><span class="line"></span><br><span class="line">删除单个字符</span><br><span class="line">x(命令模式)</span><br><span class="line"></span><br><span class="line">删除单词</span><br><span class="line">dw(光标置于首字母)</span><br><span class="line"></span><br><span class="line">删除光标至行尾</span><br><span class="line">D或d$</span><br><span class="line"></span><br><span class="line">删除光标到行首</span><br><span class="line">d0</span><br><span class="line"></span><br><span class="line">光标移至行首</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">光标移至行尾</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">替换单个字符</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line">删除指定区域：</span><br><span class="line">按v切换为可视模式，使用hjkl来选中待删除区域，按d删除该区域数据</span><br><span class="line"></span><br><span class="line">删除指定行</span><br><span class="line">dd</span><br><span class="line"></span><br><span class="line">删除指定N行</span><br><span class="line">ndd</span><br><span class="line"></span><br><span class="line">粘贴<span class="symbol">:</span></span><br><span class="line">p粘至光标所在下一行</span><br><span class="line">P粘在光标所在上一行</span><br><span class="line"></span><br><span class="line">复制一行：</span><br><span class="line">yy</span><br><span class="line"></span><br><span class="line">复制多行：</span><br><span class="line">nyy</span><br><span class="line"></span><br><span class="line">查找</span><br><span class="line"><span class="number">1</span>.找设想内容</span><br><span class="line">命令模式下，按“/”输入欲搜索关键字，回车，使用n检索下一个</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.找 看到的内容</span><br><span class="line">将光标置于任意一个字符上，按“*、<span class="comment">#”查找</span></span><br><span class="line"></span><br><span class="line">单行替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:s</span> /源字符串/替换字符串</span><br><span class="line"></span><br><span class="line">通篇替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:%s</span> /源字符串/替换字符串 只替换每一行首个</span><br><span class="line"><span class="symbol">:%s</span> /源字符串/替换字符串/g 替换所有</span><br><span class="line"></span><br><span class="line">指定行替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:</span>起始行号，终止行号s /源字符串/替换字符串/g </span><br><span class="line"></span><br><span class="line">撤销：</span><br><span class="line">u</span><br><span class="line"></span><br><span class="line">反撤销：</span><br><span class="line">Ctrl + r</span><br><span class="line"></span><br><span class="line">分屏</span><br><span class="line"><span class="symbol">:sp</span> 横屏分 Ctrl + ww切换</span><br><span class="line"><span class="symbol">:vsp</span> 竖屏分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">跳转至man手册</span><br><span class="line">将光标置于待查看函数单词，使用K跳转，(指定卷：nK</span><br><span class="line"></span><br><span class="line">查看宏定义</span><br><span class="line">将光标置于待查看宏定义单词，[ d</span><br><span class="line"></span><br><span class="line">末行模式<span class="symbol">:</span>! 执行shell 命令</span><br></pre></td></tr></table></figure>
<p>配置vim</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="string">/etc/vim/vimrc</span></span><br><span class="line">2. ~<span class="string">/.vimrc</span></span><br><span class="line">~<span class="string">./vimrc</span>优先级高</span><br></pre></td></tr></table></figure>
<h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><p>预处理 gcc -E 展开宏、头文件，替换条件编译，删除注释、空白，空行</p>
<p>编译 gcc -S 检查语法规范 编译消耗时间最多</p>
<p>汇编：gcc -c将汇编指令翻译成机器指令</p>
<p>链接：无参数 数据段合并，地址回填</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-I 指定头文件</span></span><br><span class="line">头文件与.c文件不在同一目录</span><br><span class="line">gcc -I ./inc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="deletion">-c 只做预处理、编译、汇编</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-g: 编译时添加调试信息</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-On （n = 0-3） 编译优化</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-Wall 提示更多警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-D&lt;DEF&gt; 编译时定义宏</span></span><br><span class="line">gcc hello.c -D HELLO</span><br></pre></td></tr></table></figure>
<h3 id="动态库、静态库"><a href="#动态库、静态库" class="headerlink" title="动态库、静态库"></a>动态库、静态库</h3><p>提高编译效率</p>
<p>静态库：对空间要求较低，对时间要求较高的核心程序</p>
<p>动态库：对时间要求较低，对空间要求较高</p>
<p>只做静态库的方法：静态库lib开头 .a结尾</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ar</span> <span class="selector-tag">rcs</span> <span class="selector-tag">libmylib</span><span class="selector-class">.a</span> <span class="selector-tag">file1</span><span class="selector-class">.o</span>（得先编译成<span class="selector-class">.o</span>文件)</span><br></pre></td></tr></table></figure>
<p>1.将.c生成.o文件</p>
<p>gcc -c add.c -o add.o</p>
<p>2.使用ar工具制做静态库</p>
<p>ar rcs libmymath.a add.o sub.o</p>
<p>编译错误会有行号信息，链接错误没有行号，显示ld returned 1 exit status</p>
<p>3.使用静态库：</p>
<p><code>gcc test.c libmathlib.a -o test</code></p>
<p><code>gcc test.c ./lib/libmath.a -o a.out -I ./inc</code></p>
<p>lib 存放.a文件</p>
<p>inc 存放相应头文件,必须有相应头文件，记录函数声明信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防卫式声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MYMATH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MYMATH_H_</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div1</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>动态库制作</p>
<p>1、将.c生成.o文件（生成与位置无关的代码 -fPIC）</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span> -o <span class="keyword">add</span>.o -fPIC</span><br></pre></td></tr></table></figure>
<p>2.使用gcc -shared 制作动态库</p>
<p>gcc -shared -o lib库名.so add.o sub.o div.o</p>
<p>3.编译可执行程序时，指定所使用的动态库，-l指定库名，-L指定库路径</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o a.<span class="keyword">out</span> -lmymath -L ./<span class="class"><span class="keyword">lib</span> -<span class="title">I</span> ./<span class="title">inc</span></span></span><br></pre></td></tr></table></figure>
<p>4.运行可执行程序出错</p>
<p>原因：</p>
<p>链接器：工作于链接阶段，工作时需要-l,和-L</p>
<p>动态链接器：工作于程序运行阶段，工作时需提供动态库所在的目录地址</p>
<p>1.通过环境变量设置<code>export LD_LIBRARY_PATH = 动态库路径</code> 临时生效，重启终端环境变量失效 环境变量只与进程有关</p>
<p>2.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">永久生效</span><br><span class="line">1）</span><br><span class="line">vi ~/.bashrc//改变bash环境变量</span><br><span class="line">2）写入 <span class="built_in">export</span> LD_LIBRARY_PATH= 动态库路径 保存</span><br><span class="line">3）使环境变量生效</span><br><span class="line">. .bashrc 或者 <span class="built_in">source</span> .bashrc 或者 重启终端</span><br></pre></td></tr></table></figure>
<p><code>ldd a.out</code> 查看a.out 加载哪些动态库，及动态库路径</p>
<p>3.直接把动态库放到与标准c库一起，</p>
<p> <code>cp libmymath.so /lib</code></p>
<ol>
<li><p>配置文件法</p>
<p>1）sudo vi /etc/ld.so.conf</p>
<p>2）写入动态库绝对路径 保存</p>
<p>3） sudo ldconfig -v 使配置文件生效</p>
<p>ldd a.out 查看，失败not found</p>
</li>
</ol>
<p>数据段合并</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20211004203908020.png" alt="image-20211004203908020"></p>
<p>连接时会把.text段和.rodata段合并,.data段和.bss段合并，节省空间</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>-g 使用该参数编译可执行程序</p>
<p>gdb a.out</p>
<p>基础指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>: <span class="built_in">list</span> <span class="number">1</span> <span class="comment">//列出源码。根据源码指定行号设置断点</span></span><br><span class="line">b <span class="number">52</span> <span class="comment">//break 在52行设置断点</span></span><br><span class="line">run/r <span class="comment">//run</span></span><br><span class="line">n/next <span class="comment">//next,下一条指令，如果当前断点是函数则不进入函数</span></span><br><span class="line">s/step <span class="comment">//step，下一条指令，进入函数</span></span><br><span class="line">p/print :p i<span class="comment">//print i</span></span><br><span class="line"><span class="keyword">continue</span>: 继续执行断点后续指令</span><br><span class="line">quit: 退出gdb当前调试</span><br></pre></td></tr></table></figure>
<p>其他指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用run查找段错误位置</span><br><span class="line">finish 结束当前函数调用，回到调用点</span><br><span class="line">start 启动调试</span><br><span class="line">    </span><br><span class="line"><span class="built_in">set</span> args 设置命令行参数</span><br><span class="line">run 后面也能加命令行参数</span><br><span class="line">run argv[<span class="number">1</span>] argv[<span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">info b 断点信息表</span><br><span class="line">    </span><br><span class="line">b <span class="number">41</span> <span class="keyword">if</span> i = <span class="number">4</span> <span class="comment">//条件断点</span></span><br><span class="line">    </span><br><span class="line">ptype j <span class="comment">//查看变量类型</span></span><br><span class="line">    </span><br><span class="line">bt/backtrace 查看栈帧信息</span><br><span class="line"></span><br><span class="line">frame <span class="number">1</span> 切换栈帧</span><br><span class="line">    </span><br><span class="line">display i <span class="comment">//设置追踪i</span></span><br><span class="line"></span><br><span class="line">undisplay 编号<span class="comment">//取消跟踪变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> 删除断点</span><br></pre></td></tr></table></figure>
<p>栈帧：随着函数调用而在stack上开辟的一片内存空间，用于存放函数调用而产生的局部变量和临时值</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><ul>
<li><p>1个规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖条件</span><br><span class="line">	（一个tab缩进）命令</span><br><span class="line"><span class="section">test: test.c</span></span><br><span class="line">	gcc -o test test.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.o</span></span><br><span class="line">	gcc hello.o -o hello</span><br><span class="line">	 </span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o </span><br></pre></td></tr></table></figure>
<p>all:指定makefile的终极目标</p>
</li>
</ul>
<p>1、目标的时间必须晚于依赖条件的时间，否则，更新目录</p>
<p>2、依赖条件不存在，找寻新的规则去产生依赖</p>
<ul>
<li><p>2个函数</p>
<p>wildcard </p>
<p>patsubst</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#找到当前目录所有后缀为.c的文件赋值给src,将文件名组成列表赋值给变量src</span></span><br><span class="line"></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c %.o <span class="variable">$(src)</span>)</span></span><br><span class="line"><span class="comment">#将参数3中，包含参数1的部分，替换为参数2</span></span><br><span class="line"><span class="comment">#把src变量里所有后缀为.c的文件替换为.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:#(没有依赖)</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out <span class="comment">#-rm 出错依然执行</span></span><br></pre></td></tr></table></figure>
<p>make clean -n//尝试执行，但不真正执行</p>
</li>
</ul>
<ul>
<li>3个自动变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span>:在规则的命令中表示规则中的目标</span><br><span class="line"><span class="variable">$&lt;</span>：在规则的命令中，表示第一个依赖条件,如果将该变量应用在模式规则中，它可将依赖列表中的依赖依次取出，套用规则</span><br><span class="line"><span class="variable">$^</span>：在规则的命令中，表示所有依赖条件</span><br><span class="line"></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span><span class="comment"># add.c sub.c hello.c</span></span><br><span class="line">obj = <span class="variable">$(subsubst %.c %.o <span class="variable">$(src)</span>)</span><span class="comment"># add.o sub.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">All:a.out</span></span><br><span class="line"></span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out</span><br></pre></td></tr></table></figure>
<p>模式规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span><span class="comment"># add.c sub.c hello.c</span></span><br><span class="line">obj = <span class="variable">$(subsubst %.c %.o <span class="variable">$(src)</span>)</span><span class="comment"># add.o sub.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">All:a.out</span></span><br><span class="line"></span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out</span><br></pre></td></tr></table></figure>
<p>静态模式规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>:%.o:%.c</span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>生成伪目标</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean ALL</span></span><br></pre></td></tr></table></figure>
<p>调加参数</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myArgs = -Wall -g</span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br></pre></td></tr></table></figure>
<p>makefile 名字为m1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f m1</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p>-n模拟执行make,make clean 命令</p>
<p>-f：指定文件执行make命令</p>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p>系统调用</p>
<ul>
<li>open 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//根据error num 返回错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags)</span></span>;<span class="comment">//O_RDONLY O_WRONLY ORDWR O_CREAT O_APPEND O_EXCL（检查文件是否存在） O_TRUNC（把文件清零） O_NONBLOCK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags,<span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//不是C语言支持重载，而是open支持可变参数</span></span><br><span class="line"><span class="comment">//返回新的文件描述符，错误返回-1，并设置errno</span></span><br><span class="line"><span class="comment">//mode_t 8进制整数 读写执行权限，需要创建时指定，同时权限受unmask限制 mode&amp;~unmask</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> count)</span></span>;<span class="comment">//count缓冲区大小</span></span><br><span class="line"><span class="comment">//成功返回读取得到的字节数,失败返回-1</span></span><br><span class="line"><span class="comment">//-1 并且errno = EAGIN 或EWOULDBLOCK说明不是read失败，而是read在以非阻塞方式读一个设备文件(网络文件），并且文件无数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> count)</span></span>;<span class="comment">//count实际写出内容的大小</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open argv1 error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open argv2 error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((n = read(fd1,buf,<span class="number">1024</span>))!= <span class="number">0</span>)&#123;</span><br><span class="line">        write(fd2,buf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>strace 跟踪程序运行时所进行的系统调用</p>
<p>系统缓冲区</p>
<p>read write无缓冲IO</p>
<p>预读入缓输出</p>
<ul>
<li><p>文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stdin</span> <span class="number">0</span> STDIN_FILENO</span><br><span class="line"><span class="built_in">stdout</span> <span class="number">1</span> STDOUT_FILENO</span><br><span class="line"><span class="built_in">stderr</span> <span class="number">2</span> STDERR_FILENO</span><br></pre></td></tr></table></figure>
<p>最多1024个，新建文件描述符是目前进程最小可用的描述符</p>
</li>
<li><p>阻塞、非阻塞:</p>
<p>阻塞是设备文件、网络文件的属性</p>
<p>读常规文件是不会阻塞的</p>
<p>产生阻塞的场景：读设备文件，读网络文件</p>
<p>/dev/tty —终端文件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> fd,n;</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    tryagain:</span><br><span class="line">        n = read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EAGAIN)&#123;</span><br><span class="line">                perror(<span class="string">&quot;read STDIN_FILENO&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                write(STDOUT_FILENO,<span class="string">&quot;try again\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>));</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">goto</span> tryagain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fcntl函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,...<span class="comment">/*arg*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> flags,n;</span><br><span class="line">    flags = fcntl(STDIN_FILE,F_GETFL);<span class="comment">//获取stdin属性信息</span></span><br><span class="line">    <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(STDIN_FILENO,FSETFL,flags);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取文件状态 F_GETFL</p>
<p>设置文件状态 F_SETFL</p>
<ul>
<li><p>lseek</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">whence <span class="comment">//SEEK_SET SEEK_SET SEEK_END</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>文件读写使用同一偏移位置</p>
</li>
<li><p>使用lseek获取、</p>
</li>
<li>拓展文件大小，要使文件大小真正发生变化，需要发生IO操作 </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trunate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;<span class="comment">//拓展一个现有文件大小</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>od -tcx filename 查看文件的16进制表示</p>
<p>od -tcd filename 查看文件的10进制表示</p>
<ul>
<li><p>传入参数</p>
<p>1.指针作为函数参数</p>
<p>2.const 修饰</p>
<p>3.指针指向有效区域，在函数内部做读入操作</p>
</li>
<li><p>传出参数</p>
<p>1.指针作为函数参数</p>
<p>2.指针指向的空间可以无意义，但有效</p>
<p>3.函数对其进行写操作</p>
<p>4.函数调用后，充当返回值</p>
</li>
<li><p>传入传出参数</p>
<p>1.指针作为函数参数</p>
<p>2.在函数调用前，指针指向的空间有意义</p>
<p>3.在函数内部，先读后写</p>
<p>4.函数调用结束后，充当函数返回值</p>
</li>
</ul>
<ul>
<li><p>inode 本质为结构体，存储文件属性信息</p>
</li>
<li><p>dentry 目录项： 文件名、inode号 硬链接，相同inode,不同dentry</p>
</li>
<li><p>stat 获取文件属性 (从inode中获取)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,struct stat * buf)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    path:文件路径</span><br><span class="line">     buf:传出参数，存放文件属性</span><br><span class="line">获取文件大小： buf.st_size</span><br><span class="line">获取文件类型： buf.st_mode</span><br><span class="line">获取文件权限： buf.st_mode</span><br></pre></td></tr></table></figure>
<p>stat符号穿透，stat检查符号链接时，直接获取符号链接引用的真正文件信息</p>
<p>lstat不会进行符号穿透</p>
<p>vim,cat会穿透符号链接，ls -l 不会</p>
</li>
<li><p>link 函数：创建硬链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>unlink 函数:删除一个文件的目录项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>unlink :如果文件硬链接数到0了，但该文件仍不会马上释放，需等到所有打开该文件的进程关闭</p>
</li>
<li><p>symlink创建符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> * newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<p>readlink读软连接本身</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readlink t.soft</span><br></pre></td></tr></table></figure></li>
<li><p>readlink</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path,<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>rename</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> * newpath)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>getcwd:获取工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>chdir：改变工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文件权限</p>
<p>r:目录可以被浏览</p>
<p>w:创建删除修改文件</p>
<p>x:可以被进入</p>
</li>
<li><p>opendir函数 库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR*<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>closedir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>readdir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR*dirp)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    close(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span> * name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readdir</span><span class="params">(<span class="keyword">char</span> *dir)</span></span>&#123;</span><br><span class="line">    DIR *dp = opendir(dir);</span><br><span class="line">    <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp))!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sdp-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(name,<span class="string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);</span><br><span class="line">        isFile(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span> * name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    ret = stat(name, &amp;sb);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;</span><br><span class="line">        readdir(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%ld\n&quot;</span>,name,sb.st_size);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;</span><br><span class="line">        isFile(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> isFile(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>dup</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line">oldfd:已有文件描述符</span><br><span class="line">newfd:新文件描述符</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd,<span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">把旧的复制给新的，返回newfd</span><br><span class="line">newfd指向和oldfd一致</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">0</span>);<span class="comment">//0被占用，fcnt使用文件描述符表最小可用文件描述符返回</span></span><br><span class="line"><span class="keyword">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">7</span>);<span class="comment">//7未被占用，可以被使用</span></span><br></pre></td></tr></table></figure>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进程：占用内存、cpu等系统资源</p>
</li>
<li><p>PCB</p>
<p>进程id</p>
<p>进程状态：就绪，运行，挂起，停止</p>
<p>进程切换时需要保存和恢复的一些寄存器值</p>
<p>描述虚拟地址空间信息</p>
<p>描述控制终端的信息</p>
<p>当前工作位置</p>
<p>文件描述符表</p>
<p>和信号相关信息</p>
<p>用户id和组id</p>
<p>会话和进程组</p>
<p>进程可以使用的资源上限</p>
</li>
</ul>
<ul>
<li>环境变量</li>
</ul>
<p>PATH SHELL TERM LANG HOME <code>echo $PATH</code></p>
<ul>
<li><p>进程控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>进程共享</p>
<p>刚发生父子进程fork之后</p>
<p>全局变量，.data,.text,栈，堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式相同</p>
<p>不同：</p>
<p>进程id,fork返回值，父进程id，进程运行时间，闹钟（定时器），未决信号集</p>
<p>读时共享，写时复制</p>
<p>父子进程共享 文件描述符，mmap映射区</p>
</li>
<li><p>gdb调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child 跟踪子进程</span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br></pre></td></tr></table></figure></li>
<li><p>exec函数族</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程id不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> * arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>execlp，加载一个进程，借助PATH环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span><span class="comment">/*相当于argv[0],没啥用*/</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//只有execlp出错时才返回-1，否则之后代码不再执行</span></span><br><span class="line">perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;./a.out&quot;</span>,<span class="string">&quot;./a.out&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  只有execve是系统调用</p>
<ul>
<li><p>孤儿进程</p>
<p>父进程先于子进程结束，子进程的父进程将成为init进程</p>
</li>
<li><p>僵尸进程</p>
<p>进程终止，父进程尚未收回，子进程残留资源（PCB)存放于内核中，变为僵尸进程</p>
</li>
<li><p>wait函数（waitpid(-1,&amp;status,0);)</p>
<p>阻塞等待子进程退出</p>
<p>回收子进程残留资源</p>
<p>获取子进程结束状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> the child terminated normally</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">    <span class="keyword">return</span> the <span class="built_in">exit</span> status of the child</span><br><span class="line">WIFSIGNALED(status)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> the child process was terminated by a signal</span><br><span class="line">WTERMSIG(status)</span><br><span class="line">       <span class="keyword">return</span> the number of the signal that caused the child process to <span class="built_in">terminate</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
<li><p>waitpid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options)</span></span>;<span class="comment">//一次wait/waitpid函数调用，只能回收一个子进程</span></span><br><span class="line">正常回收返回pid</span><br><span class="line">如果设置WNOHANG，子进程未结束，返回<span class="number">0</span></span><br><span class="line"><span class="number">-1</span>：失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>文件，管道，共享内存，消息队列，套接字，命名管道</p>
<p>管道（使用最简单，匿名管道只能用于有血缘关系的进程之间，要共享文件描述符）</p>
<p>信号（开销小，表示信息有限）</p>
<p>共享映射区（无血缘关系）</p>
<p>本地套接字（最稳定，实现复杂度最高）</p>
<ul>
<li><p>管道</p>
<p>pipe函数创建 mkfifo 创建有名管道（伪文件不占用磁盘空间）</p>
<ol>
<li>其本质上是一个伪文件</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>规定数据从管道写段流入，从读端写出</li>
</ol>
<p>管道的原理，管道是为内核使用环形队列机制，借助内核缓冲区（4k)实现</p>
<p>局限性：自己写，不能自己读</p>
<p>​              数据不可反复读</p>
<p>​              半双工通信</p>
<p>​              只能在有血缘关系的进程之间使用</p>
<p>pipe函数：创建并打开管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line">参数:fd[<span class="number">0</span>]读端</span><br><span class="line">    fd[<span class="number">1</span>]写端</span><br><span class="line">返回：<span class="number">0</span> 成功 <span class="number">-1</span>失败</span><br></pre></td></tr></table></figure></li>
<li><p>管道的读写行为</p>
<ol>
<li><p>读管道 </p>
<ul>
<li><p>管道有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据</p>
<p>管道写端全部关闭，read返回0(读到文件结尾)</p>
<p>写端没有全部关闭，read阻塞等待</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道写端全部关闭，进程异常终止，SIGPIPE</p>
</li>
<li><p>管道写端没有全部关闭</p>
<p>管道已满，write阻塞</p>
<p>管道未满，write将数据写入，并返回实际写入字节数</p>
</li>
</ul>
</li>
</ol>
<p>可以有一个写端，多个读端，或者一个读端，多个写端</p>
</li>
<li><p>ulimit -a 查看打开文件个数，pipe缓存区大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>FIFO命名管道</p>
<p>解决没有关系进程之间的通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo myfifo</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文件进程通信</p>
</li>
<li><p>存储映射IO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;<span class="comment">//创建共享内存</span></span><br><span class="line">参数：</span><br><span class="line">    addr：指定映射区的首地址，通常传<span class="literal">NULL</span>,表示让系统自动分配</span><br><span class="line">    length:共享内存大小（&lt;=文件实际大小）</span><br><span class="line">    prot:共享内存映射区的读写权限 PROT_READ PROT_WRITE PROT_NONE PROT_EXEC</span><br><span class="line">    flags:标志共享内存共享属性：MAP_SHARED MAP_PRIVATE（对内存的修改不会反应到磁盘上）</span><br><span class="line">    fd:用于创建共享内存映射区的文件描述符</span><br><span class="line">    offset：默认<span class="number">0</span>，表示映射文件全部，偏移位置，必须是<span class="number">4</span>k的整数倍</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">        成功：映射区首地址</span><br><span class="line">        失败： MAP_FAILED,(<span class="keyword">void</span>*)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> munmap(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length);释放映射区</span><br><span class="line">addr:mmap返回值</span><br><span class="line">length:大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mann.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    perror(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;testmp&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lseek(fd,10,SEEK_END);</span></span><br><span class="line"><span class="comment">    write(fd,&#x27;\0&#x27;,1); //相当于ftruncate()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ftruncate(fd,<span class="number">20</span>);<span class="comment">//需要写权限</span></span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---%s\n&quot;</span>,p);</span><br><span class="line">    <span class="keyword">int</span> ret = munmap(p,len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<p>1.用于创建映射区文件大小为0，实际指定非零大小创建映射区，会造成SIGBUS</p>
<p>2.用于创建映射区文件大小为0，实际指定0大小创建映射区，invalid argument</p>
<p>3.用于创建映射区的文件读写属性为只读，实际mmap指定写，会造成invalid argument</p>
<p>4.创建映射区隐含一次read操作，需要read权限，mmap读写权限，映射区访问权限为SHARED时，应该不超过文件的open权限，文件只读open没发建立映射区</p>
<p>5.文件描述符fd在mmap创建后即可关闭，后续文件可以通过地址访问</p>
<p>6.offset必须是4k整数倍（MMU映射的最小单位为4k)</p>
<p>7.对申请的内存越界访问未定义</p>
<p>8.munmap释放的地址，必须是mmap申请的地址</p>
<p>9.映射区访问权限为私有，对内存的修改只跟内存有关，跟磁盘无关</p>
<p>10.映射区访问权限为私有，只需要open文件时有读权限，用于创建映射区即可</p>
</li>
<li><p>mmap</p>
<p>1.open(“文件名”,O_RDWR)</p>
<p>2.mmap(NULL,有效文件大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</p>
</li>
<li><p>父子间mmap通信，需设置flag为MAP_SHARED，否则父子进程各有一份映射区</p>
<p>父进程先创建映射区open（O_RDWR) mmap(MAP_SHARED)</p>
<p>指定MAP_SHARED权限</p>
<p>fork()创建子进程</p>
<p>一个进程读，一个进程写</p>
</li>
<li><p>无血缘关系进程之间mmap通信</p>
<p>两个进程打开同一个文件，创建映射区</p>
<p>指定flags为MAP_SHARED</p>
<p>一个进程写入，另一个进程读出，同一个文件mmap映射区是同一个位置</p>
<p>无血缘关系进程间通信 mmap：数据可以重复读取</p>
<p>​                                       fifo:数据只能一次读取</p>
</li>
<li><p>匿名映射：只能用于有血缘关系进程之间通信</p>
<p>使用MAP_ANONYMOUS（或者MAP_ANON)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//fd -1</span></span><br></pre></td></tr></table></figure>
<p>不支持ANONYMOUS的操作系统，可以打开/dev/zero，大小想要多大有多大</p>
<p>/dev/null</p>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>简单，不能携带大量信息，满足某个特设条件才发送</p>
<p>信号的特质：</p>
<p>信号时软件层面的中断，一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令</p>
<p>所有信号的产生和处理都是内核完成的</p>
<p>产生信号：</p>
<ol>
<li>按键产生，Ctrl+C Ctrl + Z Ctrl + \</li>
<li>系统调用产生 kill raise abort</li>
<li>软件条件产生，定时器alarm sleep借助alarm实现</li>
<li>硬件异常产生，非法访问内存（段错误）、除零，内存对齐出错（总线错误）</li>
<li>命令产生kill命令</li>
</ol>
<p>递达：递送并到达进程,直接被处理掉</p>
<p>未决：产生和抵达之间的状态，主要由于阻塞（屏蔽）导致该状态</p>
<p>信号处理方式：</p>
<p>1。执行默认动作</p>
<p>2.忽略（丢弃）</p>
<p>3.捕获（调用户处理函数）</p>
<ul>
<li><p>阻塞信号集（信号屏蔽字）：本质：位图，用来记录信号的屏蔽状态，将某些信号加入集合，对他们设置屏蔽，当屏蔽信号x后，再收到该信号，该信号的处理将推后（解除屏蔽后）</p>
</li>
<li><p>未决信号集,本质：位图，用来记录信号的处理状态</p>
<p>信号产生，未决信号集中描述该信号的位立即翻转为1，表信号处于未决状态，当信号被处理对应位翻转回0</p>
<p>信号产生后由于某些原因不能抵达（主要是阻塞），这类信号的集合称之为未决信号集，在屏蔽解除时，信号一直处于未决状态</p>
</li>
</ul>
<p>kill -l 列出所有信号</p>
<p>0-31常规信号：都有默认的处理事件和处理动作</p>
<p>34-64实时信号 ：没有默认事件</p>
<ul>
<li><p>信号4要素</p>
<p>1.编号，2.名称 3.信号对应的事件 4.默认处理动作</p>
<p>man 7 signal</p>
<p>SIGHUB 用户退出shell</p>
<p>SIGQUIT <ctrl+\></p>
<p>SIGINT <ctrl+c>终止进程</p>
<p>SIGKILL 无条件终止进程，不能被忽略，处理，阻塞</p>
<p>SIGSTOP停止进程的执行，不能忽略，处理，阻塞</p>
<p>SIGUSR1，SIGUSR2没有默认处理事件，处理动作是终止进程</p>
<p>SIGTERM, kill命令发送的信号，终止进程（不带信号编号）</p>
<p>SIGCHLD:子进程状态发生变化时，父进程接收这个信号，默认动作为忽略这个信号</p>
<p>SIGTSTP：停止中断交互进程的运行<ctrl+z></p>
</li>
<li><p>默认动作</p>
<p>Term：终止进程</p>
<p>Ign忽略信号</p>
<p>Core:终止进程，生成Core文件</p>
<p>Stop:停止（暂停）进程</p>
<p>Cont:继续运行进程</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sid)</span></span>;</span><br><span class="line">pid &gt; <span class="number">0</span> 杀死指定进程</span><br><span class="line">   = <span class="number">0</span> 杀跟调用kill函数的进程处于同一进程组的所有组员</span><br><span class="line">    &lt;<span class="number">-1</span> 取绝对值，发送信号给该绝对值所对应的进程组的所有组员</span><br><span class="line">    =<span class="number">-1</span> 发送信号给有权限的所有进程</span><br></pre></td></tr></table></figure>
<p>  ps ajx查看进程组信息</p>
<p>  kill -SIGKILL -1杀死所有有权限的进程</p>
<p>  发送者实际有效ID == 接收者实际有效ID</p>
<ul>
<li><p>其他几个发信号函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;<span class="comment">//发送信号给调用者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>alarm函数</p>
<p>设置定时器，（闹钟）指定seconds后，发送SIGALRM信号，进程接收到该信号，默认动作终止</p>
<p>每个进程有且只有唯一定时器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">返回值：无错误</span><br></pre></td></tr></table></figure>
<p>取消定时器alarm(0)返回旧闹钟剩余秒数</p>
<p>定时，与进程状态无关</p>
<p>time指令 查看程序执行的时间<code>time ./alarm</code></p>
<p>实际执行时间=系统时间+用户时间+等待时间</p>
<p>setitimer函数，可以实现周期定时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which,<span class="keyword">const</span> struct itimerval *new_value,struct itimerval *old_value)</span></span>;</span><br><span class="line">new_value 定时秒数</span><br><span class="line">old_value 传出参数，上次定时剩余时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span><span class="comment">/*next value*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span><span class="comment">/*current value*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;<span class="comment">/*seconds*/</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;<span class="comment">/*microseconds*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_t</span>;</span></span><br><span class="line"><span class="keyword">new_t</span>.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">new_t</span>.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">it_interval 用来设定两次定时任务之间的间隔时间</span><br><span class="line">it_value 定时的时长</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">which</span></span><br><span class="line"><span class="comment">自然计时：ITIMER_REAL -&gt;14)SIGLARM</span></span><br><span class="line"><span class="comment">虚拟空间计时（用户空间）ITIMER_VIRTUAL—&gt;26)SIGVTALRM 计算占用cpu时间</span></span><br><span class="line"><span class="comment">运行时计时（用户+内核）ITIMER_PROF-&gt;27)SIGPROF 计算占用cpu及执行系统调用的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">成功<span class="number">0</span>，失败<span class="number">-1</span></span><br></pre></td></tr></table></figure></li>
<li><p>信号集操作函数</p>
<p>只可以操作阻塞信号集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;<span class="comment">//typedef unsigned long sigset_t;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集清零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集置为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//删除某个信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//判断信号是否在信号集，在返回1，不在返回0</span></span><br></pre></td></tr></table></figure>
<p>sigprocmask函数</p>
<p>可以用来屏蔽信号，解除屏蔽</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> sigset*<span class="built_in">set</span>,sigset*oldset)</span></span>;<span class="comment">//成功0，失败-1</span></span><br><span class="line"><span class="built_in">set</span>传入参数，是一个位图</span><br><span class="line">oldset传出参数，保存旧的信号屏蔽集</span><br><span class="line">how参数取值：假设当前信号的屏蔽字为mask</span><br><span class="line">   SIG_BLOCK:<span class="built_in">set</span>表示需要屏蔽的信号，mask = mask|<span class="built_in">set</span></span><br><span class="line">   SIG_UNBLOCK:<span class="built_in">set</span>表示需要解除的信号，相当于mask = mask&amp;~<span class="built_in">set</span></span><br><span class="line">   SIG_SETMASK,替换原来的mask mask = <span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<p>sigpending函数</p>
<p>读取当前进程未决信号集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//set传出参数</span></span><br></pre></td></tr></table></figure></li>
<li><p>信号捕捉</p>
<p>signal函数</p>
<p>注册一个信号捕捉函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sigaction函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction*act,struct sigaction *oldact)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (*sg_sigaction)(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span> *);<span class="comment">//发送信号携带复杂信息</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;<span class="comment">//只工作于信号捕捉工作时间之中，绝大时候传0</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;<span class="comment">//设置参数，绝大时候传0</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);<span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>信号捕捉特性</p>
<p>1.进程正常运行时，默认PCB有一个信号屏蔽字，假定为mask，它决定了进程自动屏蔽哪些信号，当注册了某个信号捕捉函数，捕捉到该信号之后，要调用该函数，而该函数有可能执行很长时间，这期间所屏蔽的信号不由mask指定，而由sa_mask指定，调用完信号处理函数，再恢复为mask</p>
<p>2.xxx信号捕捉函数执行期间，相同信号自动被屏蔽</p>
<p>3.阻塞的常规信号不支持排队，产生多次只记录一次</p>
</li>
<li><p>内核实现信号捕捉</p>
<p>1.在执行主控制流程的某条指令时因为中断、异常或系统调用进入内核（用户态）</p>
<p>2.内核处理完异常准备回用户模式之前先处理当前进程中可以递送的信号</p>
<p>3.do_signal()如果信号的处理动作有自定义的信号处理函数则回到用户模式执行信号处理函数</p>
<p>4.信号处理函数返回时执行特殊的系统调用sigreturn再次进入内核（用户态）函数调用之后需要返回调用者</p>
<p>5.sys_sigreturn()返回用户模式，从主控制流程中上次被中断的地方继续向下执行</p>
</li>
<li><p>SIGCHID产生条件</p>
<p>子进程终止时</p>
<p>子进程接收到SIGSTOP信号停止时</p>
<p>子进程处于停止态，接收到SIGCONT后唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt; <span class="number">0</span>)&#123;<span class="comment">//防止因为处理SIGCHID期间屏蔽SIGCHID，造成一些子进程的SIGCHID丢失导致未回收</span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(status))<span class="comment">//正常退出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d exit %d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))<span class="comment">//被信号退出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d cancel signal %d\n&quot;</span>, pid, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中断系统调用</p>
<p>1.慢速系统调用：可能会使进程永远阻塞的系统调用，如果阻塞期间收到一个信号，该系统调用就被中断，不再执行，也可设定系统调用是否重启</p>
<p>2.其他系统调用：getpid getppid fork</p>
<p>慢速系统调用被中断的相关行为，实际上就是pause行为</p>
</li>
</ul>
<p>  可修改sa_flags来设置被信号中断后系统调用是否重启SA_INTERRURT不重启，SA_RESTART重启</p>
<ul>
<li><p>会话</p>
<p>多个进程组的集合</p>
<p>setid函数</p>
<p>创建一个会话，并以自己的ID设置进程组ID，同时也是会话的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//成功返回0，失败-1并设置errno</span></span><br><span class="line">调用setid函数的进程，既是新会长，也是新组长</span><br></pre></td></tr></table></figure>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3></li>
</ul>
<p>daemon 进程，Linux后台服务进程，通常独立于控制终端，并且周期性执行某种任务，或等待某些发生的事件。通常采用以d结尾的名字</p>
<p>通常运行于操作系统后台，脱离控制终端，一般不与用户进行交互，周期性等待某个事件发生或者周期性执行某一动作</p>
<p>不受用户登录注销影响，通常采用以d结尾的命名方式</p>
<p>创建守护进程：</p>
<ul>
<li><p>创建子进程，父进程退出</p>
<p>所有工作在子进程中进行，形式上脱离了控制终端</p>
</li>
<li><p>在子进程中创建会话</p>
<p>setsid()函数</p>
<p>使子进程完全独立出来，脱离控制</p>
</li>
<li><p>改变当前目录为根目录</p>
<p>chdir()函数</p>
<p>防止占用可卸载文件系统</p>
<p>也可换成其他路径</p>
</li>
<li><p>重设文件权限掩码</p>
<p>umask()函数</p>
<p>防止继承的文件创建屏蔽字拒绝某些权限</p>
<p>增加守护进程灵活性</p>
</li>
<li><p>关闭/重定向文件描述符</p>
<p>0，1，2，继承打开文件不会用到，浪费系统资源，无法卸载</p>
</li>
<li><p>开始执行守护进程核心工作，守护进程退出处理程序模型</p>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程:独立地址空间，拥有PCB，最小资源分配单位</p>
<p>线程：有独立PCB，但没有独立地址空间，最小执行单位</p>
<p>ps -Lf pid —&gt;线程号</p>
<p>页目录（首地址在PCB中），页表，页面</p>
<ul>
<li>轻量级进程，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li>
<li>从内核看线程和进程一样的，但PCB所指的三级页表相同</li>
<li>进程可以蜕变成线程</li>
<li>线程可以看成是寄存器和栈的集合</li>
<li>在linux下，线程是最小的执行单位，晋城市最先的资源分配单位</li>
</ul>
<p>线程共享资源</p>
<ul>
<li>文件描述符表</li>
<li>每个信号处理方式</li>
<li>当前工作目录</li>
<li>用户id,组id</li>
<li>内存地址空间</li>
</ul>
<p>线程非共享资源</p>
<ul>
<li>线程id</li>
<li>处理器现场和栈指针（内核栈）</li>
<li>独立的栈空间</li>
<li>errno变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<p>线程优缺点：</p>
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信，共享数据方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>库函数，不稳定</li>
<li>调试，编写困难，gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<h4 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h4><ul>
<li>pthread_self函数</li>
</ul>
<p>获取线程id,其作用对应进程的getpid()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">线程ID：<span class="keyword">pthread_t</span>类型，本质在linux下为无符号整型，其它系统有可能是结构体</span><br><span class="line">线程ID是进程内部识别标志，(两个进程间可以有线程ID相同)</span><br><span class="line">线程号：标识线程身份，交给CPU选择调度时间</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_create</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;<span class="comment">//成功返回0，失败返回错误号</span></span><br><span class="line">thread 传出参数，新创建线程的子线程id</span><br><span class="line">attr 线程属性,<span class="literal">NULL</span>表示默认参数</span><br><span class="line">start_routine 回调函数</span><br><span class="line">arg 回调函数所需要的参数</span><br><span class="line">传参采用值传递，借助强转</span><br><span class="line">(<span class="keyword">void</span>*)i<span class="comment">//不可是(void*)&amp;i</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_exit</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;<span class="comment">//将当前线程退出</span></span><br><span class="line">retval 退出值，无退出值时，<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>pthread_join函数</p>
<p>阻塞等待线程退出，获取线程退出状态，对应进程中的waitpid()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span> ** retval)</span></span>;成功<span class="number">0</span>，失败错误号</span><br><span class="line">thread 线程ID</span><br><span class="line">retval记录线程结束状态</span><br></pre></td></tr></table></figure></li>
<li><p>pthread_cancel函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  杀死线程,cancel杀死进程需要到达一个取消点(保存点)（系统调用</p>
<p>  子线程没发生系统调用，须要子线程自己添加取消点</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_testcancel();</span><br></pre></td></tr></table></figure>
<p>  如果子线程没有到达取消点，那么pthread_cancel()无效</p>
<p>  被pthread_cancel()杀死的线程返回-1，使用pthread_join回收</p>
<ul>
<li><p>pthread_detach 函数</p>
<p>线程分离</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;<span class="comment">//成功0，失败错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离之后资源由操作系统自动回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程失败打印错误,perror没用</span></span><br><span class="line">strerror(ret);</span><br><span class="line">检查出错返回</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;xxx error %s\n&quot;</span>,stderror(ret));</span><br></pre></td></tr></table></figure>
<p>线程控制原语：thread_create()  thread_self()   pthread_exit()   pthread_join()  pthread_cacel() pthread_detach()</p>
<p>进程控制原语：fork()                    gepid()             exit() //return    wait()/waitpid() kill()</p>
</li>
<li><p>线程属性初始化</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr)</span></span>;<span class="comment">//成功0，失败：错误号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr)</span></span>;<span class="comment">//成功0，失败：错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离状态的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">int</span>* detachstate)</span></span>;</span><br><span class="line">attr:已初始化的线程属性</span><br><span class="line">detachstate： PTHREAD_CREATE_DETACHED（分离线程）</span><br><span class="line">              PTHREAD_CREATE_JOINABLE(非分离线程)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><p>线程使用注意事项</p>
<ul>
<li><p>主线程退出其他线程不退出，主线程应调用pthread_exit</p>
</li>
<li><p>避免僵尸进程</p>
<p>pthread_join</p>
<p>pthread_detach</p>
<p>pthread_create 指定分离属性</p>
<p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收栈中的值</p>
</li>
<li><p>malloc和mmap申请的内存可以被其他线程释放</p>
</li>
<li><p>应避免在对多线程模型中调用fork，除非马上exec，子进程只有调用fork的线程存在，其他线程在子进程中均pthread_exit</p>
</li>
<li><p>信号的复杂语义很难与多线程并存，应避免使用信号机制</p>
</li>
</ul>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>线程同步：协同步调，按照预定的先后次序运行</p>
<p>线程同步：指一个线程发出某一个功能调用时，在没有得到结果之前，该调用不返回，同时其他线程为保证数据一致性，不能调用该功能。</p>
<p>锁：建议锁，对公共数据的访问，所有线程应该在访问公共数据前先拿锁再访问，但锁不具有强制性（互斥量）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init()</span><br><span class="line">pthread_mutex_mutex_destory()</span><br><span class="line">pthread_mutex_lock()</span><br><span class="line">pthread_mutex_trylock()</span><br><span class="line">pthread_mutex_unlock()</span><br><span class="line">返回值：成功<span class="number">0</span>，失败返回错误号</span><br><span class="line"><span class="keyword">pthread_mutex_t</span>类型，本质是一个结构体</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;变量值只有<span class="number">0</span>，<span class="number">1</span>两种</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;<span class="comment">//restrict本指针指向的内存写操作只能由mutex完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>尽量保证锁的粒度越小越好。</p>
<p>互斥锁，初值为1</p>
<p>加锁 —操作，阻塞线程</p>
<p>解锁++操作，唤醒阻塞在锁上的线程</p>
<p>try锁，尝试加锁，成功—，失败返回，同时设置错误号EBUSY</p>
<ul>
<li><p>死锁:使用锁不恰当导致的现象：</p>
<p>1.对一个锁反复lock</p>
<p>2.两个线程各持有一把锁，请求对方持有的锁</p>
</li>
<li><p>读写锁</p>
<ul>
<li><p>锁只有一把，以读方式加锁，读锁，以写方式加锁，写锁</p>
</li>
<li><p>读共享，写独占</p>
</li>
<li>写锁优先级高</li>
</ul>
<p>读写锁是写模式加锁时，解锁前，所有对该锁的加锁线程都会被阻塞</p>
<p>读写锁是读模式加锁时，如果线程以读模式对其加锁会成功，如果以写模式加锁会阻塞</p>
<p>读写锁是读模式加锁时，同时有以读、写模式加锁的线程请求，会先满足写请求，致使所有线程阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init</span><br><span class="line">pthread_rwlock_destory</span><br><span class="line">pthread_rwlock_rdlock</span><br><span class="line">pthread_rwlock_wrlock</span><br><span class="line">pthread_rwlock_tryrdlock</span><br><span class="line">pthread_rwlock_trywrlock</span><br><span class="line">pthread_rwlock_unlock</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> 类型，用于定义一个读写锁变量</span><br></pre></td></tr></table></figure>
<p>相较于互斥量而言，当读线程多时，提高访问效率</p>
</li>
<li><p>条件变量</p>
<p>条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用，给多线程提供一个会和的场所</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init函数</span><br><span class="line">pthread_cond_destory</span><br><span class="line">pthread_cond_wait</span><br><span class="line">pthread_cond_timewait</span><br><span class="line">pthread_cond_signal</span><br><span class="line">pthread_cond_broadcast</span><br><span class="line">    </span><br><span class="line"><span class="keyword">pthread_cont_t</span>类型，用于定义条件变量</span><br><span class="line"><span class="keyword">pthread_cont_t</span> cond = PTHREAD_COND_INITIALIZER;<span class="comment">//静态初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>pthread_cond_wait函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span>*<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数作用：</p>
<ul>
<li>阻塞等待条件变量cond满足</li>
<li>释放已掌握的互斥锁，解除互斥量（1，2两步为一个原子操作）<code>pthread_mutex_unlock(&amp;mutex)</code></li>
<li>当被唤醒，pthread_cond_wait返回时，解除阻塞并重新申请获得互斥锁<code>pthread_mutex_lock(&amp;mutex)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>生产者消费者模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cond不满足)&#123;</span><br><span class="line">   pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>信号量</p>
<p>相当于初始化值为N的互斥量</p>
<p>可应用于进程、线程之间同步</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">sem_init</span><br><span class="line">sem_destory</span><br><span class="line">sem_wait<span class="comment">//加锁</span></span><br><span class="line">sem_trywait</span><br><span class="line">sem_timewait</span><br><span class="line">sem_post<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> 本质上是结构体</span><br><span class="line"><span class="keyword">sem_t</span> sem;<span class="comment">//规定信号量sem不能小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>*sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">//pshared 0 线程间同步</span></span><br><span class="line">          <span class="number">1</span> 进程间同步</span><br><span class="line"><span class="comment">//value N值（指定同时访问的线程数）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>“cd” does not work in shell script</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr -d <span class="string">&quot;\r&quot;</span> &lt; oldname.sh &gt; newname.sh</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/14/Effective-C/" rel="prev" title="Effective C++">
                  <i class="fa fa-chevron-left"></i> Effective C++
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="next" title="网络编程">
                  网络编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  



      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liulx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

      
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>












    <div class="pjax">
  

  

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"9hqrMBm5CSF4MzBqIOmG2yjR-gzGzoHsz","appKey":"cY7tkRBoQeYdaspntsGJazu2","placeholder":"Just go go","avatar":"mm","meta":["nick","mail"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"serverURLs":null,"enableQQ":true,"requiredFields":["nick"]}
    ));
  }, window.Valine);
});
</script>

    </div>
  <!-- 引用依赖 -->
          <link rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
          <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
          <script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script>

          <!-- 我使用的APlayer本体 -->
          <div class="aplayer"
            data-id="4866586492"
            data-server="netease"
            data-type="playlist"
            data-fixed="true"
            data-autoplay="true"
            data-order="random"
            data-volume="0.55"
            data-theme="#cc543a"
            data-preload="auto" >
            </div>
          <!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面-->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
<script type="text/javascript" src="/js/fire.js"></script>

</html>
