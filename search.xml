<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>长长见识</title>
    <url>/2022/01/15/%E9%95%BF%E9%95%BF%E8%A7%81%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/10/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C/S模型：缓存大量数据，协议选择灵活,速度快，缺点：安全性</p>
<p>B/S模型：安全、跨平台，开发工作量小 缺点：不能缓存大量数据，严格遵守HTTP</p>
<h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p>网络套接字：socket</p>
<p>一个文件描述符指向一个套接字，该套接字内部由内核借助两个缓存区实现</p>
<p>在通信过程中。套接字一定是成对出现的</p>
<ul>
<li><p>网络字节序：</p>
<p>大端法：低地址高字节</p>
<p>网络字节序和主机字节序转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;<span class="comment">//本地-&gt;网络</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;<span class="comment">//网络转本地</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netlong)</span></span>;</span><br><span class="line"><span class="comment">//IP地址转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dest)</span></span>;本地字节序（<span class="built_in">string</span> ip)-&gt;网络字节序</span><br><span class="line">af:AF_INET</span><br><span class="line">   AF_INET6</span><br><span class="line">src:传入参数 IP地址，点分十进制</span><br><span class="line">dest：传出参数，网络字节序的IP地址</span><br><span class="line">成功返回<span class="number">1</span>，异常<span class="number">0</span>src不是有效ip地址，失败<span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span>*src,<span class="keyword">char</span> *dst,<span class="keyword">socklen_t</span> size)</span></span>;网络字节序-&gt;本地字节序（<span class="built_in">string</span> ip)</span><br><span class="line">src:网络字节序ip地址</span><br><span class="line">dst:本地字节序（<span class="built_in">string</span> ip)</span><br><span class="line">size dst大小</span><br><span class="line">返回值 成功src</span><br><span class="line">      失败<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p>man 7 ip</p>
</li>
<li><p>sockaddr地址结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">               <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">               <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">               <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = hton(<span class="number">9527</span>);</span><br><span class="line"><span class="keyword">int</span> dest;</span><br><span class="line">addr.sin_addr.s_addr = inet_pton(AF_INET,<span class="string">&quot;192.152.22.35&quot;</span>,(<span class="keyword">void</span> *)&amp;dst);</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY）;<span class="comment">//取出系统中任意有效地址，二进制类型</span></span><br><span class="line">bind(fd,(struct sockaddr*)&amp;addr,len);</span><br></pre></td></tr></table></figure>
<p>服务器</p>
<p>socket()创建套接字</p>
<p>bind(）绑定IP+Port</p>
<p>listen()设置同时监听上限</p>
<p>accept()阻塞监听客户端连接</p>
<p>close()</p>
<p>客户端</p>
<p>socket()创建套接字</p>
<p>connect()绑定IP和端口</p>
<p>close()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;<span class="comment">//创建一个套接字</span></span><br><span class="line">domain: AF_INET AF_INET6 AF_UNIX（本地）</span><br><span class="line">type:SOCK_STREAM,SOCK_DGRAM</span><br><span class="line">protocol:<span class="number">0</span></span><br><span class="line">成功返回新套接字对应的文件描述符</span><br><span class="line">失败<span class="number">-1</span>,perror</span><br><span class="line">    socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;<span class="comment">//给socket绑定一个地址结构（IP+port)</span></span><br><span class="line">sockfd:socket函数返回值</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_addr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//要与sock传递的一致</span></span><br><span class="line">    </span><br><span class="line">addr:&amp;addr</span><br><span class="line">addrlen:<span class="keyword">sizeof</span>(addr)</span><br><span class="line">成功<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;<span class="comment">//设置同时与服务器建立连接的上限数</span></span><br><span class="line">backlog:上限数值，最大<span class="number">128</span></span><br><span class="line">成功<span class="number">0</span></span><br><span class="line">失败<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;<span class="comment">//阻塞等待客户端建立连接，成功的话返回一个与客户端成功连接的socket文件描述符</span></span><br><span class="line">sockfd:socket 返回值</span><br><span class="line">addr:传出参数，成功与服务器建立连接的客户端地址结构</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    传入&amp;addr_len</span><br><span class="line">addrlen:传入传出参数，入：addr大小，出：客户端addr实际大小</span><br><span class="line">成功返回能与客户端进行数据通信的socket对应的文件描述符</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr*addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//addr：传入参数，服务器的地址结构</span></span><br><span class="line"><span class="comment">//addrlen:服务器的地址结构大小</span></span><br><span class="line">返回值：</span><br><span class="line">    成功<span class="number">0</span></span><br><span class="line">    失败<span class="number">-1</span>errno</span><br><span class="line">如果不使用bind绑定客户端地址结构，采用隐式绑定</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ],CLIENT_IP[<span class="number">1024</span>];</span><br><span class="line">    lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_len;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bind(lfd,(struct sockaddr*)(&amp;serv_addr),<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(lfd,<span class="number">128</span>);</span><br><span class="line">    client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    cfd = accept(lfd,(struct sockaddr*)(&amp;client_addr),&amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip:%s port:%d\n&quot;</span>,inet_ntop(AF_INET,&amp;client_addr.sin_addr.s_addr,CLIENT_IP,<span class="keyword">sizeof</span>(CLIENT_IP)),ntohs(client_addr.sin_port));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ret; i++)&#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd,buf,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> <span class="number">127.0.0.1</span> <span class="number">9527</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cfd;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = connect(cfd, (struct sockaddr *) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--counter) &#123;</span><br><span class="line">        write(cfd, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h3><ul>
<li><p>socket()创建监听套接字</p>
</li>
<li><p>bind()绑定地址结构</p>
</li>
<li><p>listen()</p>
</li>
<li><p>while(1){</p>
<p>cfd =accept()</p>
<p>pid = fork();</p>
<p>if(pid == 0){</p>
<p>close(lfd)</p>
<p>子进程read(cfd)-&gt;小-&gt;大 write(cfd)</p>
<p>}else if(pid &gt; 0){</p>
<p>close(cfd);//关闭用于客户端通信的套接字cfd</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
</li>
<li><p>子进程：</p>
<p>close(lfd)</p>
<p>read()</p>
<p>小—大</p>
<p>write()</p>
</li>
<li><p>父进程</p>
<p>close(cfd)</p>
<p>注册信号捕捉函数 SIGCHLD</p>
<p>在回调函数中完成子进程回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    bind(lfd, (struct sockaddr *) (&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cfd = accept(lfd, (struct sockaddr *) &amp;client_addr, &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">            <span class="keyword">int</span> ret, i;</span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;<span class="comment">//read函数返回0说明对端已经关闭</span></span><br><span class="line">                    <span class="comment">//read 返回-1出错</span></span><br><span class="line">                    <span class="comment">//errno = EAGIN or EWOULDBLOCK 设置非阻塞方式，没有数据到达</span></span><br><span class="line">                    <span class="comment">//errno = EINTR 慢速系统调用被中断</span></span><br><span class="line">                    <span class="comment">//其他异常</span></span><br><span class="line">                    close(cfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">                    buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, buf, ret);</span><br><span class="line">                write(STDOUT_FILENO, buf, ret);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signal(SIGCHLD, sigchld);</span><br><span class="line">            close(cfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h3><ul>
<li><p>socket()创建监听套接字</p>
</li>
<li><p>bind()绑定地址结构</p>
</li>
<li><p>listen()</p>
</li>
<li><p>while(1){</p>
</li>
</ul>
<p>cfd = Accept(lfd,)</p>
<p>pthread_create(&amp;tid,NULL,tfn,NULL);</p>
<p>pthread_detach(tid);//pthread_join(tid,void**);新线程—专门回收子线程</p>
<p>}</p>
<ul>
<li><p>子线程</p>
<p>void <em>tfn(void </em>arg){</p>
<p>read()   </p>
<p>小—大</p>
<p>   write()</p>
<p>}</p>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">scp -r .<span class="regexp">/test[本地目录] 用户名@101.200.170.171：/</span>home<span class="regexp">/用户名/</span>socket_server[远程目录]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -apn | grep 8000 //查看8000号端口网络连接状态</span><br></pre></td></tr></table></figure>
<h3 id="TCP状态时序图"><a href="#TCP状态时序图" class="headerlink" title="TCP状态时序图"></a>TCP状态时序图</h3><p>1.主动发起连接请求端 CLOSE— 发送SYN — SEND_SYN —接收ACK,SYN—SEND_SYN —-发送ACK — ESTABLISHED（数据通信态）</p>
<p>2.主动关闭连接请求端 ESTABLISHED（数据通信态）—发送FIN—FIN_WAIT1—接收ACK—FIN_WAIT2(半关闭)—接收端发送FIN—FIN_WAIT2（半关闭）—回发ACK—TIME_WAIT(2MSL)(只有主动关闭连接方会经历该状态）—CLOSE</p>
<p>3.被动接受连接请求端 CLOSE—LISTEN —接收SYN—LISTEN—发送SYN,ACK—SYN_RCVD—接收ACK—ESTABLISHED</p>
<p>4.被动关闭连接请求端：ESTABLISHED—接收FIN，发送ACK — CLOSE_WAIT (对端处于半关闭状态)— 发送FIN—LAST_ACK—接收ACK—CLOSE</p>
<ul>
<li><p>2MSL时长</p>
<p>保证最后一个ACK能被对端接收，（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求）</p>
</li>
</ul>
<h3 id="设置端口复用"><a href="#设置端口复用" class="headerlink" title="设置端口复用"></a>设置端口复用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在socket和bind之间插入</span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;<span class="comment">//设置端口复用，0/1</span></span><br><span class="line">setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR<span class="comment">/*SO_REUSEPORT*/</span>,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>半关闭：通信双方，只有一端关闭通信 FIN_WAIT_2</p>
<p>close(cfd);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> how)</span></span>;</span><br><span class="line">how:</span><br><span class="line">SHUT_RD</span><br><span class="line">SHUT_WR</span><br><span class="line">SHUT_RDWR</span><br><span class="line">shutdown在关闭多个文件描述符引用的文件时，采用全关闭方法，close只关闭一个</span><br></pre></td></tr></table></figure>
<h3 id="select多路IO转接"><a href="#select多路IO转接" class="headerlink" title="select多路IO转接"></a>select多路IO转接</h3><p>阻塞</p>
<p>非阻塞忙轮询</p>
<p>响应式—多路IO转接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nfds：监听的所有文件描述符中最大的文件描述符+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">传入传出参数：</span></span><br><span class="line"><span class="comment">readfds 读文件描述符监听集合，文件描述符指针，指向文件描述符表位图</span></span><br><span class="line"><span class="comment">writefds 写文件描述符监听集合 NULL</span></span><br><span class="line"><span class="comment">exceptfds 异常文件描述符监听集合 NULL</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回监听集合中，满足对应事件的的总数</span></span><br><span class="line"><span class="comment">0：没有满足监听条件的文件描述符</span></span><br><span class="line"><span class="comment">-1：error</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">timeout:定阻塞时间</span></span><br><span class="line"><span class="comment">    NULL:永远等待</span></span><br><span class="line"><span class="comment">    设置timeval,等待固定时间</span></span><br><span class="line"><span class="comment">    设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原理：借助内核，select来监听，客户端连接，数据通信事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line">FD_ZERO(rset);</span><br><span class="line"></span><br><span class="line">FD_SET(<span class="number">3</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">6</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>,&amp;rset);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lfd = socket(); <span class="comment">//创建套接字</span></span><br><span class="line">bind();<span class="comment">//绑定地址结构</span></span><br><span class="line">listen();<span class="comment">//设置监听上限</span></span><br><span class="line">fd_set rset,allset;<span class="comment">//创建r监听集合</span></span><br><span class="line">FD_ZERO(allset);<span class="comment">//将r监听集合清空</span></span><br><span class="line">FD_SET(lfd,&amp;allset);<span class="comment">//将lfd添加至读集合</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">rset = allset;<span class="comment">//保存监听集合</span></span><br><span class="line">ret = select(lfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//监听文件描述符集合对应事件</span></span><br><span class="line"><span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;<span class="comment">//有监听的描述符满足对应事件</span></span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))&#123;<span class="comment">//1在 0不在</span></span><br><span class="line">        cfd = accept(); <span class="comment">//建立连接，返回用于通信的文件描述符</span></span><br><span class="line">        FD_SET(cfd,&amp;allset);<span class="comment">//添加到监听通信描述符集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = lfd+<span class="number">1</span>; i &lt;= 最大文件描述符; i++)&#123;</span><br><span class="line">        FD_ISSET(i,&amp;rset);<span class="comment">//有read,write事件</span></span><br><span class="line">        read();</span><br><span class="line">        小--&gt;大</span><br><span class="line">        write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9999</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bind(lfd, (struct sockaddr *) (&amp;serv_addr), <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">    fd_set rset,allset;</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(lfd,&amp;allset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> client_addr_len;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        num = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(lfd, &amp;rset))&#123;</span><br><span class="line">            client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">            cfd = accept(lfd,(struct sockaddr*)&amp;client_addr,&amp;client_addr_len);</span><br><span class="line">            FD_SET(cfd,&amp;allset);</span><br><span class="line">            <span class="keyword">if</span>(cfd &gt; maxfd)maxfd = cfd;</span><br><span class="line">            <span class="keyword">if</span>(--num)<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = lfd+<span class="number">1</span>; i &lt;= maxfd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123;</span><br><span class="line">                len = read(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">                    FD_CLR(i,&amp;allset);</span><br><span class="line">                    close(i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                    buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                write(i,buf,len);</span><br><span class="line">                write(STDOUT_FILENO,buf,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select优缺点：</p>
<p>文件描述符数量有限，1024</p>
<p>检测满足条件的fd,自己添加业务逻辑提高小，提高了编码难度</p>
<p>优点，跨平台。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">fds:监听的文件描述符数组</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span>POLLIN POLLOUT POLLERR</span><br><span class="line">               <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span>传入是，给<span class="number">0</span>，如果满足对应事件，返回非<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">nfds:监听数组的实际有效的监听个数</span><br><span class="line">timeout:超时时长 milliseconds</span><br><span class="line">    <span class="number">-1</span> 阻塞等待</span><br><span class="line">    <span class="number">0</span> 立即返回，不阻塞进程</span><br><span class="line">    &gt;<span class="number">0</span>等待指定毫秒数</span><br><span class="line">返回值：返回满足对应监听事件的文件描述符总个数</span><br><span class="line">    <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)&#123;<span class="comment">/*lfd有读事件就绪*/</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>read函数返回0说明对端已经关闭<br>read 返回-1出错<br>errno = EAGIN or EWOULDBLOCK 设置非阻塞方式，没有数据到达<br>errno = EINTR 慢速系统调用被中断</p>
<p>errno = ECONNRESET说明连接被重置，需要close()移除监听序列</p>
<p>其他异常</p>
</li>
<li><p>优点：自带数组结构，可以将监听事件、返回事件集合分离，拓展监听上限，超出1024限制</p>
</li>
<li><p>缺点：不能跨平台，Linux,无法直接定位满足监听事件的文件描述符，编码难度大</p>
</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">size:创建的红黑树监听结点数量(仅供参考)</span><br><span class="line">返回值：指向新创建的红黑树根节点的fd</span><br><span class="line">    失败<span class="number">-1</span>，errno</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    epfd:epoll_create函数返回值，epfd</span><br><span class="line">    op：对红黑树的操作  EPOLL_CTL_ADD  EPOLL_CTL_MOD  EPOLL_CTL_DEL</span><br><span class="line">    event:本质上是一个<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>结构体地址</span></span><br><span class="line"><span class="class">        <span class="title">events</span>:</span></span><br><span class="line">                EPOLLIN EPOLLOUT  EPOLLERR</span><br><span class="line">        data：联合体</span><br><span class="line">              <span class="keyword">int</span> fd;对应监听事件的fd</span><br><span class="line">    成功<span class="number">0</span>，失败<span class="number">-1</span> errno</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">               <span class="keyword">void</span>        *ptr;</span><br><span class="line">               <span class="keyword">int</span>          fd;</span><br><span class="line">               <span class="keyword">uint32_t</span>     u32;<span class="comment">//不用</span></span><br><span class="line">               <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">    &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">               <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">               <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;<span class="comment">//阻塞监听</span></span><br><span class="line">     epfd:epoll_create返回值，epfd</span><br><span class="line">     events:数组，传出参数，传出满足监听条件的fd结构体</span><br><span class="line">     maxevents:数组元素的总个数</span><br><span class="line">     timeout:同poll</span><br><span class="line">     返回值</span><br><span class="line">         &gt;<span class="number">0</span> 满足监听的总个数，可用作循环上限</span><br><span class="line">         <span class="number">0</span> 没有fd满足监听事件</span><br><span class="line">         失败<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>sys<span class="regexp">/fs/</span><span class="keyword">file</span>-max 当前计算机所能打开的最大文件个数，受硬件影响</span><br><span class="line">ulimit -a 当前用户下进程默认打开文件描述符个数，缺省为<span class="number">1024</span></span><br><span class="line">修改文件描述符上限</span><br><span class="line">sudo vi <span class="regexp">/ect/</span>security/limits.conf</span><br><span class="line">修改：</span><br><span class="line"> * soft nofile <span class="number">65535</span>--&gt;设置默认值， 可以通过形如ulimit -n <span class="number">20000</span>命令修改</span><br><span class="line"> * hard nofile <span class="number">1000000</span>--》命令修改上限</span><br></pre></td></tr></table></figure>
<p>显著提高程序中大量并发连接中只有少量活跃的情况下的系统cpu利用率</p>
<p>Epoll事件模型</p>
<p>ET边沿触发，只有数据到来才触发，不管缓存区是否还有数据</p>
<p>LT水平触发，只要有数据都会触发—默认采用模式(缓存区剩余未读尽数据会导致epoll_wait返回)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">改边沿触发 event.events = EPOLLIN | EPOLLET;</span><br></pre></td></tr></table></figure>
<p>LT是缺省的工作方式，同时支持block unblock socket,传统的select poll都是这种模型代表</p>
<p>ET是高速工作方式，仅支持no-block socket,忙轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;event);</span><br><span class="line"><span class="keyword">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(cfd,F_SETFL,flag);</span><br></pre></td></tr></table></figure>
<p>优点：高效，突破1024文件描述符,事件分离</p>
<p>缺点：不能跨平台Linux</p>
<h3 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h3><p>epoll ET 模式+非阻塞+void*ptr</p>
<p>不但要监听cfd的读事件，还要监听cfd的写事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__func__ 打印函数名</span><br><span class="line">__LINE__行号</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *epoll基于非阻塞I/O事件驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS  1024                                    <span class="comment">//监听上限数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述就绪文件描述符相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                                                 <span class="comment">//要监听的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> events;                                             <span class="comment">//对应的监听事件</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                                              <span class="comment">//泛型参数</span></span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);       <span class="comment">//回调函数</span></span><br><span class="line">    <span class="keyword">int</span> status;                                             <span class="comment">//是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFLEN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">long</span> last_active;                                       <span class="comment">//记录每次加入红黑树 g_efd 的时间值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_efd;                                                  <span class="comment">//全局变量, 保存epoll_create返回的文件描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">MAX_EVENTS</span>+1];</span>                    <span class="comment">//自定义结构体类型数组. +1--&gt;listen fd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将结构体 myevent_s 成员变量 初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventset</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ev-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(ev-&gt;buf));</span><br><span class="line">    ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);                       <span class="comment">//调用eventset函数的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventadd</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;       <span class="comment">//EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status == <span class="number">0</span>) &#123;                                          <span class="comment">//已经在红黑树 g_efd 里</span></span><br><span class="line">        op = EPOLL_CTL_ADD;                 <span class="comment">//将其加入红黑树 g_efd, 并将status置1</span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)                       <span class="comment">//实际添加/修改</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add failed [fd=%d], events[%d]\n&quot;</span>, ev-&gt;fd, events);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;</span>, ev-&gt;fd, op, events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventdel</span><span class="params">(<span class="keyword">int</span> efd, struct myevent_s *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status != <span class="number">1</span>)                                        <span class="comment">//不在红黑树上</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epv.data.ptr = ev;</span></span><br><span class="line">    epv.data.ptr = <span class="literal">NULL</span>;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;                                             <span class="comment">//修改状态</span></span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                <span class="comment">//从红黑树 efd 上将 ev-&gt;fd 摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptconn</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="built_in">cin</span>);</span><br><span class="line">    <span class="keyword">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cfd = accept(lfd, (struct sockaddr *)&amp;<span class="built_in">cin</span>, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">            <span class="comment">/* 暂时不做出错处理 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: accept, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)                                <span class="comment">//从全局数组g_events中找一个空闲元素</span></span><br><span class="line">            <span class="keyword">if</span> (g_events[i].status == <span class="number">0</span>)                                <span class="comment">//类似于select中找值为-1的元素</span></span><br><span class="line">                <span class="keyword">break</span>;                                                  <span class="comment">//跳出 for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == MAX_EVENTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: max connect limit[%d]\n&quot;</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;                                                      <span class="comment">//跳出do while(0) 不执行后续代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) &#123;             <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed, %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */</span></span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);   </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         <span class="comment">//将cfd添加到红黑树g_efd中,监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;</span>, </span><br><span class="line">            inet_ntoa(<span class="built_in">cin</span>.sin_addr), ntohs(<span class="built_in">cin</span>.sin_port), g_events[i].last_active, i);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)arg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);            <span class="comment">//读文件描述符, 数据存入myevent_s成员buf中</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);        <span class="comment">//将该节点从红黑树上摘除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;                                <span class="comment">//手动添加字符串结束标记</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        eventset(ev, fd, senddata, ev);                     <span class="comment">//设置该 fd 对应的回调函数为 senddata</span></span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      <span class="comment">//将fd加入红黑树g_efd中,监听其写事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="comment">/* ev-g_events 地址相减得到偏移元素位置 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%ld], closed\n&quot;</span>, fd, ev-g_events);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv[fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">senddata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)arg;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, <span class="number">0</span>);                    <span class="comment">//直接将数据 回写给客户端。未作处理</span></span><br><span class="line"></span><br><span class="line">    eventdel(g_efd, ev);                                <span class="comment">//从红黑树g_efd中移除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d], [%d]%s\n&quot;</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     <span class="comment">//将该fd的 回调函数改为 recvdata</span></span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       <span class="comment">//从新添加到红黑树上， 设为监听读事件</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(ev-&gt;fd);                                      <span class="comment">//关闭链接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error %s\n&quot;</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建 socket, 初始化lfd */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            <span class="comment">//将socket设为非阻塞</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));                                               <span class="comment">//bzero(&amp;sin, sizeof(sin))</span></span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	bind(lfd, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line">	listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */</span></span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventadd(int efd, int events, struct myevent_s *ev) */</span></span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = SERV_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);                           <span class="comment">//使用用户指定端口.如未指定,用默认端口</span></span><br><span class="line"></span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+<span class="number">1</span>);                 <span class="comment">//创建红黑树,返回给全局 g_efd </span></span><br><span class="line">    <span class="keyword">if</span> (g_efd &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create efd in %s err %s\n&quot;</span>, __func__, strerror(errno));</span><br><span class="line"></span><br><span class="line">    initlistensocket(g_efd, port);                      <span class="comment">//初始化监听socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>+1];</span>            <span class="comment">//保存已经满足就绪事件的文件描述符数组 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;server running:port[%d]\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> checkpos = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);                          <span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkpos++) &#123;         <span class="comment">//一次循环检测100个。 使用checkpos控制检测对象</span></span><br><span class="line">            <span class="keyword">if</span> (checkpos == MAX_EVENTS)</span><br><span class="line">                checkpos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (g_events[checkpos].status != <span class="number">1</span>)         <span class="comment">//不在红黑树 g_efd 上</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> duration = now - g_events[checkpos].last_active;       <span class="comment">//客户端不活跃的世间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (duration &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                close(g_events[checkpos].fd);                           <span class="comment">//关闭与该客户端链接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] timeout\n&quot;</span>, g_events[checkpos].fd);</span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   <span class="comment">//将该客户端 从红黑树 g_efd移除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/</span></span><br><span class="line">        <span class="keyword">int</span> nfd = epoll_wait(g_efd, events, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error, exit\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfd; i++) &#123;</span><br><span class="line">            <span class="comment">/*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s *)events[i].data.ptr;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           <span class="comment">//读就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">                <span class="comment">//lfd  EPOLLIN  </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         <span class="comment">//写就绪事件</span></span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出前释放所有资源 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ctags</span></span><br><span class="line"><span class="attribute">ctags</span> ./* -R</span><br><span class="line"><span class="attribute">Ctrl</span> + ] 光标置于调用函数上，跳转至函数定义位置</span><br><span class="line"><span class="attribute">Ctrl</span> + t 返回到此前跳转位置</span><br><span class="line"><span class="attribute">Ctrl</span>+ o 在屏幕左边列出文件列表，再次ctrl+o关闭</span><br><span class="line"><span class="attribute">F4</span>在屏幕右边列出文件列表，再次F<span class="number">4</span>关闭</span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>1.main()</p>
<p>   创建线程池</p>
<p>   向线程池添加任务，借助回调处理任务</p>
<p>   销毁线程池</p>
<p>2.pthreadpool_create()</p>
<p>   创建线程池结构体指针</p>
<p>   初始化线程池结构体</p>
<p> 创建N个任务线程</p>
<p>创建一个管理线程</p>
<p>失败时销毁开辟的所有空间（释放）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *(*function)(<span class="keyword">void</span> *);          <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *arg;                          <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="keyword">threadpool_task_t</span>;                    <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;               <span class="comment">/* 用于锁住本结构体 */</span>    </span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> thread_counter;     <span class="comment">/* 记录忙状态线程个数de琐 -- busy_thr_num */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_full;      <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> queue_not_empty;     <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> *threads;                 <span class="comment">/* 存放线程池中每个线程的tid。数组 */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> adjust_tid;               <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="keyword">threadpool_task_t</span> *task_queue;      <span class="comment">/* 任务队列(数组首地址) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_thr_num;                    <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_thr_num;                    <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> live_thr_num;                   <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> busy_thr_num;                   <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="keyword">int</span> wait_exit_thr_num;              <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queue_front;                    <span class="comment">/* task_queue队头下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_rear;                     <span class="comment">/* task_queue队尾下标 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_size;                     <span class="comment">/* task_queue队中实际任务数 */</span></span><br><span class="line">    <span class="keyword">int</span> queue_max_size;                 <span class="comment">/* task_queue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shutdown;                       <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.threadpool_thread()</p>
<p>进入子进程回调函数</p>
<p>接收参数 void *arg -&gt;pool 结构体</p>
<p>加锁-&gt;lock-&gt;整个结构体锁</p>
<p>判断条件变量 wait </p>
<p>4.adjust_thread()</p>
<p>循环10秒执行一次</p>
<p>进入管理者线程回调函数</p>
<p>接收参数 void *arg -&gt;pool 结构体</p>
<p>加锁-&gt;lock-&gt;整个结构体锁</p>
<p>获取管理线程池需要的变量</p>
<p>根据既定算法，使用上述变量，判断是否应该创建、销毁线程池中指定步长的线程</p>
<p>5.threadpool_add()</p>
<p>模拟产生任务，num[20]</p>
<p>设置回调函数，处理任务</p>
<p>内部实现：</p>
<p>加锁</p>
<p>初始化任务队列结构体成员，回调函数function arg</p>
<p>利用环形队列机制，实现添加任务，借助队尾指针挪移实现</p>
<p>唤醒阻塞在条件变量上的线程</p>
<p>解锁</p>
<p>6.从3.中的wait之后继续执行，处理任务</p>
<p>加锁</p>
<p>获取任务处理回调函数，及参数</p>
<p>利用环形队列机制，实现处理任务，借助队头指针挪移%实现</p>
<p>唤醒阻塞在条件变量上的server</p>
<p>解锁</p>
<p>加锁</p>
<p>改忙线程数++</p>
<p>解锁</p>
<p>执行处理任务的线程</p>
<p>加锁</p>
<p>改忙线程数—</p>
<p>解锁</p>
<p>7.创建销毁线程</p>
<p>管理者线程 task_num,live_num,busy_num</p>
<p>根据既定算法，使用上述变量判断是否应该创建、销毁线程池中指定步长的线程</p>
<p>如果满足创建条件</p>
<p>pthread_create() 回调任务线程函数 live_num++</p>
<p>如果满足销毁条件</p>
<p>wait_exit_thr_num = 10;</p>
<p>signal给阻塞在条件变量上的线程发送假满足信号</p>
<p>阻塞线程会被假信号唤醒，wait_exit_thr_num pthread_exit()</p>
<h3 id="TCP-UDP各自优缺点"><a href="#TCP-UDP各自优缺点" class="headerlink" title="TCP UDP各自优缺点"></a>TCP UDP各自优缺点</h3><p>TCP:面向连接的，可靠数据传输 对不稳定的网络层，采取完全弥补的通信方式，丢包重传</p>
<p>优点：稳定，数据流量稳定，速度稳定，顺序稳定</p>
<p>缺点：传输速度慢，效率低，开销大</p>
<p>使用场景：数据完整性要求较高，不追求效率</p>
<p>​                   大数据传输，文件传输</p>
<p>UDP:无连接，不可靠数据报传递 对于不稳定的网络层，采取完全不弥补的通信方式，默认还原网络状况</p>
<p>优点：传输速度快，效率高，开销低</p>
<p>缺点：不稳定</p>
<p>使用场景：对时效性要求较高，稳定性其次</p>
<p>游戏、视频会议，视频电话 应用层数据校验协议，弥补udp的不足</p>
<h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><p>UDP实现的C/S模型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">accept(),connec()被舍弃</span><br><span class="line">recv()/send()只能用于TCP通信，替代read/write</span><br><span class="line">server:</span><br><span class="line">        lfd =  socket(AF_INET,STREAM,<span class="number">0</span>);SOCK_DGRAM报式协议</span><br><span class="line">        bind()</span><br><span class="line">        listen()可有可无</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            read(cfd,buf,)被替换--recvfrom()</span><br><span class="line">            小-大</span><br><span class="line">            write()被替换--sendto()</span><br><span class="line">        &#125;</span><br><span class="line">client:</span><br><span class="line">       connfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)</span><br><span class="line">       sendto(&#x27;服务器地址结构&#x27;，地址结构大小)</span><br><span class="line">       recvfrom()</span><br><span class="line">       close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">sockfd:套接字</span><br><span class="line">buf:缓存区地址</span><br><span class="line">len缓存区大小</span><br><span class="line">flags:<span class="number">0</span>默认值</span><br><span class="line">src_addr：(struct sockaddr*)&amp;addr;传出。对端地址结构</span><br><span class="line">addrlen:传入传出</span><br><span class="line">返回值：</span><br><span class="line">    成功接收数据字节数，<span class="number">-1</span>失败，<span class="number">0</span>对端关闭</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">sockfd:套接字</span><br><span class="line">buf:存储数据的缓存区地址</span><br><span class="line">len 数据长度</span><br><span class="line">flags:<span class="number">0</span>默认值</span><br><span class="line">src_addr：(struct sockaddr*)&amp;addr;传出。目标地址结构</span><br><span class="line">addrlen:地址结构长度</span><br><span class="line">返回值：</span><br><span class="line">    成功写出数据字节数，<span class="number">-1</span>失败，<span class="number">0</span>对端关闭</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,<span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        n = sendto(sockfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">client</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sockfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);         <span class="comment">//NULL:不关心对端信息</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h3><p>（domain)</p>
<p>对比TCP C/S模型，注意</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; domain AF_INET--&gt;AF_UNIX/AF_LOCAL</span><br><span class="line">                                                type SOCK_STREM/SOCK_DGRAM都可以</span><br><span class="line"><span class="number">2.</span>地址结构：sockaddr_in--&gt;sockaddr_un</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">    <span class="keyword">__kernel_sa_family_t</span> sum_family;</span><br><span class="line">    <span class="keyword">char</span> sun_path[UNIX_PATH_MAX];</span><br><span class="line">&#125;;</span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(addr.sun_path,<span class="string">&quot;srv.socket&quot;</span>);</span><br><span class="line"><span class="number">3.b</span>ind();</span><br><span class="line">bind(fd,(struct sockaddr*)&amp;addr,offsetof(struct sockaddr_un,sun_path)+<span class="built_in">strlen</span>(<span class="string">&quot;srv.socket&quot;</span>));</span><br><span class="line">bind()函数调用成功会创建一个socket文件,因此为保证bind成功，通常我们再bind之前,可以使用unlink</span><br><span class="line"><span class="number">4.</span>客户端不能依赖隐式绑定，并且应该在通信建立过程中，创建并初始化<span class="number">2</span>个地址结构</span><br><span class="line">    <span class="function">client_addr <span class="title">bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    server_addr <span class="title">connect</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR  <span class="meta-string">&quot;serv.socket&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd, len, size, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">/* servaddr total len */</span></span><br><span class="line"></span><br><span class="line">    unlink(SERV_ADDR);                              <span class="comment">/* 确保bind之前serv.sock文件不存在,bind会创建该文件 */</span></span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           <span class="comment">/* 参3不能是sizeof(servaddr) */</span></span><br><span class="line"></span><br><span class="line">    Listen(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accept ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);  <span class="comment">//AF_UNIX大小+108B</span></span><br><span class="line"></span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (<span class="keyword">socklen_t</span> *)&amp;len);</span><br><span class="line"></span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      <span class="comment">/* 得到文件名的长度 */</span></span><br><span class="line">        cliaddr.sun_path[len] = <span class="string">&#x27;\0&#x27;</span>;                       <span class="comment">/* 确保打印时,没有乱码出现 */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client bind filename %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((size = read(cfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            write(cfd, buf, size);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">client.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;         </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_ADDR <span class="meta-string">&quot;serv.socket&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIE_ADDR <span class="meta-string">&quot;clie.socket&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  cfd, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    cliaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);     <span class="comment">/* 计算客户端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    unlink(CLIE_ADDR);</span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 <span class="comment">/* 客户端也需要bind, 不能依赖自动绑定*/</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                                          <span class="comment">/* 构造server 地址 */</span></span><br><span class="line">    servaddr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, SERV_ADDR);</span><br><span class="line"></span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">/* 计算服务器端地址结构有效长度 */</span></span><br><span class="line"></span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对比本地套 和 网络套。<br>                    网络套接字                        本地套接字</p>
<pre><code>server：    lfd = socket(AF_INET, SOCK_STREAM, 0);            lfd = socket(AF_UNIX, SOCK_STREAM, 0);

        bzero() ---- struct sockaddr_in serv_addr;         bzero() ---- struct sockaddr_un serv_addr, clie_addr;

        serv_addr.sin_family = AF_INET;                       serv_addr.sun_family = AF_UNIX;    
        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        serv_addr.sin_port = htons(8888);                   strcpy（serv_addr.sun_path, &quot;套接字文件名&quot;）
                                                         len = offsetof(sockaddr_un, sun_path) + strlen();
</code></pre><p>​<br>​            bind(lfd, (struct sockaddr <em>)&amp;serv_addr, sizeof());     unlink(“套接字文件名”);<br>​                                                              bind(lfd, (struct sockaddr </em>)&amp;serv_addr, len);  创建新文件<br>​<br>            Listen(lfd, 128);                               Listen(lfd, 128);</p>
<pre><code>        cfd = Accept(lfd, ()&amp;clie_addr, &amp;len);            cfd = Accept(lfd, ()&amp;clie_addr, &amp;len);  


client：        
        lfd = socket(AF_INET, SOCK_STREAM, 0);            lfd = socket(AF_UNIX, SOCK_STREAM, 0);

        &quot; 隐式绑定 IP+port&quot;                                  bzero() ---- struct sockaddr_un clie_addr;
                                                          clie_addr.sun_family = AF_UNIX;
                                                        strcpy（clie_addr.sun_path, &quot;client套接字文件名&quot;）
                                                         len = offsetof(sockaddr_un, sun_path) + strlen();
                                                       unlink( &quot;client套接字文件名&quot;);
                                                       bind(lfd, (struct sockaddr *)&amp;clie_addr, len);

        bzero() ---- struct sockaddr_in serv_addr;        bzero() ---- struct sockaddr_un serv_addr;

        serv_addr.sin_family = AF_INET;                          serv_addr.sun_family = AF_UNIX;

        inet_pton(AF_INT, &quot;服务器IP&quot;, &amp;sin_addr.s_addr)                            
                                                         strcpy（serv_addr.sun_path, &quot;server套接字文件名&quot;）
        serv_addr.sin_port = htons(&quot;服务器端口&quot;);        

                                                            len = offsetof(sockaddr_un, sun_path) + strlen();

        connect(lfd, &amp;serv_addr, sizeof());                         connect(lfd, &amp;serv_addr, len);
</code></pre><h3 id="libevent库"><a href="#libevent库" class="headerlink" title="libevent库"></a>libevent库</h3><p>开源、精简、跨平台、专注于网络通信</p>
<p>源码包安装：</p>
<p>./configure 检查安装环境生成makefile</p>
<p>make 生成.o文件和可执行文件</p>
<p>sudo make install 将必要的资源cp至系统指定目录</p>
<p>进入sample 目录，运行demo</p>
<p>编译使用库的.c文件时，需要加-levent</p>
<p>库名 libevent.so  /usr/local/lib <code>ll libevent*</code></p>
<h4 id="libevent框架"><a href="#libevent框架" class="headerlink" title="libevent框架"></a>libevent框架</h4><p>创建event_base</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct event_base*<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>*<span class="title">base</span> =</span> event_base_new();</span><br></pre></td></tr></table></figure>
<p>创建事件event</p>
<p>​        常规事件 <code>event_new();</code></p>
<p>​        bufferevent <code>bufferevent_socket_new();</code></p>
<p>将事件添加到base上</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event*ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure>
<p>循环监听事件满足</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base * base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>释放event_base</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure>
<p>特性：基于<code>事件</code>的异步通信模型—回调</p>
<ul>
<li><p>启动循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base * base)</span></span>;</span><br><span class="line">只有event_new指定了EV_PERSIST才持续触发，否则只触发一次就跳出循环</span><br><span class="line">EV_WRITE|EV_PERSIST、 EV_READ|EV_PERSIST</span><br></pre></td></tr></table></figure></li>
<li><p>其他循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base*base,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line">在指定时间后停止循环</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base*base)</span></span>;</span><br><span class="line">立即停止循环</span><br></pre></td></tr></table></figure></li>
<li><p>查看支持哪些多路IO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">event_get_supported_methods</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前用的多路IO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base*base)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>查看fork后子进程使用的event_base</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用该函数后，父进程创建的base才能在子进程中使用</p>
</li>
</ul>
<h4 id="常规事件"><a href="#常规事件" class="headerlink" title="常规事件"></a>常规事件</h4><p>创建事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base*base,<span class="keyword">evutil_socket_t</span> fd,<span class="keyword">short</span> what,event_callback_fn cb,<span class="keyword">void</span>*arg)</span></span>;</span><br><span class="line">base :event_base_new()返回值</span><br><span class="line">   fd:绑定到event上的文件描述符</span><br><span class="line"> what:对应的事件（读、写、异常）</span><br><span class="line">     EV_READ</span><br><span class="line">     EV_WRITE</span><br><span class="line">     EV_PERSIST持续触发，结合event_base_dispatch函数使用，生效</span><br><span class="line"> cb:一旦事件满足监听条件，回调的函数</span><br><span class="line"> arg:回调函数的参数</span><br><span class="line"> 返回值：成功创建的event</span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,<span class="keyword">short</span>,<span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>添加事件到event_base</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event * ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line">tv：<span class="literal">NULL</span>,添加的事件不会超时</span><br><span class="line">    否则，tv以秒和微秒指定超时值</span><br></pre></td></tr></table></figure>
<p>从event_base摘下事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>未决和非未决</p>
<p>未决：有资格被处理，但还没有处理</p>
<p>非未决：没有资格被处理</p>
</li>
</ul>
<h4 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>带buf的事件对象</p>
<p>原理：bufferevent有两个缓存区，也是队列实现。先进先出，只能读一次</p>
<p>读：有数据—&gt;读回调函数被调用—&gt;使用bufferevent_read()读数据</p>
<p>写：使用bufferevent_write()—&gt;向缓冲区写数据—&gt;该缓存区有数据自动写出—&gt;写完，回调函数被调用，通知写数据完成</p>
<p>用bufferevent_read()来从读缓存中读数据。替代read()功能</p>
<ul>
<li>创建bufferevent</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct bufferevent* <span class="title">bufferevent_socket_new</span><span class="params">(struct event_base*base,<span class="keyword">evutil_socket_t</span> fd,<span class="keyword">enum</span> bufferevent_options)</span></span>;</span><br><span class="line">fd:跟bufferevent绑定的文件描述符</span><br><span class="line">options:BEV_OPT_CLOSE_ON_FREE  </span><br><span class="line">返回：成功创建的bufferevent事件对象</span><br></pre></td></tr></table></figure>
<ul>
<li><p>释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>给bufferevent设置回调</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,bufferevent_data_cb readcb,bufferevent_data_cb writecb,bufferevent_event_cb eventcb,<span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line">readcb：设置读缓冲回调 read_cb&#123;bufferevent_read()读数据&#125;</span><br><span class="line">writecb:设置写缓冲回调，发送写成功通知 给调用者 可以为<span class="literal">NULL</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent*bev,<span class="keyword">short</span> events,<span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">events:BEV_EVENT_CONNECTED请求的连接过程已经完成，实现客户端可用</span><br><span class="line">eventcb:设置事件回调，也可传<span class="literal">NULL</span></span><br><span class="line">cbarg:上述回调函数参数</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> * ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_read</span><span class="params">(struct bufferevent * bev,<span class="keyword">void</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent * bev,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>禁用、启用缓冲区</p>
<p>默认：新建bufferevent写缓冲是enable的，而读缓冲是disable的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent * bufev,<span class="keyword">short</span> events)</span></span>;<span class="comment">//启用缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent * bufev,<span class="keyword">short</span> events)</span></span>;<span class="comment">//禁用</span></span><br><span class="line">events: EV_READ EV_WRITE EV_READ|EV_WRITE</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">bufferevent_get_enable</span><span class="params">(struct bufferevent * bufev)</span></span>;<span class="comment">//获取缓冲区禁用状态</span></span><br></pre></td></tr></table></figure>
<p>客户端</p>
<p>socket() connect()</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, struct sockaddr *address,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line">address、len connect()第2，3个参数</span><br></pre></td></tr></table></figure>
<p>监听服务器：</p>
<p>socket() bind()listen()accept()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct event_base * base;</span></span></span><br><span class="line"><span class="function"><span class="params">    evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> fd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct event_base * base;</span></span></span><br><span class="line"><span class="function"><span class="params">     evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct sockaddr *sa,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> socklen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">flags:可识别的标志</span><br><span class="line">    LEV_OPT_CLOSE_ON_FREE：释放bufferevent时关闭底层传输端口，这将关闭底层套接字，释放底层bufferevent等</span><br><span class="line">    LEV_OPT_REUSEABLE端口复用，可以用|</span><br><span class="line">backlog:listen第<span class="number">2</span>个参数，传<span class="number">-1</span>：表默认最大值</span><br><span class="line">sa:服务器自己的地址结构IP+Port</span><br><span class="line">socklen:sa的长度</span><br><span class="line">socket bind listen accept</span><br><span class="line">返回值：成功创建的监听器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">evutil_socket_t</span> sock,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>*ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">listener:evconnlistener_new_bind返回值</span><br><span class="line">sock:用于通信的文件描述符</span><br><span class="line">addr:客户端IP+addr</span><br><span class="line">len:addr的len</span><br><span class="line">ptr:外部ptr传递进来值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>释放监听服务器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener*lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>服务器</p>
<p>1.创建一个event_base</p>
<p>2.创建一个bufferevent事件对象 bufferevent_socket_new();</p>
<p>3.使用bufferevent_setcb()给read,write,event设置回调，</p>
<p>4.当监听的事件满足时，read_cb会被调用，在其内部bufferevent_read()读</p>
<p>5.创建一个监听服务器evconnlistener_new_bind(),设置其回调函数，当有客户端成功连接时，这个回调函数会被调用</p>
<p>6.listener_cb()在函数内部完成与客户端通信</p>
<p>7.设置bufferevent的读写缓冲区enable、disable</p>
<p>8.启动循环，event_base_dispatch</p>
<p>9.释放资源</p>
<p>客户端</p>
<p>1.创建event_base</p>
<p>2.使用bufferevent_socket_new()创建一个用于跟服务器通信的bufferevent事件对象</p>
<p>3.使用bufferevent_socket_connect()连接服务器</p>
<p>4.使用buffer_setcb()给bufferevent对象的readcb,writecb,eventcb设置回调</p>
<p>5.设置bufferevent对象的读写缓冲区</p>
<p>6.接收、发送数据 bufferevent_read() bufferevent_write()</p>
<p>7.启动循环监听event_base_dispath()</p>
<p>8.释放资源</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h4><ul>
<li>请求行</li>
<li>请求头</li>
<li>空行（必须要有）</li>
<li>请求数据</li>
</ul>
<p>GET:</p>
<p>请求指定页面信息，并返回实体主体</p>
<p>POST:</p>
<p>向指定资源提交数据进行处理请求，数据被包含在请求体中。POST请求可能导致新的资源建立或已有资源修改</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">GET</span>  /hello.c HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="应答消息"><a href="#应答消息" class="headerlink" title="应答消息"></a>应答消息</h3><ul>
<li>状态行：包括协议版本号，状态码，状态信息</li>
<li>消息报头</li>
<li>空行：必须要有</li>
<li>响应正文</li>
</ul>
<p><code>telnet</code>调试</p>
<p><code>telnet 127.0.0.1 9999</code></p>
<p>GET /hello.c HTTP/1.1</p>
]]></content>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2021/10/04/linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Linux 系统目录</p>
<ul>
<li>bin 二进制可执行文件</li>
<li>boot 开机启动程序</li>
<li>dev 设备文件</li>
<li>home 普通用户</li>
<li>etc:用户信息和系统配置文件 password group</li>
<li>lib 库文件</li>
<li>root 管理员宿主目录</li>
<li>usr用户资源目录</li>
</ul>
<p>文件类型：</p>
<ul>
<li>普通文件 -</li>
<li>目录文件 d</li>
<li>字符设备文件 c</li>
<li>块设备文件 b</li>
<li>软连接 l</li>
<li>管道文件 p</li>
<li>套接字 s</li>
<li>未知文件</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>which:查看指定命令所在路径</li>
<li>pwd： 查看当前所在路径</li>
<li>rmdir:删除空目录</li>
<li>rm : rm file <code>rm dir -rf</code> f强制删除</li>
<li>cp </li>
<li>mv</li>
<li>cat</li>
<li>tac</li>
</ul>
<p>软连接：快捷方式</p>
<p><code>ln -s file file.s</code>创建软连接</p>
<p>为保证软连接可以随意移动，需保证用绝对路径创建</p>
<p>硬链接：</p>
<p><code>ln file file.h</code>增加硬链接文件计数，共享Inode</p>
<ul>
<li><p>whoami</p>
<p><code>sudo su</code>切换root用户</p>
</li>
<li><p>chmod </p>
<p><code>chmod u+x a.c</code>给所有者添加可执行权限</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">u表示用户</span><br><span class="line">g表示同组用户</span><br><span class="line">o表示其他用户</span><br><span class="line"><span class="keyword">a</span>表示所有用户</span><br></pre></td></tr></table></figure>
<p>rwx r:4 w:2 x:1</p>
<p><code>chmod 471 a.c</code></p>
</li>
<li><p>chown</p>
<p><code>sudo chown new_user a.c</code>更改文件所有者</p>
</li>
<li><p>adduser</p>
<p>sudo adduser 新用户名</p>
</li>
<li><p>addgroup 创建用户组</p>
<p><code>sudo addgroup g88</code></p>
</li>
<li><p>chgrp</p>
<p><code>sudo chgrp g88 a.c</code></p>
<p><code>sudo chown nobody:nogroup a.c</code>同时修改用户和用户组</p>
</li>
<li><p>deluser</p>
<p><code>sudo deluser wangwu</code></p>
</li>
<li><p>find</p>
</li>
</ul>
<p><code>find ./ -type &#39;l&#39;</code>查找当前目录下软连接</p>
<p><code>find ./ -name &#39;*.jpg&#39;</code>按文件名搜索</p>
<p><code>find ./ -maxdepth 1 - name &#39;*.jpg&#39;</code>指定搜索层级</p>
<p><code>find ./ -size +20M -size -50M</code>文件大小</p>
<p><code>-atime -mtime -ctime</code></p>
<p><code>find ./ -ctime 1</code> 当天内修改过</p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -exec ls -l &#123;&#125; \;</code></p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -ok rm -r &#123;&#125; \;</code></p>
<ul>
<li><p>grep 找文件内容</p>
<p><code>grep -r &#39;copy&#39; ./ -n</code> -n显示行号</p>
</li>
<li><p>ps</p>
<p><code>ps aux</code> </p>
<p><code>ps aux |grep &#39;kernel&#39;</code></p>
</li>
</ul>
<p>find ./ -type f | xargs ls -l </p>
<p>-xargs :将find搜索的结果集执行某一命令，当结果集数量过大时，可以分片映射</p>
<p>-print0:</p>
<p><code>find /usr/ -name &quot;*tmp*&quot; -print0 | xargs print0 ls -l</code></p>
<p>awk 按列拆分，sed按行拆分</p>
<ul>
<li>软件安装：</li>
</ul>
<p><code>sudo apt-get update</code>更新软件源列表</p>
<p>卸载<code>sudo apt-get remove</code></p>
<p>安装deb文件</p>
<p>sudo dpkg -i xx.deb</p>
<p>源码安装：</p>
<p>   1.解压缩代码包</p>
<ol>
<li><p>cd dir</p>
</li>
<li><p>./configure</p>
<p>检测文件是否缺失，创建makefile，检测编译环境</p>
</li>
<li><p>make</p>
<p>编译源码，生成库和可执行文件</p>
</li>
<li><p>sudo make install</p>
<p>把库和可执行程序安装到系统路径下</p>
</li>
<li><p>sudo make distclean</p>
<p>删除和卸载软件</p>
</li>
</ol>
<p>压缩</p>
<ul>
<li><p>tar</p>
<p><code>tar zcvf 要生成的压缩包名 压缩材料</code> z: 调用gzip, c： creat, v：显示压缩过程，可以没有，f生成文件名</p>
<p>先调用gzip 然后调用tar打包</p>
</li>
<li><p>gzip</p>
<p><code>gzip 文件名</code>压缩一个文件</p>
<p><code>gzip a.c</code> 得到a.c.gz</p>
</li>
<li><p>bzip2</p>
<p><code>tar jcvf test.tar.gz file1 dir2</code></p>
</li>
<li><p>解压，将压缩命令中的c替换为x</p>
</li>
<li><p>rar </p>
<p><code>rar a -r newdir dir</code></p>
<p>解压</p>
<p><code>unrar x rartest.rar</code></p>
</li>
</ul>
<p><code>sudo aptitude show tree</code>显示软件是否安装</p>
<ul>
<li><p>zip </p>
<p><code>zip -r dir.zip dir</code></p>
<p>解压</p>
<p>unzip dir.zip</p>
</li>
<li><p>who </p>
</li>
<li>jobs当前后台运行的作业</li>
<li>fg 前台</li>
<li>bg后台</li>
<li>kill</li>
<li>env 环境变量</li>
<li>top 任务管理器</li>
</ul>
<p>设置密码</p>
<p>sudo passwd 用户名</p>
<p>切换用户</p>
<p>su 用户名</p>
<ul>
<li>ifconfig 查看ip地址</li>
<li>man 查看手册</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.可执行程序或<span class="keyword">shell</span><span class="bash">命令</span></span><br><span class="line"><span class="number">2</span>.系统调用</span><br><span class="line"><span class="number">3</span>.库调用</span><br><span class="line"><span class="number">5</span>.文件格式、规范</span><br><span class="line"><span class="number">9</span>.内核例程</span><br></pre></td></tr></table></figure>
<ul>
<li>alias 起别名</li>
<li>unmask 指定用户创建文件时的掩码</li>
<li>创建终端Ctrl+Shift +t</li>
<li>切换标签Alt+n</li>
<li>新开终端Ctrl+Shift + n</li>
</ul>
<p>光标移动到第一个字符contrl+a</p>
<p>移动到最后一个字符contrl+e</p>
<p>清空输入control+u</p>
<p>空目录大小4096</p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><ul>
<li><p>命令模式i a o,I A O,s S切换到文本模式,:切换到末行模式，zz保存退出</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">i:</span>插入光标前一个字符</span><br><span class="line"><span class="symbol">I:</span>插入行首</span><br><span class="line"><span class="symbol">a:</span>插入光标后一个字符</span><br><span class="line"><span class="symbol">A:</span>插入行末</span><br><span class="line"><span class="symbol">o:</span>向下新开一行，插入行首</span><br><span class="line"><span class="symbol">O:</span>向上新开一行，插入行首</span><br><span class="line"><span class="symbol">s:</span>删除当前字符，插入</span><br><span class="line"><span class="symbol">S:</span>删除当前行，插入</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>文本模式ESC切换到文本模式</p>
</li>
<li><p>末行模式w:保存 q:退出，两次ESC回到命令模式</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">h：左移</span><br><span class="line"><span class="symbol">j:</span>下移</span><br><span class="line"><span class="symbol">k:</span>上移</span><br><span class="line"><span class="symbol">l:</span>右移</span><br><span class="line"></span><br><span class="line">跳转到指定行</span><br><span class="line"><span class="number">1</span>.88G(命令模式)</span><br><span class="line"><span class="number">2</span>.<span class="symbol">:</span><span class="number">88</span>(末行模式)</span><br><span class="line"></span><br><span class="line">跳转文件首：</span><br><span class="line">gg(命令模式)</span><br><span class="line"></span><br><span class="line">跳转文件尾</span><br><span class="line">G(命令模式)</span><br><span class="line"></span><br><span class="line">自动格式化程序：</span><br><span class="line">gg=G(命令模式)</span><br><span class="line"></span><br><span class="line">括号对应：</span><br><span class="line"><span class="string">%(命令模式)</span></span><br><span class="line"></span><br><span class="line">删除单个字符</span><br><span class="line">x(命令模式)</span><br><span class="line"></span><br><span class="line">删除单词</span><br><span class="line">dw(光标置于首字母)</span><br><span class="line"></span><br><span class="line">删除光标至行尾</span><br><span class="line">D或d$</span><br><span class="line"></span><br><span class="line">删除光标到行首</span><br><span class="line">d0</span><br><span class="line"></span><br><span class="line">光标移至行首</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">光标移至行尾</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">替换单个字符</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line">删除指定区域：</span><br><span class="line">按v切换为可视模式，使用hjkl来选中待删除区域，按d删除该区域数据</span><br><span class="line"></span><br><span class="line">删除指定行</span><br><span class="line">dd</span><br><span class="line"></span><br><span class="line">删除指定N行</span><br><span class="line">ndd</span><br><span class="line"></span><br><span class="line">粘贴<span class="symbol">:</span></span><br><span class="line">p粘至光标所在下一行</span><br><span class="line">P粘在光标所在上一行</span><br><span class="line"></span><br><span class="line">复制一行：</span><br><span class="line">yy</span><br><span class="line"></span><br><span class="line">复制多行：</span><br><span class="line">nyy</span><br><span class="line"></span><br><span class="line">查找</span><br><span class="line"><span class="number">1</span>.找设想内容</span><br><span class="line">命令模式下，按“/”输入欲搜索关键字，回车，使用n检索下一个</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.找 看到的内容</span><br><span class="line">将光标置于任意一个字符上，按“*、<span class="comment">#”查找</span></span><br><span class="line"></span><br><span class="line">单行替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:s</span> /源字符串/替换字符串</span><br><span class="line"></span><br><span class="line">通篇替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:%s</span> /源字符串/替换字符串 只替换每一行首个</span><br><span class="line"><span class="symbol">:%s</span> /源字符串/替换字符串/g 替换所有</span><br><span class="line"></span><br><span class="line">指定行替换</span><br><span class="line">末行模式</span><br><span class="line"><span class="symbol">:</span>起始行号，终止行号s /源字符串/替换字符串/g </span><br><span class="line"></span><br><span class="line">撤销：</span><br><span class="line">u</span><br><span class="line"></span><br><span class="line">反撤销：</span><br><span class="line">Ctrl + r</span><br><span class="line"></span><br><span class="line">分屏</span><br><span class="line"><span class="symbol">:sp</span> 横屏分 Ctrl + ww切换</span><br><span class="line"><span class="symbol">:vsp</span> 竖屏分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">跳转至man手册</span><br><span class="line">将光标置于待查看函数单词，使用K跳转，(指定卷：nK</span><br><span class="line"></span><br><span class="line">查看宏定义</span><br><span class="line">将光标置于待查看宏定义单词，[ d</span><br><span class="line"></span><br><span class="line">末行模式<span class="symbol">:</span>! 执行shell 命令</span><br></pre></td></tr></table></figure>
<p>配置vim</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">1. <span class="string">/etc/vim/vimrc</span></span><br><span class="line">2. ~<span class="string">/.vimrc</span></span><br><span class="line">~<span class="string">./vimrc</span>优先级高</span><br></pre></td></tr></table></figure>
<h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><p>预处理 gcc -E 展开宏、头文件，替换条件编译，删除注释、空白，空行</p>
<p>编译 gcc -S 检查语法规范 编译消耗时间最多</p>
<p>汇编：gcc -c将汇编指令翻译成机器指令</p>
<p>链接：无参数 数据段合并，地址回填</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-I 指定头文件</span></span><br><span class="line">头文件与.c文件不在同一目录</span><br><span class="line">gcc -I ./inc hello.c -o hello</span><br><span class="line"></span><br><span class="line"><span class="deletion">-c 只做预处理、编译、汇编</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-g: 编译时添加调试信息</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-On （n = 0-3） 编译优化</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-Wall 提示更多警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-D&lt;DEF&gt; 编译时定义宏</span></span><br><span class="line">gcc hello.c -D HELLO</span><br></pre></td></tr></table></figure>
<h3 id="动态库、静态库"><a href="#动态库、静态库" class="headerlink" title="动态库、静态库"></a>动态库、静态库</h3><p>提高编译效率</p>
<p>静态库：对空间要求较低，对时间要求较高的核心程序</p>
<p>动态库：对时间要求较低，对空间要求较高</p>
<p>只做静态库的方法：静态库lib开头 .a结尾</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ar</span> <span class="selector-tag">rcs</span> <span class="selector-tag">libmylib</span><span class="selector-class">.a</span> <span class="selector-tag">file1</span><span class="selector-class">.o</span>（得先编译成<span class="selector-class">.o</span>文件)</span><br></pre></td></tr></table></figure>
<p>1.将.c生成.o文件</p>
<p>gcc -c add.c -o add.o</p>
<p>2.使用ar工具制做静态库</p>
<p>ar rcs libmymath.a add.o sub.o</p>
<p>编译错误会有行号信息，链接错误没有行号，显示ld returned 1 exit status</p>
<p>3.使用静态库：</p>
<p><code>gcc test.c libmathlib.a -o test</code></p>
<p><code>gcc test.c ./lib/libmath.a -o a.out -I ./inc</code></p>
<p>lib 存放.a文件</p>
<p>inc 存放相应头文件,必须有相应头文件，记录函数声明信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防卫式声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MYMATH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MYMATH_H_</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div1</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>动态库制作</p>
<p>1、将.c生成.o文件（生成与位置无关的代码 -fPIC）</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span> -o <span class="keyword">add</span>.o -fPIC</span><br></pre></td></tr></table></figure>
<p>2.使用gcc -shared 制作动态库</p>
<p>gcc -shared -o lib库名.so add.o sub.o div.o</p>
<p>3.编译可执行程序时，指定所使用的动态库，-l指定库名，-L指定库路径</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">gcc test.c -o a.<span class="keyword">out</span> -lmymath -L ./<span class="class"><span class="keyword">lib</span> -<span class="title">I</span> ./<span class="title">inc</span></span></span><br></pre></td></tr></table></figure>
<p>4.运行可执行程序出错</p>
<p>原因：</p>
<p>链接器：工作于链接阶段，工作时需要-l,和-L</p>
<p>动态链接器：工作于程序运行阶段，工作时需提供动态库所在的目录地址</p>
<p>1.通过环境变量设置<code>export LD_LIBRARY_PATH = 动态库路径</code> 临时生效，重启终端环境变量失效 环境变量只与进程有关</p>
<p>2.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">永久生效</span><br><span class="line">1）</span><br><span class="line">vi ~/.bashrc//改变bash环境变量</span><br><span class="line">2）写入 <span class="built_in">export</span> LD_LIBRARY_PATH= 动态库路径 保存</span><br><span class="line">3）使环境变量生效</span><br><span class="line">. .bashrc 或者 <span class="built_in">source</span> .bashrc 或者 重启终端</span><br></pre></td></tr></table></figure>
<p><code>ldd a.out</code> 查看a.out 加载哪些动态库，及动态库路径</p>
<p>3.直接把动态库放到与标准c库一起，</p>
<p> <code>cp libmymath.so /lib</code></p>
<ol>
<li><p>配置文件法</p>
<p>1）sudo vi /etc/ld.so.conf</p>
<p>2）写入动态库绝对路径 保存</p>
<p>3） sudo ldconfig -v 使配置文件生效</p>
<p>ldd a.out 查看，失败not found</p>
</li>
</ol>
<p>数据段合并</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20211004203908020.png" alt="image-20211004203908020"></p>
<p>连接时会把.text段和.rodata段合并,.data段和.bss段合并，节省空间</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>-g 使用该参数编译可执行程序</p>
<p>gdb a.out</p>
<p>基础指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>: <span class="built_in">list</span> <span class="number">1</span> <span class="comment">//列出源码。根据源码指定行号设置断点</span></span><br><span class="line">b <span class="number">52</span> <span class="comment">//break 在52行设置断点</span></span><br><span class="line">run/r <span class="comment">//run</span></span><br><span class="line">n/next <span class="comment">//next,下一条指令，如果当前断点是函数则不进入函数</span></span><br><span class="line">s/step <span class="comment">//step，下一条指令，进入函数</span></span><br><span class="line">p/print :p i<span class="comment">//print i</span></span><br><span class="line"><span class="keyword">continue</span>: 继续执行断点后续指令</span><br><span class="line">quit: 退出gdb当前调试</span><br></pre></td></tr></table></figure>
<p>其他指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">使用run查找段错误位置</span><br><span class="line">finish 结束当前函数调用，回到调用点</span><br><span class="line">start 启动调试</span><br><span class="line">    </span><br><span class="line"><span class="built_in">set</span> args 设置命令行参数</span><br><span class="line">run 后面也能加命令行参数</span><br><span class="line">run argv[<span class="number">1</span>] argv[<span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">info b 断点信息表</span><br><span class="line">    </span><br><span class="line">b <span class="number">41</span> <span class="keyword">if</span> i = <span class="number">4</span> <span class="comment">//条件断点</span></span><br><span class="line">    </span><br><span class="line">ptype j <span class="comment">//查看变量类型</span></span><br><span class="line">    </span><br><span class="line">bt/backtrace 查看栈帧信息</span><br><span class="line"></span><br><span class="line">frame <span class="number">1</span> 切换栈帧</span><br><span class="line">    </span><br><span class="line">display i <span class="comment">//设置追踪i</span></span><br><span class="line"></span><br><span class="line">undisplay 编号<span class="comment">//取消跟踪变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> 删除断点</span><br></pre></td></tr></table></figure>
<p>栈帧：随着函数调用而在stack上开辟的一片内存空间，用于存放函数调用而产生的局部变量和临时值</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><ul>
<li><p>1个规则</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">目标：依赖条件</span><br><span class="line">	（一个tab缩进）命令</span><br><span class="line"><span class="section">test: test.c</span></span><br><span class="line">	gcc -o test test.c</span><br><span class="line"></span><br><span class="line"><span class="section">hello: hello.o</span></span><br><span class="line">	gcc hello.o -o hello</span><br><span class="line">	 </span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o </span><br></pre></td></tr></table></figure>
<p>all:指定makefile的终极目标</p>
</li>
</ul>
<p>1、目标的时间必须晚于依赖条件的时间，否则，更新目录</p>
<p>2、依赖条件不存在，找寻新的规则去产生依赖</p>
<ul>
<li><p>2个函数</p>
<p>wildcard </p>
<p>patsubst</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#找到当前目录所有后缀为.c的文件赋值给src,将文件名组成列表赋值给变量src</span></span><br><span class="line"></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c %.o <span class="variable">$(src)</span>)</span></span><br><span class="line"><span class="comment">#将参数3中，包含参数1的部分，替换为参数2</span></span><br><span class="line"><span class="comment">#把src变量里所有后缀为.c的文件替换为.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:#(没有依赖)</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out <span class="comment">#-rm 出错依然执行</span></span><br></pre></td></tr></table></figure>
<p>make clean -n//尝试执行，但不真正执行</p>
</li>
</ul>
<ul>
<li>3个自动变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span>:在规则的命令中表示规则中的目标</span><br><span class="line"><span class="variable">$&lt;</span>：在规则的命令中，表示第一个依赖条件,如果将该变量应用在模式规则中，它可将依赖列表中的依赖依次取出，套用规则</span><br><span class="line"><span class="variable">$^</span>：在规则的命令中，表示所有依赖条件</span><br><span class="line"></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span><span class="comment"># add.c sub.c hello.c</span></span><br><span class="line">obj = <span class="variable">$(subsubst %.c %.o <span class="variable">$(src)</span>)</span><span class="comment"># add.o sub.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">All:a.out</span></span><br><span class="line"></span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out</span><br></pre></td></tr></table></figure>
<p>模式规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span><span class="comment"># add.c sub.c hello.c</span></span><br><span class="line">obj = <span class="variable">$(subsubst %.c %.o <span class="variable">$(src)</span>)</span><span class="comment"># add.o sub.o hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">All:a.out</span></span><br><span class="line"></span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> a.out</span><br></pre></td></tr></table></figure>
<p>静态模式规则</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>:%.o:%.c</span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>生成伪目标</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean ALL</span></span><br></pre></td></tr></table></figure>
<p>调加参数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">myArgs = -Wall -g</span><br><span class="line"><span class="section">a.out:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br></pre></td></tr></table></figure>
<p>makefile 名字为m1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f m1</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p>-n模拟执行make,make clean 命令</p>
<p>-f：指定文件执行make命令</p>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><p>系统调用</p>
<ul>
<li>open 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> num)</span></span>;<span class="comment">//根据error num 返回错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags)</span></span>;<span class="comment">//O_RDONLY O_WRONLY ORDWR O_CREAT O_APPEND O_EXCL（检查文件是否存在） O_TRUNC（把文件清零） O_NONBLOCK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags,<span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//不是C语言支持重载，而是open支持可变参数</span></span><br><span class="line"><span class="comment">//返回新的文件描述符，错误返回-1，并设置errno</span></span><br><span class="line"><span class="comment">//mode_t 8进制整数 读写执行权限，需要创建时指定，同时权限受unmask限制 mode&amp;~unmask</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> count)</span></span>;<span class="comment">//count缓冲区大小</span></span><br><span class="line"><span class="comment">//成功返回读取得到的字节数,失败返回-1</span></span><br><span class="line"><span class="comment">//-1 并且errno = EAGIN 或EWOULDBLOCK说明不是read失败，而是read在以非阻塞方式读一个设备文件(网络文件），并且文件无数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> count)</span></span>;<span class="comment">//count实际写出内容的大小</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open argv1 error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open argv2 error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((n = read(fd1,buf,<span class="number">1024</span>))!= <span class="number">0</span>)&#123;</span><br><span class="line">        write(fd2,buf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>strace 跟踪程序运行时所进行的系统调用</p>
<p>系统缓冲区</p>
<p>read write无缓冲IO</p>
<p>预读入缓输出</p>
<ul>
<li><p>文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stdin</span> <span class="number">0</span> STDIN_FILENO</span><br><span class="line"><span class="built_in">stdout</span> <span class="number">1</span> STDOUT_FILENO</span><br><span class="line"><span class="built_in">stderr</span> <span class="number">2</span> STDERR_FILENO</span><br></pre></td></tr></table></figure>
<p>最多1024个，新建文件描述符是目前进程最小可用的描述符</p>
</li>
<li><p>阻塞、非阻塞:</p>
<p>阻塞是设备文件、网络文件的属性</p>
<p>读常规文件是不会阻塞的</p>
<p>产生阻塞的场景：读设备文件，读网络文件</p>
<p>/dev/tty —终端文件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> fd,n;</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    tryagain:</span><br><span class="line">        n = read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EAGAIN)&#123;</span><br><span class="line">                perror(<span class="string">&quot;read STDIN_FILENO&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                write(STDOUT_FILENO,<span class="string">&quot;try again\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>));</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">goto</span> tryagain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fcntl函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,...<span class="comment">/*arg*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> flags,n;</span><br><span class="line">    flags = fcntl(STDIN_FILE,F_GETFL);<span class="comment">//获取stdin属性信息</span></span><br><span class="line">    <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(STDIN_FILENO,FSETFL,flags);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取文件状态 F_GETFL</p>
<p>设置文件状态 F_SETFL</p>
<ul>
<li><p>lseek</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">whence <span class="comment">//SEEK_SET SEEK_SET SEEK_END</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>文件读写使用同一偏移位置</p>
</li>
<li><p>使用lseek获取、</p>
</li>
<li>拓展文件大小，要使文件大小真正发生变化，需要发生IO操作 </li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trunate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;<span class="comment">//拓展一个现有文件大小</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>od -tcx filename 查看文件的16进制表示</p>
<p>od -tcd filename 查看文件的10进制表示</p>
<ul>
<li><p>传入参数</p>
<p>1.指针作为函数参数</p>
<p>2.const 修饰</p>
<p>3.指针指向有效区域，在函数内部做读入操作</p>
</li>
<li><p>传出参数</p>
<p>1.指针作为函数参数</p>
<p>2.指针指向的空间可以无意义，但有效</p>
<p>3.函数对其进行写操作</p>
<p>4.函数调用后，充当返回值</p>
</li>
<li><p>传入传出参数</p>
<p>1.指针作为函数参数</p>
<p>2.在函数调用前，指针指向的空间有意义</p>
<p>3.在函数内部，先读后写</p>
<p>4.函数调用结束后，充当函数返回值</p>
</li>
</ul>
<ul>
<li><p>inode 本质为结构体，存储文件属性信息</p>
</li>
<li><p>dentry 目录项： 文件名、inode号 硬链接，相同inode,不同dentry</p>
</li>
<li><p>stat 获取文件属性 (从inode中获取)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,struct stat * buf)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    path:文件路径</span><br><span class="line">     buf:传出参数，存放文件属性</span><br><span class="line">获取文件大小： buf.st_size</span><br><span class="line">获取文件类型： buf.st_mode</span><br><span class="line">获取文件权限： buf.st_mode</span><br></pre></td></tr></table></figure>
<p>stat符号穿透，stat检查符号链接时，直接获取符号链接引用的真正文件信息</p>
<p>lstat不会进行符号穿透</p>
<p>vim,cat会穿透符号链接，ls -l 不会</p>
</li>
<li><p>link 函数：创建硬链接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>unlink 函数:删除一个文件的目录项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>unlink :如果文件硬链接数到0了，但该文件仍不会马上释放，需等到所有打开该文件的进程关闭</p>
</li>
<li><p>symlink创建符号链接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> * newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<p>readlink读软连接本身</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readlink t.soft</span><br></pre></td></tr></table></figure></li>
<li><p>readlink</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path,<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>rename</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath,<span class="keyword">const</span> <span class="keyword">char</span> * newpath)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>getcwd:获取工作目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>chdir：改变工作目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文件权限</p>
<p>r:目录可以被浏览</p>
<p>w:创建删除修改文件</p>
<p>x:可以被进入</p>
</li>
<li><p>opendir函数 库函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR*<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>closedir</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>readdir</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR*dirp)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    close(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span> * name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readdir</span><span class="params">(<span class="keyword">char</span> *dir)</span></span>&#123;</span><br><span class="line">    DIR *dp = opendir(dir);</span><br><span class="line">    <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span>((sdp = readdir(dp))!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sdp-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(name,<span class="string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);</span><br><span class="line">        isFile(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isFile</span><span class="params">(<span class="keyword">char</span> * name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    ret = stat(name, &amp;sb);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;</span><br><span class="line">        readdir(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%ld\n&quot;</span>,name,sb.st_size);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;</span><br><span class="line">        isFile(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> isFile(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>dup</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line">oldfd:已有文件描述符</span><br><span class="line">newfd:新文件描述符</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd,<span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">把旧的复制给新的，返回newfd</span><br><span class="line">newfd指向和oldfd一致</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">0</span>);<span class="comment">//0被占用，fcnt使用文件描述符表最小可用文件描述符返回</span></span><br><span class="line"><span class="keyword">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">7</span>);<span class="comment">//7未被占用，可以被使用</span></span><br></pre></td></tr></table></figure>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进程：占用内存、cpu等系统资源</p>
</li>
<li><p>PCB</p>
<p>进程id</p>
<p>进程状态：就绪，运行，挂起，停止</p>
<p>进程切换时需要保存和恢复的一些寄存器值</p>
<p>描述虚拟地址空间信息</p>
<p>描述控制终端的信息</p>
<p>当前工作位置</p>
<p>文件描述符表</p>
<p>和信号相关信息</p>
<p>用户id和组id</p>
<p>会话和进程组</p>
<p>进程可以使用的资源上限</p>
</li>
</ul>
<ul>
<li>环境变量</li>
</ul>
<p>PATH SHELL TERM LANG HOME <code>echo $PATH</code></p>
<ul>
<li><p>进程控制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>进程共享</p>
<p>刚发生父子进程fork之后</p>
<p>全局变量，.data,.text,栈，堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式相同</p>
<p>不同：</p>
<p>进程id,fork返回值，父进程id，进程运行时间，闹钟（定时器），未决信号集</p>
<p>读时共享，写时复制</p>
<p>父子进程共享 文件描述符，mmap映射区</p>
</li>
<li><p>gdb调试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child 跟踪子进程</span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br></pre></td></tr></table></figure></li>
<li><p>exec函数族</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程id不变</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> * arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> <span class="keyword">const</span> * argv[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>execlp，加载一个进程，借助PATH环境变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span><span class="comment">/*相当于argv[0],没啥用*/</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);<span class="comment">//只有execlp出错时才返回-1，否则之后代码不再执行</span></span><br><span class="line">perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execl(<span class="string">&quot;./a.out&quot;</span>,<span class="string">&quot;./a.out&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  只有execve是系统调用</p>
<ul>
<li><p>孤儿进程</p>
<p>父进程先于子进程结束，子进程的父进程将成为init进程</p>
</li>
<li><p>僵尸进程</p>
<p>进程终止，父进程尚未收回，子进程残留资源（PCB)存放于内核中，变为僵尸进程</p>
</li>
<li><p>wait函数（waitpid(-1,&amp;status,0);)</p>
<p>阻塞等待子进程退出</p>
<p>回收子进程残留资源</p>
<p>获取子进程结束状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> the child terminated normally</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">    <span class="keyword">return</span> the <span class="built_in">exit</span> status of the child</span><br><span class="line">WIFSIGNALED(status)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> the child process was terminated by a signal</span><br><span class="line">WTERMSIG(status)</span><br><span class="line">       <span class="keyword">return</span> the number of the signal that caused the child process to <span class="built_in">terminate</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></li>
<li><p>waitpid</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options)</span></span>;<span class="comment">//一次wait/waitpid函数调用，只能回收一个子进程</span></span><br><span class="line">正常回收返回pid</span><br><span class="line">如果设置WNOHANG，子进程未结束，返回<span class="number">0</span></span><br><span class="line"><span class="number">-1</span>：失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>文件，管道，共享内存，消息队列，套接字，命名管道</p>
<p>管道（使用最简单，匿名管道只能用于有血缘关系的进程之间，要共享文件描述符）</p>
<p>信号（开销小，表示信息有限）</p>
<p>共享映射区（无血缘关系）</p>
<p>本地套接字（最稳定，实现复杂度最高）</p>
<ul>
<li><p>管道</p>
<p>pipe函数创建 mkfifo 创建有名管道（伪文件不占用磁盘空间）</p>
<ol>
<li>其本质上是一个伪文件</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端</li>
<li>规定数据从管道写段流入，从读端写出</li>
</ol>
<p>管道的原理，管道是为内核使用环形队列机制，借助内核缓冲区（4k)实现</p>
<p>局限性：自己写，不能自己读</p>
<p>​              数据不可反复读</p>
<p>​              半双工通信</p>
<p>​              只能在有血缘关系的进程之间使用</p>
<p>pipe函数：创建并打开管道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line">参数:fd[<span class="number">0</span>]读端</span><br><span class="line">    fd[<span class="number">1</span>]写端</span><br><span class="line">返回：<span class="number">0</span> 成功 <span class="number">-1</span>失败</span><br></pre></td></tr></table></figure></li>
<li><p>管道的读写行为</p>
<ol>
<li><p>读管道 </p>
<ul>
<li><p>管道有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据</p>
<p>管道写端全部关闭，read返回0(读到文件结尾)</p>
<p>写端没有全部关闭，read阻塞等待</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道写端全部关闭，进程异常终止，SIGPIPE</p>
</li>
<li><p>管道写端没有全部关闭</p>
<p>管道已满，write阻塞</p>
<p>管道未满，write将数据写入，并返回实际写入字节数</p>
</li>
</ul>
</li>
</ol>
<p>可以有一个写端，多个读端，或者一个读端，多个写端</p>
</li>
<li><p>ulimit -a 查看打开文件个数，pipe缓存区大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>FIFO命名管道</p>
<p>解决没有关系进程之间的通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfifo myfifo</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文件进程通信</p>
</li>
<li><p>存储映射IO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;<span class="comment">//创建共享内存</span></span><br><span class="line">参数：</span><br><span class="line">    addr：指定映射区的首地址，通常传<span class="literal">NULL</span>,表示让系统自动分配</span><br><span class="line">    length:共享内存大小（&lt;=文件实际大小）</span><br><span class="line">    prot:共享内存映射区的读写权限 PROT_READ PROT_WRITE PROT_NONE PROT_EXEC</span><br><span class="line">    flags:标志共享内存共享属性：MAP_SHARED MAP_PRIVATE（对内存的修改不会反应到磁盘上）</span><br><span class="line">    fd:用于创建共享内存映射区的文件描述符</span><br><span class="line">    offset：默认<span class="number">0</span>，表示映射文件全部，偏移位置，必须是<span class="number">4</span>k的整数倍</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">        成功：映射区首地址</span><br><span class="line">        失败： MAP_FAILED,(<span class="keyword">void</span>*)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> munmap(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length);释放映射区</span><br><span class="line">addr:mmap返回值</span><br><span class="line">length:大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mann.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    perror(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;testmp&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lseek(fd,10,SEEK_END);</span></span><br><span class="line"><span class="comment">    write(fd,&#x27;\0&#x27;,1); //相当于ftruncate()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ftruncate(fd,<span class="number">20</span>);<span class="comment">//需要写权限</span></span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---%s\n&quot;</span>,p);</span><br><span class="line">    <span class="keyword">int</span> ret = munmap(p,len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<p>1.用于创建映射区文件大小为0，实际指定非零大小创建映射区，会造成SIGBUS</p>
<p>2.用于创建映射区文件大小为0，实际指定0大小创建映射区，invalid argument</p>
<p>3.用于创建映射区的文件读写属性为只读，实际mmap指定写，会造成invalid argument</p>
<p>4.创建映射区隐含一次read操作，需要read权限，mmap读写权限，映射区访问权限为SHARED时，应该不超过文件的open权限，文件只读open没发建立映射区</p>
<p>5.文件描述符fd在mmap创建后即可关闭，后续文件可以通过地址访问</p>
<p>6.offset必须是4k整数倍（MMU映射的最小单位为4k)</p>
<p>7.对申请的内存越界访问未定义</p>
<p>8.munmap释放的地址，必须是mmap申请的地址</p>
<p>9.映射区访问权限为私有，对内存的修改只跟内存有关，跟磁盘无关</p>
<p>10.映射区访问权限为私有，只需要open文件时有读权限，用于创建映射区即可</p>
</li>
<li><p>mmap</p>
<p>1.open(“文件名”,O_RDWR)</p>
<p>2.mmap(NULL,有效文件大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</p>
</li>
<li><p>父子间mmap通信，需设置flag为MAP_SHARED，否则父子进程各有一份映射区</p>
<p>父进程先创建映射区open（O_RDWR) mmap(MAP_SHARED)</p>
<p>指定MAP_SHARED权限</p>
<p>fork()创建子进程</p>
<p>一个进程读，一个进程写</p>
</li>
<li><p>无血缘关系进程之间mmap通信</p>
<p>两个进程打开同一个文件，创建映射区</p>
<p>指定flags为MAP_SHARED</p>
<p>一个进程写入，另一个进程读出，同一个文件mmap映射区是同一个位置</p>
<p>无血缘关系进程间通信 mmap：数据可以重复读取</p>
<p>​                                       fifo:数据只能一次读取</p>
</li>
<li><p>匿名映射：只能用于有血缘关系进程之间通信</p>
<p>使用MAP_ANONYMOUS（或者MAP_ANON)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//fd -1</span></span><br></pre></td></tr></table></figure>
<p>不支持ANONYMOUS的操作系统，可以打开/dev/zero，大小想要多大有多大</p>
<p>/dev/null</p>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>简单，不能携带大量信息，满足某个特设条件才发送</p>
<p>信号的特质：</p>
<p>信号时软件层面的中断，一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令</p>
<p>所有信号的产生和处理都是内核完成的</p>
<p>产生信号：</p>
<ol>
<li>按键产生，Ctrl+C Ctrl + Z Ctrl + \</li>
<li>系统调用产生 kill raise abort</li>
<li>软件条件产生，定时器alarm sleep借助alarm实现</li>
<li>硬件异常产生，非法访问内存（段错误）、除零，内存对齐出错（总线错误）</li>
<li>命令产生kill命令</li>
</ol>
<p>递达：递送并到达进程,直接被处理掉</p>
<p>未决：产生和抵达之间的状态，主要由于阻塞（屏蔽）导致该状态</p>
<p>信号处理方式：</p>
<p>1。执行默认动作</p>
<p>2.忽略（丢弃）</p>
<p>3.捕获（调用户处理函数）</p>
<ul>
<li><p>阻塞信号集（信号屏蔽字）：本质：位图，用来记录信号的屏蔽状态，将某些信号加入集合，对他们设置屏蔽，当屏蔽信号x后，再收到该信号，该信号的处理将推后（解除屏蔽后）</p>
</li>
<li><p>未决信号集,本质：位图，用来记录信号的处理状态</p>
<p>信号产生，未决信号集中描述该信号的位立即翻转为1，表信号处于未决状态，当信号被处理对应位翻转回0</p>
<p>信号产生后由于某些原因不能抵达（主要是阻塞），这类信号的集合称之为未决信号集，在屏蔽解除时，信号一直处于未决状态</p>
</li>
</ul>
<p>kill -l 列出所有信号</p>
<p>0-31常规信号：都有默认的处理事件和处理动作</p>
<p>34-64实时信号 ：没有默认事件</p>
<ul>
<li><p>信号4要素</p>
<p>1.编号，2.名称 3.信号对应的事件 4.默认处理动作</p>
<p>man 7 signal</p>
<p>SIGHUB 用户退出shell</p>
<p>SIGQUIT <ctrl+\></p>
<p>SIGINT <ctrl+c>终止进程</p>
<p>SIGKILL 无条件终止进程，不能被忽略，处理，阻塞</p>
<p>SIGSTOP停止进程的执行，不能忽略，处理，阻塞</p>
<p>SIGUSR1，SIGUSR2没有默认处理事件，处理动作是终止进程</p>
<p>SIGTERM, kill命令发送的信号，终止进程（不带信号编号）</p>
<p>SIGCHLD:子进程状态发生变化时，父进程接收这个信号，默认动作为忽略这个信号</p>
<p>SIGTSTP：停止中断交互进程的运行<ctrl+z></p>
</li>
<li><p>默认动作</p>
<p>Term：终止进程</p>
<p>Ign忽略信号</p>
<p>Core:终止进程，生成Core文件</p>
<p>Stop:停止（暂停）进程</p>
<p>Cont:继续运行进程</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sid)</span></span>;</span><br><span class="line">pid &gt; <span class="number">0</span> 杀死指定进程</span><br><span class="line">   = <span class="number">0</span> 杀跟调用kill函数的进程处于同一进程组的所有组员</span><br><span class="line">    &lt;<span class="number">-1</span> 取绝对值，发送信号给该绝对值所对应的进程组的所有组员</span><br><span class="line">    =<span class="number">-1</span> 发送信号给有权限的所有进程</span><br></pre></td></tr></table></figure>
<p>  ps ajx查看进程组信息</p>
<p>  kill -SIGKILL -1杀死所有有权限的进程</p>
<p>  发送者实际有效ID == 接收者实际有效ID</p>
<ul>
<li><p>其他几个发信号函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;<span class="comment">//发送信号给调用者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>alarm函数</p>
<p>设置定时器，（闹钟）指定seconds后，发送SIGALRM信号，进程接收到该信号，默认动作终止</p>
<p>每个进程有且只有唯一定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">返回值：无错误</span><br></pre></td></tr></table></figure>
<p>取消定时器alarm(0)返回旧闹钟剩余秒数</p>
<p>定时，与进程状态无关</p>
<p>time指令 查看程序执行的时间<code>time ./alarm</code></p>
<p>实际执行时间=系统时间+用户时间+等待时间</p>
<p>setitimer函数，可以实现周期定时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which,<span class="keyword">const</span> struct itimerval *new_value,struct itimerval *old_value)</span></span>;</span><br><span class="line">new_value 定时秒数</span><br><span class="line">old_value 传出参数，上次定时剩余时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span><span class="comment">/*next value*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span><span class="comment">/*current value*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;<span class="comment">/*seconds*/</span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;<span class="comment">/*microseconds*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_t</span>;</span></span><br><span class="line"><span class="keyword">new_t</span>.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">new_t</span>.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">it_interval 用来设定两次定时任务之间的间隔时间</span><br><span class="line">it_value 定时的时长</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">which</span></span><br><span class="line"><span class="comment">自然计时：ITIMER_REAL -&gt;14)SIGLARM</span></span><br><span class="line"><span class="comment">虚拟空间计时（用户空间）ITIMER_VIRTUAL—&gt;26)SIGVTALRM 计算占用cpu时间</span></span><br><span class="line"><span class="comment">运行时计时（用户+内核）ITIMER_PROF-&gt;27)SIGPROF 计算占用cpu及执行系统调用的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">成功<span class="number">0</span>，失败<span class="number">-1</span></span><br></pre></td></tr></table></figure></li>
<li><p>信号集操作函数</p>
<p>只可以操作阻塞信号集</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;<span class="comment">//typedef unsigned long sigset_t;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集清零</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>)</span></span>;<span class="comment">//将某个信号集置为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//将某个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//删除某个信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>*<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//判断信号是否在信号集，在返回1，不在返回0</span></span><br></pre></td></tr></table></figure>
<p>sigprocmask函数</p>
<p>可以用来屏蔽信号，解除屏蔽</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> sigset*<span class="built_in">set</span>,sigset*oldset)</span></span>;<span class="comment">//成功0，失败-1</span></span><br><span class="line"><span class="built_in">set</span>传入参数，是一个位图</span><br><span class="line">oldset传出参数，保存旧的信号屏蔽集</span><br><span class="line">how参数取值：假设当前信号的屏蔽字为mask</span><br><span class="line">   SIG_BLOCK:<span class="built_in">set</span>表示需要屏蔽的信号，mask = mask|<span class="built_in">set</span></span><br><span class="line">   SIG_UNBLOCK:<span class="built_in">set</span>表示需要解除的信号，相当于mask = mask&amp;~<span class="built_in">set</span></span><br><span class="line">   SIG_SETMASK,替换原来的mask mask = <span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<p>sigpending函数</p>
<p>读取当前进程未决信号集</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//set传出参数</span></span><br></pre></td></tr></table></figure></li>
<li><p>信号捕捉</p>
<p>signal函数</p>
<p>注册一个信号捕捉函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sigaction函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction*act,struct sigaction *oldact)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (*sg_sigaction)(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span> *);<span class="comment">//发送信号携带复杂信息</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;<span class="comment">//只工作于信号捕捉工作时间之中，绝大时候传0</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;<span class="comment">//设置参数，绝大时候传0</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);<span class="comment">//废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>信号捕捉特性</p>
<p>1.进程正常运行时，默认PCB有一个信号屏蔽字，假定为mask，它决定了进程自动屏蔽哪些信号，当注册了某个信号捕捉函数，捕捉到该信号之后，要调用该函数，而该函数有可能执行很长时间，这期间所屏蔽的信号不由mask指定，而由sa_mask指定，调用完信号处理函数，再恢复为mask</p>
<p>2.xxx信号捕捉函数执行期间，相同信号自动被屏蔽</p>
<p>3.阻塞的常规信号不支持排队，产生多次只记录一次</p>
</li>
<li><p>内核实现信号捕捉</p>
<p>1.在执行主控制流程的某条指令时因为中断、异常或系统调用进入内核（用户态）</p>
<p>2.内核处理完异常准备回用户模式之前先处理当前进程中可以递送的信号</p>
<p>3.do_signal()如果信号的处理动作有自定义的信号处理函数则回到用户模式执行信号处理函数</p>
<p>4.信号处理函数返回时执行特殊的系统调用sigreturn再次进入内核（用户态）函数调用之后需要返回调用者</p>
<p>5.sys_sigreturn()返回用户模式，从主控制流程中上次被中断的地方继续向下执行</p>
</li>
<li><p>SIGCHID产生条件</p>
<p>子进程终止时</p>
<p>子进程接收到SIGSTOP信号停止时</p>
<p>子进程处于停止态，接收到SIGCONT后唤醒</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt; <span class="number">0</span>)&#123;<span class="comment">//防止因为处理SIGCHID期间屏蔽SIGCHID，造成一些子进程的SIGCHID丢失导致未回收</span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(status))<span class="comment">//正常退出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d exit %d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))<span class="comment">//被信号退出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child %d cancel signal %d\n&quot;</span>, pid, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中断系统调用</p>
<p>1.慢速系统调用：可能会使进程永远阻塞的系统调用，如果阻塞期间收到一个信号，该系统调用就被中断，不再执行，也可设定系统调用是否重启</p>
<p>2.其他系统调用：getpid getppid fork</p>
<p>慢速系统调用被中断的相关行为，实际上就是pause行为</p>
</li>
</ul>
<p>  可修改sa_flags来设置被信号中断后系统调用是否重启SA_INTERRURT不重启，SA_RESTART重启</p>
<ul>
<li><p>会话</p>
<p>多个进程组的集合</p>
<p>setid函数</p>
<p>创建一个会话，并以自己的ID设置进程组ID，同时也是会话的ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//成功返回0，失败-1并设置errno</span></span><br><span class="line">调用setid函数的进程，既是新会长，也是新组长</span><br></pre></td></tr></table></figure>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3></li>
</ul>
<p>daemon 进程，Linux后台服务进程，通常独立于控制终端，并且周期性执行某种任务，或等待某些发生的事件。通常采用以d结尾的名字</p>
<p>通常运行于操作系统后台，脱离控制终端，一般不与用户进行交互，周期性等待某个事件发生或者周期性执行某一动作</p>
<p>不受用户登录注销影响，通常采用以d结尾的命名方式</p>
<p>创建守护进程：</p>
<ul>
<li><p>创建子进程，父进程退出</p>
<p>所有工作在子进程中进行，形式上脱离了控制终端</p>
</li>
<li><p>在子进程中创建会话</p>
<p>setsid()函数</p>
<p>使子进程完全独立出来，脱离控制</p>
</li>
<li><p>改变当前目录为根目录</p>
<p>chdir()函数</p>
<p>防止占用可卸载文件系统</p>
<p>也可换成其他路径</p>
</li>
<li><p>重设文件权限掩码</p>
<p>umask()函数</p>
<p>防止继承的文件创建屏蔽字拒绝某些权限</p>
<p>增加守护进程灵活性</p>
</li>
<li><p>关闭/重定向文件描述符</p>
<p>0，1，2，继承打开文件不会用到，浪费系统资源，无法卸载</p>
</li>
<li><p>开始执行守护进程核心工作，守护进程退出处理程序模型</p>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程:独立地址空间，拥有PCB，最小资源分配单位</p>
<p>线程：有独立PCB，但没有独立地址空间，最小执行单位</p>
<p>ps -Lf pid —&gt;线程号</p>
<p>页目录（首地址在PCB中），页表，页面</p>
<ul>
<li>轻量级进程，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li>
<li>从内核看线程和进程一样的，但PCB所指的三级页表相同</li>
<li>进程可以蜕变成线程</li>
<li>线程可以看成是寄存器和栈的集合</li>
<li>在linux下，线程是最小的执行单位，晋城市最先的资源分配单位</li>
</ul>
<p>线程共享资源</p>
<ul>
<li>文件描述符表</li>
<li>每个信号处理方式</li>
<li>当前工作目录</li>
<li>用户id,组id</li>
<li>内存地址空间</li>
</ul>
<p>线程非共享资源</p>
<ul>
<li>线程id</li>
<li>处理器现场和栈指针（内核栈）</li>
<li>独立的栈空间</li>
<li>errno变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<p>线程优缺点：</p>
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信，共享数据方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>库函数，不稳定</li>
<li>调试，编写困难，gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<h4 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h4><ul>
<li>pthread_self函数</li>
</ul>
<p>获取线程id,其作用对应进程的getpid()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">线程ID：<span class="keyword">pthread_t</span>类型，本质在linux下为无符号整型，其它系统有可能是结构体</span><br><span class="line">线程ID是进程内部识别标志，(两个进程间可以有线程ID相同)</span><br><span class="line">线程号：标识线程身份，交给CPU选择调度时间</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_create</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;<span class="comment">//成功返回0，失败返回错误号</span></span><br><span class="line">thread 传出参数，新创建线程的子线程id</span><br><span class="line">attr 线程属性,<span class="literal">NULL</span>表示默认参数</span><br><span class="line">start_routine 回调函数</span><br><span class="line">arg 回调函数所需要的参数</span><br><span class="line">传参采用值传递，借助强转</span><br><span class="line">(<span class="keyword">void</span>*)i<span class="comment">//不可是(void*)&amp;i</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_exit</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;<span class="comment">//将当前线程退出</span></span><br><span class="line">retval 退出值，无退出值时，<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>pthread_join函数</p>
<p>阻塞等待线程退出，获取线程退出状态，对应进程中的waitpid()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span> ** retval)</span></span>;成功<span class="number">0</span>，失败错误号</span><br><span class="line">thread 线程ID</span><br><span class="line">retval记录线程结束状态</span><br></pre></td></tr></table></figure></li>
<li><p>pthread_cancel函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  杀死线程,cancel杀死进程需要到达一个取消点(保存点)（系统调用</p>
<p>  子线程没发生系统调用，须要子线程自己添加取消点</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_testcancel();</span><br></pre></td></tr></table></figure>
<p>  如果子线程没有到达取消点，那么pthread_cancel()无效</p>
<p>  被pthread_cancel()杀死的线程返回-1，使用pthread_join回收</p>
<ul>
<li><p>pthread_detach 函数</p>
<p>线程分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;<span class="comment">//成功0，失败错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离之后资源由操作系统自动回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程失败打印错误,perror没用</span></span><br><span class="line">strerror(ret);</span><br><span class="line">检查出错返回</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;xxx error %s\n&quot;</span>,stderror(ret));</span><br></pre></td></tr></table></figure>
<p>线程控制原语：thread_create()  thread_self()   pthread_exit()   pthread_join()  pthread_cacel() pthread_detach()</p>
<p>进程控制原语：fork()                    gepid()             exit() //return    wait()/waitpid() kill()</p>
</li>
<li><p>线程属性初始化</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr)</span></span>;<span class="comment">//成功0，失败：错误号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr)</span></span>;<span class="comment">//成功0，失败：错误号</span></span><br></pre></td></tr></table></figure>
<p>线程分离状态的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">int</span>* detachstate)</span></span>;</span><br><span class="line">attr:已初始化的线程属性</span><br><span class="line">detachstate： PTHREAD_CREATE_DETACHED（分离线程）</span><br><span class="line">              PTHREAD_CREATE_JOINABLE(非分离线程)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><p>线程使用注意事项</p>
<ul>
<li><p>主线程退出其他线程不退出，主线程应调用pthread_exit</p>
</li>
<li><p>避免僵尸进程</p>
<p>pthread_join</p>
<p>pthread_detach</p>
<p>pthread_create 指定分离属性</p>
<p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收栈中的值</p>
</li>
<li><p>malloc和mmap申请的内存可以被其他线程释放</p>
</li>
<li><p>应避免在对多线程模型中调用fork，除非马上exec，子进程只有调用fork的线程存在，其他线程在子进程中均pthread_exit</p>
</li>
<li><p>信号的复杂语义很难与多线程并存，应避免使用信号机制</p>
</li>
</ul>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>线程同步：协同步调，按照预定的先后次序运行</p>
<p>线程同步：指一个线程发出某一个功能调用时，在没有得到结果之前，该调用不返回，同时其他线程为保证数据一致性，不能调用该功能。</p>
<p>锁：建议锁，对公共数据的访问，所有线程应该在访问公共数据前先拿锁再访问，但锁不具有强制性（互斥量）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_init()</span><br><span class="line">pthread_mutex_mutex_destory()</span><br><span class="line">pthread_mutex_lock()</span><br><span class="line">pthread_mutex_trylock()</span><br><span class="line">pthread_mutex_unlock()</span><br><span class="line">返回值：成功<span class="number">0</span>，失败返回错误号</span><br><span class="line"><span class="keyword">pthread_mutex_t</span>类型，本质是一个结构体</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;变量值只有<span class="number">0</span>，<span class="number">1</span>两种</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;<span class="comment">//restrict本指针指向的内存写操作只能由mutex完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> * mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>尽量保证锁的粒度越小越好。</p>
<p>互斥锁，初值为1</p>
<p>加锁 —操作，阻塞线程</p>
<p>解锁++操作，唤醒阻塞在锁上的线程</p>
<p>try锁，尝试加锁，成功—，失败返回，同时设置错误号EBUSY</p>
<ul>
<li><p>死锁:使用锁不恰当导致的现象：</p>
<p>1.对一个锁反复lock</p>
<p>2.两个线程各持有一把锁，请求对方持有的锁</p>
</li>
<li><p>读写锁</p>
<ul>
<li><p>锁只有一把，以读方式加锁，读锁，以写方式加锁，写锁</p>
</li>
<li><p>读共享，写独占</p>
</li>
<li>写锁优先级高</li>
</ul>
<p>读写锁是写模式加锁时，解锁前，所有对该锁的加锁线程都会被阻塞</p>
<p>读写锁是读模式加锁时，如果线程以读模式对其加锁会成功，如果以写模式加锁会阻塞</p>
<p>读写锁是读模式加锁时，同时有以读、写模式加锁的线程请求，会先满足写请求，致使所有线程阻塞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_rwlock_init</span><br><span class="line">pthread_rwlock_destory</span><br><span class="line">pthread_rwlock_rdlock</span><br><span class="line">pthread_rwlock_wrlock</span><br><span class="line">pthread_rwlock_tryrdlock</span><br><span class="line">pthread_rwlock_trywrlock</span><br><span class="line">pthread_rwlock_unlock</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> 类型，用于定义一个读写锁变量</span><br></pre></td></tr></table></figure>
<p>相较于互斥量而言，当读线程多时，提高访问效率</p>
</li>
<li><p>条件变量</p>
<p>条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用，给多线程提供一个会和的场所</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_init函数</span><br><span class="line">pthread_cond_destory</span><br><span class="line">pthread_cond_wait</span><br><span class="line">pthread_cond_timewait</span><br><span class="line">pthread_cond_signal</span><br><span class="line">pthread_cond_broadcast</span><br><span class="line">    </span><br><span class="line"><span class="keyword">pthread_cont_t</span>类型，用于定义条件变量</span><br><span class="line"><span class="keyword">pthread_cont_t</span> cond = PTHREAD_COND_INITIALIZER;<span class="comment">//静态初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>pthread_cond_wait函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span>*<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数作用：</p>
<ul>
<li>阻塞等待条件变量cond满足</li>
<li>释放已掌握的互斥锁，解除互斥量（1，2两步为一个原子操作）<code>pthread_mutex_unlock(&amp;mutex)</code></li>
<li>当被唤醒，pthread_cond_wait返回时，解除阻塞并重新申请获得互斥锁<code>pthread_mutex_lock(&amp;mutex)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>生产者消费者模型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cond不满足)&#123;</span><br><span class="line">   pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>信号量</p>
<p>相当于初始化值为N的互斥量</p>
<p>可应用于进程、线程之间同步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">sem_init</span><br><span class="line">sem_destory</span><br><span class="line">sem_wait<span class="comment">//加锁</span></span><br><span class="line">sem_trywait</span><br><span class="line">sem_timewait</span><br><span class="line">sem_post<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> 本质上是结构体</span><br><span class="line"><span class="keyword">sem_t</span> sem;<span class="comment">//规定信号量sem不能小于0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>*sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">//pshared 0 线程间同步</span></span><br><span class="line">          <span class="number">1</span> 进程间同步</span><br><span class="line"><span class="comment">//value N值（指定同时访问的线程数）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>“cd” does not work in shell script</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tr -d <span class="string">&quot;\r&quot;</span> &lt; oldname.sh &gt; newname.sh</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Effective C++</title>
    <url>/2021/08/14/Effective-C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="尽量以const-enum-inline-替换-define"><a href="#尽量以const-enum-inline-替换-define" class="headerlink" title="尽量以const,enum,inline 替换#define"></a>尽量以const,enum,inline 替换#define</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AspectRatio 1.635</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.635</span>;</span><br></pre></td></tr></table></figure>
<p>class 专属常量，为保证常量只有一份实体，必须让它成为一个static变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Num = <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">int</span> score[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="尽量使用const"><a href="#尽量使用const" class="headerlink" title="尽量使用const"></a>尽量使用const</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greet[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greet;<span class="comment">//non_const pointer non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greet;<span class="comment">//const data, non-const pointer</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greet;<span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greet;<span class="comment">//const pointer,const data</span></span><br></pre></td></tr></table></figure>
<p>如果const出现在星号左边，被指物是常量，出现在星号右边，指针本身是常量。</p>
<p>STL迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();<span class="comment">//相当于T* const</span></span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">//没问题，改变iter所指物</span></span><br><span class="line">++iter;<span class="comment">//不行，iter是const</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin();<span class="comment">//相当于const T*</span></span><br><span class="line">*cIter = <span class="number">10</span>;<span class="comment">//不行，*cIter是const</span></span><br><span class="line">++cIter;<span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>
<p>const 重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Textbook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Textbook(<span class="built_in">std</span>::<span class="built_in">string</span> s):text(s)&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;non const\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> text[pos];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Textbook <span class="title">tb</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Textbook <span class="title">ctb</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只是改变参数const属性不可以重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Textbook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="确定对象在被调用前已经被初始化"><a href="#确定对象在被调用前已经被初始化" class="headerlink" title="确定对象在被调用前已经被初始化"></a>确定对象在被调用前已经被初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;addr,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp;phones):theName(name),theAddr(addr),thePhones(phones)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化列表省了一次调用默认构造函数的代价</p>
<p>为免除跨编译单元之初始化次序问题，用local static对象替换non_local static 对象</p>
<h3 id="构造、析构、赋值操作"><a href="#构造、析构、赋值操作" class="headerlink" title="构造、析构、赋值操作"></a>构造、析构、赋值操作</h3><p>在一个内含reference成员的class内支持赋值操作，必须自己定义copy assignment操作符。</p>
<p>面对内含const成员的class,编译器反应一样。</p>
<p>如果某个base class将assignment操作符声明为private,编译器拒绝为其derived class生成assignment操作符.</p>
<h3 id="不想使用编译器自动生成的函数"><a href="#不想使用编译器自动生成的函数" class="headerlink" title="不想使用编译器自动生成的函数"></a>不想使用编译器自动生成的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Test(<span class="keyword">const</span> Test &amp;);<span class="comment">//只有声明</span></span><br><span class="line">        Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将复制构造函数、copy assignment声明为private,外部不可调用，内部调用会有链接错误</p>
<p>还可以定义一个base类，其复制构造函数、copy assignment为private，子类就不能生成默认构造函数、copy assignment.</p>
<h3 id="为多态基类声明virtual函数"><a href="#为多态基类声明virtual函数" class="headerlink" title="为多态基类声明virtual函数"></a>为多态基类声明virtual函数</h3><p>一个base类指针指向一个derived对象，base类析构函数non-virtual,调用delete时，derived类成员可能未被delete</p>
<p>要实现virtual函数，对象必须携带一些信息。用于在运行时决定哪一个virtual函数被调用</p>
<p>通常是一个所谓的vptr指针指出。</p>
<p>vptr指向一个由函数指针构成的数组，称为vtbl.</p>
<ul>
<li>只有class内含至少一个virtual函数才为析构函数声明为virtual</li>
</ul>
<p>STL容器都带有non-virtual析构函数</p>
<p>纯虚函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数的运作方式：</p>
<p>最深层派生（most derived)的那个class其析构函数最先被调用，然后是其每一个base class的析构函数被调用。</p>
<h3 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h3><h3 id="绝不在构造函数和析构函数中调用virtual函数"><a href="#绝不在构造函数和析构函数中调用virtual函数" class="headerlink" title="绝不在构造函数和析构函数中调用virtual函数"></a>绝不在构造函数和析构函数中调用virtual函数</h3><p>“在base class构造期间，virtual函数不是virtual函数”（会调用base class版本的virtual函数）</p>
<h3 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator=返回一个reference to *this"></a>令operator=返回一个reference to *this</h3><h3 id="在operator-中处理自我赋值"><a href="#在operator-中处理自我赋值" class="headerlink" title="在operator=中处理自我赋值"></a>在operator=中处理自我赋值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//证同测试（identity test)</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp;rhs)&#123;</span><br><span class="line">    Bitmap* POrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)某class的copy assignment操作符可能被声明为’以by value方式接收实参‘</p>
<p>(2)以by value 方式传递东西会造成一份副本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将copy操作从函数本体移至函数参数构造阶段</p>
<h3 id="复制对象时勿忘每一成分"><a href="#复制对象时勿忘每一成分" class="headerlink" title="复制对象时勿忘每一成分"></a>复制对象时勿忘每一成分</h3><p>令copy构造函数调用copy assignment操作无意义，构造函数用来初始化新对象，而assignment操作符只施于已初始化对象身上。</p>
<p>令copy assignment操作符调用copy构造函数不合理，因为这就像在构造一个已经存在的对象。</p>
<p>copy构造函数和copy assignment操作符有相似代码，消除重复代码的做法是，建立一个新的成员函数给二者调用。</p>
<h3 id="以对象资源管理对象"><a href="#以对象资源管理对象" class="headerlink" title="以对象资源管理对象"></a>以对象资源管理对象</h3><ul>
<li><p>获得对象后立刻放进管理对象</p>
</li>
<li><p>管理对象运用析构函数确保资源被释放</p>
<p>share_ptr在其析构函数中调用delete 而不是delete[]</p>
<p>不能在动态分配的array身上使用share_ptr</p>
</li>
</ul>
<h3 id="在资源管理类中小心copying行为"><a href="#在资源管理类中小心copying行为" class="headerlink" title="在资源管理类中小心copying行为"></a>在资源管理类中小心copying行为</h3><ul>
<li>禁止复制</li>
<li>对底层资源祭出引用计数法</li>
</ul>
<p>shared_ptr允许指定所谓的删除器，那是一个函数或函数对象，当引用次数为0时便调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span>:<span class="title">mutexPtr</span><span class="params">(pm,unlock)</span></span>&#123;</span><br><span class="line">            lock(mutexPtr.get());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mutex&gt;mutexPtr;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制底部资源</li>
</ul>
<p>复制资源管理对象时，也应该复制其所包裹的底层资源</p>
<ul>
<li>转移底部资源的所有权</li>
</ul>
<p>某些场合下希望只有一个RAII指向一个（raw resource),即使RAII对象被复制依然如此，此时资源的所有权会从被复制物转移到目标物.</p>
<h3 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h3><p>share_ptr 重载了*，-&gt;运算符，隐式转换至底层资源</p>
<h3 id="成对使用new-和delete时要采取相同的形式"><a href="#成对使用new-和delete时要采取相同的形式" class="headerlink" title="成对使用new 和delete时要采取相同的形式"></a>成对使用new 和delete时要采取相同的形式</h3><p>当使用new,有两件事情发生：第一内存被分配出来，第二，针对此内存会有一个或更多构造函数函数被调用，</p>
<p>当使用delete,有两件事发生：会有一个或多个析构函数被调用，然后内存才被释放</p>
<p>delete最大的问题在于，即将被删除的内存究竟存有多少个对象，这个问题决定了有多少个析构函数必须被调用</p>
<p>唯一让delete知道内存是否存在一个数组大小记录的办法就是在使用delete时加上中括号</p>
<p>==重写不能改变返回值类型，参数列表==</p>
<p>==引用也能实现多态==</p>
<p>成为虚函数的条件：<br>1.要能取地址<br>2.依赖对象调用</p>
<p>==内联函数不能成为虚函数，没法对一个内联函数取地址==</p>
<p>==构造函数 不可以 系统调用 不依赖对象调用==</p>
<p>static函数 不可以 无this指针 不依赖对象调用</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用本质上是一个常量指针，<code>int * const p</code></p>
<p>占用空间情况和指针一致</p>
<p>对引用的修改即是对源数据的修改</p>
<p>引用必须初始化，指针不可以</p>
<p>指针可以赋值为nullptr,没有空引用</p>
<p>没有<code>int &amp; const a</code>,只有<code>const int &amp; a</code></p>
<p>强转运算重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;assignment\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp;&amp;a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//default</span></span><br><span class="line">    A a = A();</span><br><span class="line">    <span class="comment">//default,move</span></span><br><span class="line">    <span class="comment">//没有move会调用copy</span></span><br><span class="line">    A c = C();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有继承：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//都不行， &#x27;A&#x27; is an inaccessible base of &#x27;C&#x27;|</span></span><br><span class="line">    A&amp;&amp; a = C();</span><br><span class="line">    A * a = <span class="keyword">new</span> C();</span><br><span class="line">    A a = C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>const 重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print const\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.print(); <span class="comment">//print,当没有non-const print()时，也输出print const</span></span><br><span class="line">    <span class="keyword">const</span> A b;</span><br><span class="line">    b.print();<span class="comment">//print const,当没有const print(),报错passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print const\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&amp;&amp; a = C();</span><br><span class="line">    a.print();<span class="comment">//输出的是print,类C没有重载A的print()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子类以私有方式重写父类虚函数，通过父类引用、指针可以调用子类相应私有方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//此处print为私有</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&amp;&amp; a = C();</span><br><span class="line">    a.print();<span class="comment">//输出C</span></span><br><span class="line">    C c;</span><br><span class="line">    c.print();<span class="comment">//报错&#x27;virtual void C::print()&#x27; is private within this context</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>纯虚函数是可以有实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">    A(<span class="keyword">int</span> x)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;test A\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A::test();</span><br><span class="line">    &#125;</span><br><span class="line">    B(<span class="keyword">int</span> x):A(x)&#123;<span class="comment">//必须写在初始化列表</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    b.test();</span><br><span class="line">    <span class="comment">//test(1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造函数中==必须写在member initialization list的==</p>
<ul>
<li>初始化一个reference member</li>
<li>初始化一个const member</li>
<li>当调用一个base类的constructor且它有一组参数</li>
<li>当调用一个member类的constructor且它有一组参数</li>
</ul>
<h3 id="段错误的原因"><a href="#段错误的原因" class="headerlink" title="段错误的原因"></a>段错误的原因</h3><ul>
<li><p>访问不存在的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>访问系统保护的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)<span class="number">0</span>; </span><br><span class="line">*ptr = <span class="number">100</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>访问只读的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr = <span class="string">&quot;test&quot;</span>; </span><br><span class="line"><span class="built_in">strcpy</span>(ptr, <span class="string">&quot;TEST&quot;</span>); </span><br></pre></td></tr></table></figure></li>
<li><p>栈溢出 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>double free</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*p) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Why are only <code>static const</code> integral types &amp; enums allowed In-class Initialization?</p>
<p>为什么只有static const integral类型以及enums被允许类内初始化呢？</p>
<p>这个答案就在Bjarne的那段话中。“C++需要每一个对象有特定的定义。如果C++允许存储在内存中的对象进行类内定义，那么这一规则将会被打破。”</p>
<p>注意只有static const integers 会被看作编译时的常量。编译器了解这样的integer变在任何情况下都不会改变，因此编译器才可以对其做出特有的优化与改进，编译器会简单的将其内联化这样的变量，因而不再使其保存在内存中。因为保存在内存中的需求被移除了，使得他们成了Bjane所说规则的例外。</p>
<p>值得注意的是，即使static const integral这样的变量被允许使用类内初始化，但是获取这样的变量的地址是不被允许的。一个变量只有拥有类外定义的情况下，才能被获得地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//要有這句才能過編譯</span></span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;A::x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>静态成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//static member function &#x27;static int A::print()&#x27; cannot have cv-qualifier</span></span><br></pre></td></tr></table></figure>
<p>1.static成员函数不包含<code>this</code>指针<br>2.static成员函数不能为<code>virtual</code><br>3.不能存在static和non-static成员函数有相同的名字和参数<br>4.static 成员函数不能被声明成const、volatile或者const volatile。(可以为inline)</p>
<p>析构函数是私有、删除的情况下，不能在栈上定义对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~A() =<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//A a;</span></span><br><span class="line">    <span class="comment">//use of deleted function &#x27;A::~A()&#x27;</span></span><br><span class="line">    <span class="comment">//因为a离开作用域后会自动调用析构函数</span></span><br><span class="line">    A *a = <span class="keyword">new</span> A();<span class="comment">//允许，不能delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;right\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;left\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;const left\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;const right\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>&amp;&amp; x = <span class="number">2</span>;</span><br><span class="line">   test(x);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp; y = <span class="number">3</span>;</span><br><span class="line">   test(y);</span><br><span class="line">   test(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">left</span></span><br><span class="line"><span class="comment">const left</span></span><br><span class="line"><span class="comment">right</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">setVal() = <span class="number">3</span>;<span class="comment">//允许，返回的是左值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span>&#123;&#125;</span><br><span class="line">test(<span class="number">2</span>);<span class="comment">//不合法，要求传一个左值</span></span><br></pre></td></tr></table></figure>
<p>不能对一个类的构造/析构函数取地址，因为构造函数析构函数没有返回值，不能产生一个有效的函数指针。</p>
<p>成员函数指针占16个字节。为在简单函数指针的后面还需要保存怎样调整 “this” 指针（总是隐式地传递给非静态成员函数）的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A&#x27;s this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> pad0[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&#x27;s this: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> pad2[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> A, B</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    obj.foo();</span><br><span class="line">    obj.bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A&#x27;s this: 0x7fff57ddfb48</span></span><br><span class="line"><span class="comment">B&#x27;s this: 0x7fff57ddfb68</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">“<span class="keyword">this</span>” 指针的值传给 B 的方法要比 A 的方法要大 <span class="number">32</span> 字节——一个类 A 对象的实际大小。</span><br></pre></td></tr></table></figure>
<p><code>g++ -fno-elide-constructors</code>阻止部分编译优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *(*fun(<span class="keyword">int</span>*))(<span class="keyword">int</span>*);</span><br><span class="line">=&gt;fun先与(<span class="keyword">int</span>*)结合，接收一个参数<span class="keyword">int</span>*</span><br><span class="line">  <span class="keyword">int</span> ** fun(<span class="keyword">int</span>*)(<span class="keyword">int</span>*)</span><br><span class="line">=&gt;<span class="keyword">typedef</span> <span class="keyword">int</span>** (*FP)(<span class="keyword">int</span>*);</span><br><span class="line">  FP (<span class="keyword">int</span> *);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>* (*test(<span class="keyword">int</span>* ))(<span class="keyword">int</span>*)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> fun1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>*  (*(*f)(<span class="keyword">int</span>*))(<span class="keyword">int</span>*) = test;</span><br><span class="line">    <span class="comment">//f是一个函数指针，接受一个参数(int*)</span></span><br><span class="line">    <span class="comment">//返回值也是一个函数指针int* (*) (int*)</span></span><br><span class="line">    f(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><ul>
<li>没有所谓空引用</li>
<li>引用必须有初值</li>
<li>使用引用不能测试其有效性</li>
<li>pointer可以重新赋值，指向另一个对象</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>static_cast基本与C旧式转型一致，不能用static_cast将一个struct转为int,或将一个double转为pointer,不能移除const性质</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; (<span class="keyword">size_t</span>)(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//报错了???</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够将任意类型指针转成<code>void*</code>，通过<code>void*</code> 转成其他类型指针</p>
<p>const_cast 用来改变表达式的常量性、易变性</p>
<p>将一个指针或引用去掉const</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = j;</span><br><span class="line"><span class="keyword">int</span> &amp;k = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(i);</span><br><span class="line">k++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(a.c_str());</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a.c_str());</span><br></pre></td></tr></table></figure>
<p>dynamic_cast 安全的向下转型或跨系转型动作</p>
<p><code>dynamic_cast</code> can only cast to a pointer value or reference, dynamic 转换时的类必须有虚函数</p>
<p><code>reinterpret_cast</code>不具有移植性</p>
<h3 id="绝对不要以多态方式处理数组"><a href="#绝对不要以多态方式处理数组" class="headerlink" title="绝对不要以多态方式处理数组"></a>绝对不要以多态方式处理数组</h3><p>基类数组元素大小和derived类不一致，数组产生的偏移不一样</p>
<h3 id="C-的const类型成员函数"><a href="#C-的const类型成员函数" class="headerlink" title="C++的const类型成员函数"></a>C++的const类型成员函数</h3><ul>
<li>在C++中只有被声明为const的成员函数才能被一个const类对象调用</li>
<li>const成员函数可以被对应的具有相同形参列表的非const成员函数重载</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span> <span class="keyword">const</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">const</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法的本质是：void fun (const 类 *this, int a,int b);</p>
<p><strong>本质上，const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针。</strong></p>
<h3 id="重载-lt-运算符"><a href="#重载-lt-运算符" class="headerlink" title="重载&lt;运算符"></a>重载&lt;运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A&amp;a,<span class="keyword">const</span> A&amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">bool</span> A::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A&amp;a)&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==类引用成员、常量指针必须在构造函数初始化列表中完成初始化==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> * y):x(x),y(y)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; x;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><ul>
<li><p>两种函数允许编译器执行类型转换</p>
<p>单自变量constructor</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Name(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator=<span class="number">0</span>,<span class="keyword">int</span> denominator=<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  隐式类型转换操作符</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//将Rational转为double</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="前置后置"><a href="#前置后置" class="headerlink" title="前置后置"></a>前置后置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>++();前置</span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后置，返回const，避免出现i++++</span></span><br><span class="line">&#125;</span><br><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">    UPInt oldValue = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不要重载-，-amp-amp-，及，运算符"><a href="#不要重载-，-amp-amp-，及，运算符" class="headerlink" title="不要重载||，&amp;&amp;，及，运算符"></a>不要重载||，&amp;&amp;，及，运算符</h3><p>函数调用语义会取代骤死式语义</p>
<ul>
<li><p>函数调用动作执行时，所有参数都会被求值</p>
</li>
<li><p>未规定参数求值顺序</p>
</li>
</ul>
<p>逗号表达式从左至右求值</p>
<p>不能重载的运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">. </span><br><span class="line">.* </span><br><span class="line">:: </span><br><span class="line">?:</span><br><span class="line"><span class="keyword">new</span> </span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">sizeof</span></span><br><span class="line"><span class="keyword">typeid</span></span><br><span class="line"><span class="keyword">static_cast</span></span><br><span class="line"><span class="keyword">dynamic_cast</span></span><br><span class="line"><span class="keyword">const_cast</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure>
<h3 id="不同意义的new和delete"><a href="#不同意义的new和delete" class="headerlink" title="不同意义的new和delete"></a>不同意义的new和delete</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br><span class="line"><span class="comment">//new operator</span></span><br></pre></td></tr></table></figure>
<p><code>new operator</code>由语言内建的，类似sizeof,不能改变意义</p>
<p><code>operator new</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以重载，但需保证第一个参数为size_t</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));</span><br></pre></td></tr></table></figure>
<p>operator new 和malloc一样，唯一任务是分配内存</p>
<p><code>placement new</code></p>
<p>有一些分配好的内存上直接构建对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (buffer) Widget();</span><br></pre></td></tr></table></figure>
<p>如果只想处理原始的、未设初值的内存，应该回避new operator 和delete operator,改用operator new 和operator delete</p>
<p>如果使用placement new ，不应该调用delete，调用相应对象析构函数即可</p>
<p><code>operator new[]</code>可以重载</p>
<p>数组版<code>new operator</code>先调用<code>operator new[]</code>分配内存，后为每个元素调用构造函数</p>
<p>数组版delete operator先为每个元素调用析构函数，后调用<code>operator delete[]</code>释放空间</p>
<h3 id="在constructor内阻止内存泄漏"><a href="#在constructor内阻止内存泄漏" class="headerlink" title="在constructor内阻止内存泄漏"></a>在constructor内阻止内存泄漏</h3><p>析构函数只负责析构构造好的对象，构造过程中发生异常不会引发析构函数调用</p>
<h3 id="禁止异常流出destructor"><a href="#禁止异常流出destructor" class="headerlink" title="禁止异常流出destructor"></a>禁止异常流出destructor</h3><p>如果基于exception的因素离开destructor,此时正有另一个exception处于作用状态，c++会调用terminate函数，程序立即结束</p>
<p>如果exception从destruction流出而没得到任何处理，会导致析构函数执行不全</p>
<h3 id="实现shared-ptr"><a href="#实现shared-ptr" class="headerlink" title="实现shared_ptr"></a>实现shared_ptr</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shared_ptr(T *p):ptr(p),_use_count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">    Shared_ptr(Shared_ptr&lt;T&gt;&amp;other):_use_count(&amp;(++(*other._use_count))),ptr(other.ptr)&#123;&#125;</span><br><span class="line">    Shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(Shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*<span class="keyword">this</span> == sp)&#123;<span class="comment">//处理自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++(*sp._use_count);</span><br><span class="line">        --(*<span class="keyword">this</span>-&gt;_use_count);</span><br><span class="line">        <span class="keyword">if</span>(!(*(<span class="keyword">this</span>-&gt;_use_count))&amp;&amp;<span class="keyword">this</span>-&gt;ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> _use_count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_use_count= sp._use_count;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = sp.ptr;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="comment">//返回值是引用，避免当前指针指向派生类对象造成对象切割问题</span></span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Shared_ptr()&#123;</span><br><span class="line">        --(*_use_count);</span><br><span class="line">        <span class="keyword">if</span>(!*_use_count)&#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> _use_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">void</span>*() <span class="comment">//隐式转换，有隐式转换才能写如:if(p) if(!p) if(p == 0)语句 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_use_count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* _use_count;<span class="comment">//动态内存分配，保证所有的Shared_ptr共用一份use_count,节省内存</span></span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">Shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; p.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   Shared_ptr&lt;<span class="keyword">int</span>&gt; c = p;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; p.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; c.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; (*c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出一个exception与传递一个参数差异"><a href="#抛出一个exception与传递一个参数差异" class="headerlink" title="抛出一个exception与传递一个参数差异"></a>抛出一个exception与传递一个参数差异</h3><p>一个对象被抛出无论是以by value和by reference方式传递都会发生复制行为，因为抛出异常时，控制权会离开当前作用域，其他局部变量会被销毁，只能通过复制保存对象状态。</p>
<ul>
<li>即使是静态局部变量，复制行为也会发生</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   B b;</span><br><span class="line">   A&amp;a = b;</span><br><span class="line">   a.print();<span class="comment">//B</span></span><br><span class="line">   A c = a;<span class="comment">//调用A的复制函数，只关注静态类型</span></span><br><span class="line">   c.print();<span class="comment">//A</span></span><br><span class="line">   </span><br><span class="line">   A* x = <span class="keyword">new</span> B;</span><br><span class="line">   x-&gt;print();<span class="comment">//B</span></span><br><span class="line">   A* y = x;</span><br><span class="line">   y-&gt;print();<span class="comment">//B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个被抛出的临时对象可以被左值引用捕捉，不需要<code>by reference-to-const</code>方式，函数调用将一个临时对象传递给一个左值引用是不合法的</p>
<p>by value 方式传递exception,会调用两次复制构造函数，第一次产生一个临时对象，第二次将临时对象复制给参数<code>w</code></p>
<p>by reference只会调用一次复制构造函数，产生一个临时对象</p>
<p>exception和catch子句匹配不会发生隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(someFunction())&#123;</span><br><span class="line">        	<span class="keyword">throw</span> value;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">double</span> d)&#123;<span class="comment">//不会捕捉value</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两种转换可以发生：</p>
<ul>
<li><p>为base class exceptions写的catch子句可以捕捉derived class exceptions</p>
</li>
<li><p>有形指针到无形指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">void</span> *)...<span class="comment">//可以捕捉任意指针类型</span></span><br></pre></td></tr></table></figure>
<p>catch子句以其在源代码中出现的顺序匹配（first fit)。</p>
</li>
</ul>
<p><code>mutable</code>关键字修饰的member成员能在const member functions中改变。实现<code>lazy fetching</code>,对象读取可能需要在const member function内进行</p>
<h3 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h3><p>只要你产生了一个non-heap object而没有为它命名，便诞生了一个临时对象。</p>
<p>此等匿名对象通常发生于：</p>
<ul>
<li>当隐式转换被施行起来以求函数能够调用成功</li>
<li>当函数返回对象的时候</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">countChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buffer[MAX_STRING_LEN];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c &gt;&gt; setw(MAX_STRING_LEN) &gt;&gt; buffer;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;These are &quot;</span>&lt;&lt; countChar(buffer,c);</span><br><span class="line"><span class="comment">//countChar 接收const string &amp;类型，传入的却是char[]</span></span><br><span class="line"><span class="comment">//会调用string的构造器，以buffer为参数生成临时string对象</span></span><br><span class="line"><span class="comment">//当countChar返回时，临时对象自动销毁</span></span><br></pre></td></tr></table></figure>
<p>只有当对象以by value或reference-to-const参数时转换才会发生</p>
<p>如果对象传给一个reference-to-no-const,并不会发生这种转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uppercasify</span><span class="params">(<span class="built_in">string</span> &amp; str)</span></span>;</span><br><span class="line"><span class="keyword">char</span> sub[] = <span class="string">&quot;Effective C++&quot;</span>;</span><br><span class="line">uppercasify(sub);<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//期望是修改原对象，如果允许生成临时对象，修改的只是临时对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Number <span class="keyword">operator</span>+(<span class="keyword">const</span> Number&amp;a,<span class="keyword">const</span> Number&amp;b);</span><br></pre></td></tr></table></figure>
<p>返回值是一个临时对象</p>
<h3 id="返回值优化（RVO"><a href="#返回值优化（RVO" class="headerlink" title="返回值优化（RVO)"></a>返回值优化（RVO)</h3><p>返回所谓<code>constructor arguments</code>以取代对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator()*rhs.numerator(),lhs.denominator(),rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用重载技术避免隐式类型转换"><a href="#利用重载技术避免隐式类型转换" class="headerlink" title="利用重载技术避免隐式类型转换"></a>利用重载技术避免隐式类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x=<span class="number">0</span>):x(x)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许</span></span><br><span class="line">    get() = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//允许</span></span><br><span class="line">    A&amp;&amp;a = get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> x,<span class="keyword">int</span> y):x(x),y(y)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Rational&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Rational&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x*rhs.y + <span class="keyword">this</span>-&gt;y*rhs.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y*rhs.y;</span><br><span class="line">        <span class="keyword">int</span> z = __gcd(<span class="keyword">this</span>-&gt;x,<span class="keyword">this</span>-&gt;y);</span><br><span class="line">        <span class="keyword">this</span>-&gt;x/=z;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y/=z;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回const,避免写出类似a+b = c;表达式</span></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>+(<span class="keyword">const</span> Rational&amp;lhs,<span class="keyword">const</span> Rational &amp;rhs)&#123;</span><br><span class="line">        <span class="comment">//调用的复制构造函数</span></span><br><span class="line">        <span class="keyword">return</span> Rational(lhs) += rhs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">Rational <span class="title">a</span> <span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">   <span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">   a += b;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; a.x &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; a.y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   a = a + b;</span><br><span class="line">   <span class="built_in">cerr</span> &lt;&lt; a.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived::Derived()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果在堆上创建对象，为其分配堆内存；</span></span><br><span class="line"><span class="comment">// operator new的介绍参见条款 8</span></span><br><span class="line"><span class="keyword">if</span> (本对象在堆上)</span><br><span class="line"><span class="keyword">this</span> = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Derived));<span class="comment">//在构造函数内无法知道对象是不是在堆上,对 this 赋值是非法的。  </span></span><br><span class="line">Base::Base(); <span class="comment">// 初始化 Base 部分,cannot call constructor &#x27;Base::Base&#x27; directly, 通过函数调用访问构造函数也是不允许的。</span></span><br><span class="line">dm1.<span class="built_in">string</span>(); <span class="comment">// 构造 dm1</span></span><br><span class="line">dm2.<span class="built_in">string</span>(); <span class="comment">// 构造 dm2</span></span><br><span class="line">dm3.<span class="built_in">string</span>(); <span class="comment">// 通过对象调用访问构造函数也是不允许的。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//operator只能声明成友元</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; str,A&amp;a);</span><br><span class="line"><span class="comment">//第一个参数必须是ostream</span></span><br><span class="line"><span class="comment">//如果反过来就会出现 t &lt;&lt; cout;形式调用</span></span><br></pre></td></tr></table></figure>
<h3 id="不要产生内含local-static对象的inline-non-member-functions"><a href="#不要产生内含local-static对象的inline-non-member-functions" class="headerlink" title="不要产生内含local static对象的inline non-member functions"></a>不要产生内含local static对象的inline non-member functions</h3><p><code>inline non-member functions</code>意味着这个函数有内部连接（<code>internal linkage</code>)</p>
<p>函数如果有内部连接，可能在程序中被复制，也就是程序目标代码可能会对带有内部连接的函数复制一份以上代码，而此复制行为包括函数内的staic对象</p>
<p>如果有一个inline non-member function并于其中包含local static对象，程序可能会产生多个static副本</p>
<p>带有private constructors的class不能被继承导致禁止派生</p>
<p>只有const static member能在类定义区内指定初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects = <span class="number">10</span>;<span class="comment">//类内指定</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;<span class="comment">//类外指定</span></span><br></pre></td></tr></table></figure>
<p>==智能指针没法管理栈上的对象==,事实上也不需要，离开作用域自动析构</p>
<h3 id="在成员函数调用delete-this"><a href="#在成员函数调用delete-this" class="headerlink" title="在成员函数调用delete this"></a>在成员函数调用delete this</h3><p>在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。假设这个成员函数名字叫release，而delete this就在这个release方法中被调用，那么这个对象在调用release方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定 的，调用release之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。说到这里，相信大家都能明白为什么会这样 了。</p>
<p><strong>根本原因</strong>在于delete操作符的功能和类对象的内存模型。当一个类对象声明时，系统会为其分配内存空间。<strong>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中</strong>。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当 调用delete this时，类对象的内存空间被释放。<strong>在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行</strong>。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现<strong>不可预期</strong>的问题。</p>
<p>为什么是不可预期的问题？<strong>delete this之后不是释放了类对象的内存空间了么</strong>，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生<strong>指针错误</strong>，<strong>无访问权限之类的令系统崩溃</strong>的问题才对啊？这个问题牵涉到操作系统的内存管理策略。<strong>delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回</strong>。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<p>大致明白在成员函数中调用delete this会发生什么之后，再来看看另一个问题，如果在类的析构函数中调用delete this，会发生什么？实验告诉我们，会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存” (来自effective c++)。显然，<strong>delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃</strong>。</p>
<p><strong>1.在普通的非const成员函数中：</strong>this的类型是一个指向类类型的const指针，可以改变this指向的值，但是不能改变this所保存的地址</p>
<p>2.在const成员函数中，this的类型是一个指向const类类型对象的const指针，既不能改变this所指向的对象，也不能改变this所保存的地址。</p>
<h3 id="关于成员函数内调用memset-this-0-sizeof-this"><a href="#关于成员函数内调用memset-this-0-sizeof-this" class="headerlink" title="关于成员函数内调用memset(this,0,sizeof(*this))"></a>关于成员函数内调用memset(this,0,sizeof(*this))</h3><p>会将对象内存按位清零，包括成员变量、虚指针、虚基类指针等信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;nothing\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;~A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    B()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;~B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="keyword">sizeof</span>(*<span class="keyword">this</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;test();</span><br><span class="line">    a-&gt;test();<span class="comment">//会发生段错误，虚指针已经被清零</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    B b;</span></span><br><span class="line"><span class="comment">    b.test();</span></span><br><span class="line"><span class="comment">    b.test();//调用没问题，但数据确是清零了，原因在于对象调用虚函数不会通过虚机制，会以B::test()形式调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="push-back-emplace-back"><a href="#push-back-emplace-back" class="headerlink" title="push_back emplace_back"></a>push_back emplace_back</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> y=<span class="number">0</span>):x(x),y(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a):x(a.x)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;A copy constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(A&amp;&amp; a):x(<span class="built_in">std</span>::move(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;move constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;~A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;A&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;push_back\n&quot;</span>;</span><br><span class="line">        <span class="comment">//vec.push_back(2,2);不被允许</span></span><br><span class="line">        vec.push_back(<span class="number">2</span>);<span class="comment">//此时会先调用A constructor生成临时对象a,然后再调用move constructor</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;push end\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;emplace back\n&quot;</span>;</span><br><span class="line">        vec.emplace_back(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">//会直接调用constructor</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;emplace end\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//如下情况是没有区别的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        vec.push_back(a);</span><br><span class="line">        vec.emplace_back(a);<span class="comment">//都会调用copy constructor</span></span><br><span class="line">        </span><br><span class="line">        vec.push_back(A(<span class="number">2</span>));</span><br><span class="line">        vec.emplace_back(A(<span class="number">2</span>));<span class="comment">//都会调用constructor and move constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;test\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;const test\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.test();<span class="comment">//test</span></span><br><span class="line">    <span class="keyword">const</span> A b;</span><br><span class="line">    b.test();<span class="comment">//const test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==可以定义纯虚析构函数，但是纯虚析构函数必须有定义==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~A() = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">A::~A()&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这是非法的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">test</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="comment">//合法</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//More Effective C++  p203疑似有误</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;()<span class="keyword">const</span>&#123;<span class="keyword">return</span> pointee;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*()<span class="keyword">const</span>&#123;<span class="keyword">return</span> *pointee&#125;;</span><br></pre></td></tr></table></figure>
<p>==传参时隐式类型转换产生临时对象只发生参数以by value或者reference-to-const形式传递时发生，通过reference-to-non-const形式传递不会发生，因为可能改变reference-to-non-const的值，而隐式类型转换会产生临时对象，发生的改变只作用在临时对象上==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>&amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">2.0</span>;</span><br><span class="line">    test(x);<span class="comment">//cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> func(<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    ::<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;func;<span class="comment">//cout未对函数指针进行重载，会把函数指针隐式转换为bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">short</span> num)</span></span>&#123;</span><br><span class="line">    ::<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(::<span class="built_in">std</span>::<span class="built_in">putchar</span>);</span><br><span class="line">   <span class="comment">// print(0);0的类型是int,可以转换为short或指针， call of overloaded &#x27;print(int)&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="空对象调用成员函数"><a href="#空对象调用成员函数" class="headerlink" title="空对象调用成员函数"></a>空对象调用成员函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nod</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;dynamic print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;static print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printV</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;virtual print\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Nod * a = <span class="literal">nullptr</span>;</span><br><span class="line">   a-&gt;printS();<span class="comment">//静态函数，不涉及this指针，没问题</span></span><br><span class="line">   a-&gt;printD();<span class="comment">//不涉及Nod成员变量访问，没问题，涉及成员变量会得到段错误</span></span><br><span class="line">   a-&gt;printV();<span class="comment">//段错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实现final"><a href="#实现final" class="headerlink" title="实现final"></a>实现final</h3><p>1）如果类的构造函数或析析构函数声明为私有的，那么该类不能被继承，但同时该类也不能使用；</p>
<p>2）派生类只能访问基类的公有成员和保护成员，如果是私有继承，基类中所有成员到子类中将成为私有的，子类的派生类也即子类的子类只能访问其直接父类的公有成员或保护成员，不能访问最原始基类的任何成员；</p>
<p>3）如果有三个类A、B、C，B虚拟继承A，C继承B，则意味着C将直接继承A和B，也即构造C的对象时，将会直接调用A的构造函数</p>
<p>(下述解决方案g++不报错)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalBase</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	~FinalBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span> :</span> <span class="keyword">virtual</span> <span class="keyword">private</span> FinalBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i&#x27;m a final class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tfinalclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Final obj;</span><br><span class="line">	obj.foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">MakeFinally</span>&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       MakeFinally()&#123;&#125;;<span class="comment">//只有MakeFinally的友类才可以构造MakeFinally</span></span><br><span class="line">       ~MakeFinally()&#123;&#125;;</span><br><span class="line">   <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span>  MakeFinally&lt;MyClass&gt;&#123;&#125;;<span class="comment">//MyClass是不可派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于虚继承，所以D要直接负责构造MakeFinally类，从而导致编译报错，所以D作为派生类是不合法的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> MyClass&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>（好像也不行）</p>
<ul>
<li>父类写一个纯虚函数 —— 子类<strong>必须</strong>实现这一函数</li>
<li>这个纯虚函数放在 <code>private</code> 区域 —— 子类<strong>不能</strong>实现这一函数</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>pytorch备忘</title>
    <url>/2021/07/22/pytorch%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Tensor操作"><a href="#Tensor操作" class="headerlink" title="Tensor操作"></a>Tensor操作</h3><p>创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#全零</span></span><br><span class="line">torch.ones(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#全一</span></span><br><span class="line">torch.Tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])<span class="comment"># from list</span></span><br><span class="line">npy = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">torch.from_numpy(npy)<span class="comment">#from numpy</span></span><br><span class="line">torch.arange(<span class="number">6</span>)<span class="comment">#tensor([0, 1, 2, 3, 4, 5])</span></span><br></pre></td></tr></table></figure>
<p>运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.Tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a + b</span><br><span class="line"><span class="comment">#tensor([3., 5., 7.])</span></span><br><span class="line">a * b</span><br><span class="line"><span class="comment">#tensor([ 2.,  6., 12.])</span></span><br><span class="line">a / b</span><br><span class="line"><span class="comment"># tensor([0.5000, 0.6667, 0.7500])</span></span><br><span class="line">a + <span class="number">1</span></span><br><span class="line"><span class="comment">#tensor([2., 3., 4.])</span></span><br><span class="line">torch.dot(a,b)</span><br><span class="line"><span class="comment">#tensor(20.)</span></span><br><span class="line">a.outer(b)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 2.,  3.,  4.],</span></span><br><span class="line"><span class="string">        [ 4.,  6.,  8.],</span></span><br><span class="line"><span class="string">        [ 6.,  9., 12.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">torch.mm<span class="comment">#矩阵乘法</span></span><br></pre></td></tr></table></figure>
<p>维度操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">6</span>)<span class="comment">#tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="comment">#view 维度不匹配会RE</span></span><br><span class="line">x = x.view(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#tensor([[0, 1, 2],[3, 4, 5]])</span></span><br><span class="line">torch.<span class="built_in">sum</span>(x,dim = <span class="number">0</span>)<span class="comment"># tensor([3, 5, 7])</span></span><br><span class="line">torch.transpose(x,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 3],</span></span><br><span class="line"><span class="string">        [1, 4],</span></span><br><span class="line"><span class="string">        [2, 5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">indices = torch.LongTensor([<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">torch.index_select(x,dim=<span class="number">1</span>,index = indices)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 2],</span></span><br><span class="line"><span class="string">        [3, 5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">row_indices = torch.arange(<span class="number">2</span>).long()</span><br><span class="line">col_indices = torch.LongTensor([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">x[row_indices,col_indices]<span class="comment">#((0,0),(1,1))</span></span><br><span class="line"><span class="comment"># tensor([0, 4])</span></span><br></pre></td></tr></table></figure>
<p>连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">6</span>).view(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">torch.cat([x,x],dim = <span class="number">0</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0, 1, 2],</span></span><br><span class="line"><span class="string">        [3, 4, 5],</span></span><br><span class="line"><span class="string">        [0, 1, 2],</span></span><br><span class="line"><span class="string">        [3, 4, 5]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">torch.stack([x,x])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[0, 1, 2],</span></span><br><span class="line"><span class="string">         [3, 4, 5]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[0, 1, 2],</span></span><br><span class="line"><span class="string">         [3, 4, 5]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>随机数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.rand(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#uniform random</span></span><br><span class="line">torch.randn(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">#random normal</span></span><br></pre></td></tr></table></figure>
<p>requires_grad</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad = <span class="literal">True</span>)</span><br><span class="line">x.grad <span class="keyword">is</span> <span class="literal">None</span><span class="comment">#True</span></span><br><span class="line">y = (x + <span class="number">2</span>)*(x + <span class="number">5</span>) + <span class="number">3</span></span><br><span class="line">x.grad <span class="keyword">is</span> <span class="literal">None</span><span class="comment">#True</span></span><br><span class="line">z = y.mean()</span><br><span class="line">z.backward()</span><br><span class="line">x.grad <span class="keyword">is</span> <span class="literal">None</span><span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<p>创建cuda张量</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">torch.cuda.is<span class="constructor">_avaliable()</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is<span class="constructor">_avaliable()</span> <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">3</span>).<span class="keyword">to</span>(device)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. 创建一个张量,在第0维插入一个维度</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">x = x.unsqueeze(<span class="number">0</span>)</span><br><span class="line">x.shape</span><br><span class="line"><span class="comment">#torch.Size([1, 3, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 去掉该维度</span></span><br><span class="line">x = x.squeeze(<span class="number">0</span>)</span><br><span class="line">x.shape</span><br><span class="line"><span class="comment"># torch.Size([3, 3])</span></span><br><span class="line"><span class="comment">#squeeze对size大于1的维度应用无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 在区间[3,7]创建一个形状为5x3的随机张量</span></span><br><span class="line">x = <span class="number">3</span> + torch.rand(<span class="number">5</span>,<span class="number">3</span>)*(<span class="number">7</span>-<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 创建一个具有正态分布(mean = 0, std = 1)的张量</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">x.normal_()</span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 找到 torch.Tensor([1,1,1,0,1])中所有非零元素索引</span></span><br><span class="line">x = torch.Tensor([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">torch.nonzero(x)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0],</span></span><br><span class="line"><span class="string">        [1],</span></span><br><span class="line"><span class="string">        [2],</span></span><br><span class="line"><span class="string">        [4]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6. 创建一个大小为（3,1)的随机向量，水平扩展4个副本</span></span><br><span class="line">x = torch.rand(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">x.expand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.0839, 0.0839, 0.0839, 0.0839],</span></span><br><span class="line"><span class="string">        [0.1283, 0.1283, 0.1283, 0.1283],</span></span><br><span class="line"><span class="string">        [0.9937, 0.9937, 0.9937, 0.9937]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7 返回两个三维矩阵的乘积</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">torch.bmm(a,b).shape</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#8 返回一个三维矩阵和一个二维矩阵的乘积</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b = torch.rand(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">torch.bmm(a,b.unsqueeze(<span class="number">0</span>).expand(a.size(<span class="number">0</span>), *b.size()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>kick start 2021D</title>
    <url>/2021/07/11/kick-start-2021D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Arithmetic-Square"><a href="#Arithmetic-Square" class="headerlink" title="Arithmetic Square"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813">Arithmetic Square</a></h3><p>给一个3*3matrix，中间位置元素缺失，要求填上中间元素，使得矩阵中行、列、对角线形成的等差数列个数最多</p>
<p>枚举几种填数方式即可。</p>
<p>（唯一一道没WA的==)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;(x));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*A[i][<span class="number">1</span>] == A[i][<span class="number">0</span>]+A[i][<span class="number">2</span>])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*A[<span class="number">1</span>][i] == A[<span class="number">0</span>][i]+A[<span class="number">2</span>][i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*A[<span class="number">1</span>][<span class="number">1</span>] == A[<span class="number">0</span>][<span class="number">0</span>]+A[<span class="number">2</span>][<span class="number">2</span>])</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*A[<span class="number">1</span>][<span class="number">1</span>] == A[<span class="number">0</span>][<span class="number">2</span>] + A[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[<span class="number">0</span>][<span class="number">0</span>] + A[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans = check();</span><br><span class="line">    x = A[<span class="number">2</span>][<span class="number">0</span>] + A[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    ans = max(ans,check());</span><br><span class="line">    x = A[<span class="number">1</span>][<span class="number">0</span>] + A[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    ans = max(ans,check());</span><br><span class="line">    x = A[<span class="number">0</span>][<span class="number">1</span>] + A[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = x/<span class="number">2</span>;</span><br><span class="line">    ans = max(ans,check());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">sc(t)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=t; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        sc(A[<span class="number">0</span>][i])</span><br><span class="line">    &#125;</span><br><span class="line">    sc(A[<span class="number">1</span>][<span class="number">0</span>])sc(A[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        sc(A[<span class="number">2</span>][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = slove();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Cutting-Intervals"><a href="#Cutting-Intervals" class="headerlink" title="Cutting Intervals"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933">Cutting Intervals</a></h3><p>给一堆线段[$L<em>{i},R</em>{i}$],允许在选择C个整数点进行cut操作，一次在$K$点处的cut能把线段[$L,R$] (其中$L&lt; K $,$K &lt; R$),切成$[L,K]$,和$[K,R]$要求进行C次切割后得到的线段个数最多。</p>
<p>一个很朴素的想法就是贪心，从能切开最多线段的点开始。</p>
<p>注意到set 2给定的范围很大，所以枚举所有的整数点不现实。</p>
<p>容易看出的是一个点切割能产生新的线段数目在某些连续的区间内相等，只在线段的端点处发生着变化。</p>
<p>对端点进行枚举，记录端点处的变化情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;(x));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;P[<span class="number">100004</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//mp z记录的是分割能产生z条线段的端点数</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; pv;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; endW;</span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    sort(P,P+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st.insert(P[i].fi);</span><br><span class="line">        st.insert(P[i].se);</span><br><span class="line">        <span class="comment">//记录一下这个点结尾的线段数目</span></span><br><span class="line">        endW[P[i].se]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: st)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = vec[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//前面一个区间[pre,x-1]都是的点分割都能产生z条线段</span></span><br><span class="line">        <span class="keyword">if</span>(x - pre &gt; <span class="number">1</span>)</span><br><span class="line">        mp[z] += x-pre<span class="number">-1</span>;</span><br><span class="line">        z-=endW[x];</span><br><span class="line">        <span class="comment">//当前点特殊处理?感觉实现有点丑了==</span></span><br><span class="line">        mp[z] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp;P[i].fi == x)&#123;</span><br><span class="line">            z++;i++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : mp)&#123;</span><br><span class="line">        pv.pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    sort(pv.begin(),pv.end(),[=](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x,<span class="keyword">const</span> <span class="keyword">auto</span> &amp;y)&#123;</span><br><span class="line">         <span class="keyword">return</span> -x.fi &lt; -y.fi;</span><br><span class="line">         &#125;);</span><br><span class="line">    <span class="comment">//贪心</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> w: pv)&#123;</span><br><span class="line">        <span class="keyword">if</span>(C &gt; w.se)&#123;</span><br><span class="line">            ans += w.se*w.fi;</span><br><span class="line">            C-=w.se;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans += C*w.fi;</span><br><span class="line">            C = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.clear();</span><br><span class="line">    vec.clear();</span><br><span class="line">    mp.clear();</span><br><span class="line">    pv.clear();</span><br><span class="line">    endW.clear();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sc(t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sc(n)sc(C)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sc(P[i].fi)sc(P[i].se)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = slove();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Final-Exam"><a href="#Final-Exam" class="headerlink" title="Final Exam"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc">Final Exam</a></h3><p>给一堆集合$[L<em>{i},L</em>{i}+1,\dots,R_{i}]$</p>
<p>给一个序列$[S<em>{1},S</em>{2},\dots,S_{n}]$</p>
<p>要求按照序列从左至右，从集合族中找一个元素$v$,满足$|v-S_{i}|$最小，如有多个元素满足要求，则选其中最小的。</p>
<p>一个元素在$i$位置被选择了，在后续的选择中不能再选它。</p>
<p>我们要求的操作有：</p>
<ul>
<li>将$[L<em>{i},R</em>{i}]$中的元素加入集合。</li>
<li>从集合中选择与$S_{i}$最近的元素。</li>
<li>从集合中删除一个元素。</li>
</ul>
<p>想法是用一个动态开点的线段树解决。</p>
<p>利用线段树可以很简单实现操作1，操作3.</p>
<p>至于操作2，我们可以维护一些信息，保证在值$S_{i}$的附近搜索。</p>
<p>动态开点：有需要时才给它建节点，1~$1e18$直接开不了。需要额外维护child信息，普通线段树child信息都是通过$2x+1$,$2x+2$形式得到的，但这里没有这种关系，所以需要一个数组来单独维护。至于每一个节点维护的范围，我们可以通过函数调用传参的时候记录，无需单独用数组记录，省一定的空间。</p>
<p>关于操作2,为了提高查询效率，我们需要在每个节点维护这个节点所包含的集合元素个数信息。某些不包含元素的节点就不用继续搜索。我们在查询时要进行一定规模剪枝。</p>
<p>当$S_{i}$ &gt; 当前区间最大值，只需找到这个区间最小的元素。</p>
<p>当$S_{i}$ &lt; 当前区间最小值，只需找到这个区间最大元素。</p>
<p>当$S_{i}$在当前区间的左子树的左子树，检查左子树的右子树是否有元素，有则只需要搜索左子树。</p>
<p>当$S_{i}$在当前区间的右子树的右子树，检查右子树的左子树是否有元素，有则只需要搜索右子树。</p>
<p>当$S<em>{i}$在当前区间的左子树，先搜索左子树，如果左子树最近的元素大于$S</em>{i}$，则不需检查右子树。</p>
<p>当$S<em>{i}$在当前区间的右子树，先搜索右子树，如果右子树最近的元素小于$S</em>{i}$，则无需检查左子树。</p>
<p>否则检查左右子树，找最小的。</p>
<p>注意懒标的上下传和动态开辟新点的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;(x));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> x,y,q;</span><br><span class="line"><span class="keyword">int</span> maxn;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> Q[<span class="number">100005</span>];</span><br><span class="line"><span class="comment">//child信息</span></span><br><span class="line"><span class="keyword">signed</span> C[<span class="number">60000004</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//懒标</span></span><br><span class="line"><span class="keyword">signed</span> T[<span class="number">60000006</span>];</span><br><span class="line"><span class="comment">//记录当前区间有多少个有效元素</span></span><br><span class="line"><span class="keyword">signed</span> D[<span class="number">60000006</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    C[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    C[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    D[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    T[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(C[x][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C[x][<span class="number">0</span>] = ++k;</span><br><span class="line">        C[C[x][<span class="number">0</span>]][<span class="number">0</span>] = C[C[x][<span class="number">0</span>]][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        T[k]=<span class="number">0</span>;</span><br><span class="line">        D[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(C[x][<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C[x][<span class="number">1</span>] = ++k;</span><br><span class="line"></span><br><span class="line">        C[C[x][<span class="number">1</span>]][<span class="number">0</span>] = C[C[x][<span class="number">1</span>]][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        T[k]=<span class="number">0</span>;</span><br><span class="line">        D[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    D[C[x][<span class="number">0</span>]]+= T[x]*(mid-L + <span class="number">1</span>);</span><br><span class="line">    D[C[x][<span class="number">1</span>]] += T[x]*(R-(mid+<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    T[C[x][<span class="number">0</span>]] += T[x];</span><br><span class="line">    T[C[x][<span class="number">1</span>]] += T[x];</span><br><span class="line">    T[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D[x] = D[C[x][<span class="number">0</span>]] + D[C[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">int</span> mid = (L + R)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L &gt;= l &amp;&amp; r &gt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x] += <span class="number">1</span>;</span><br><span class="line">        D[x] += R-L + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x,L,R);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">        add(C[x][<span class="number">0</span>],l,r,L,mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line"></span><br><span class="line">        add(C[x][<span class="number">1</span>],l,r,mid+<span class="number">1</span>,R);</span><br><span class="line">    push_up(x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L == v &amp;&amp; R == v)</span><br><span class="line">    &#123;</span><br><span class="line">        D[x]-=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x,L,R);</span><br><span class="line">    <span class="keyword">if</span>(v &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        sub(C[x][<span class="number">0</span>],v,L,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub(C[x][<span class="number">1</span>],v,mid+<span class="number">1</span>,R);</span><br><span class="line">    &#125;</span><br><span class="line">    push_up(x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(D[x] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x,L,R);</span><br><span class="line">    <span class="keyword">if</span>(v &lt; L)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(D[C[x][<span class="number">0</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ask(C[x][<span class="number">0</span>],v,L,mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ask(C[x][<span class="number">1</span>],v,mid+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(D[C[x][<span class="number">1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ask(C[x][<span class="number">1</span>],v,mid+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ask(C[x][<span class="number">0</span>],v,L,mid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(v &lt;= (L+mid)/<span class="number">2</span> &amp;&amp; D[C[C[x][<span class="number">0</span>]][<span class="number">1</span>]])&#123;</span><br><span class="line">        ans = ask(C[x][<span class="number">0</span>],v,L,mid);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v &gt; (mid+<span class="number">1</span>+R)/<span class="number">2</span> &amp;&amp; D[C[C[x][<span class="number">1</span>]][<span class="number">0</span>]])&#123;</span><br><span class="line">        ans = ask(C[x][<span class="number">1</span>],v,mid+<span class="number">1</span>,R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">-1</span>,b=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(v &lt;= mid)&#123;</span><br><span class="line">        a = ask(C[x][<span class="number">0</span>],v,L,mid);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">-1</span> || a &lt; v)</span><br><span class="line">        b = ask(C[x][<span class="number">1</span>],v,mid+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v &gt; mid)&#123;</span><br><span class="line">            b = ask(C[x][<span class="number">1</span>],v,mid+<span class="number">1</span>,R);</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">-1</span> || b &gt; v)</span><br><span class="line">                a = ask(C[x][<span class="number">0</span>],v,L,mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">-1</span>)ans = b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">-1</span>) ans = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a-v) &lt; <span class="built_in">abs</span>(b-v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a-v) == <span class="built_in">abs</span>(b-v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans = min(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    push_up(x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        add(<span class="number">1</span>,P[i].fi,P[i].se,<span class="number">1</span>,maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = ask(<span class="number">1</span>,Q[i],<span class="number">1</span>,maxn);</span><br><span class="line">        sub(<span class="number">1</span>,v,<span class="number">1</span>,maxn);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sc(t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxn = <span class="number">0</span>;</span><br><span class="line">        sc(n)sc(q)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sc(x)sc(y)</span><br><span class="line">            P[i] = &#123;x,y&#125;;</span><br><span class="line">            maxn = max(maxn,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sc(Q[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        slove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>内存是真的不要钱，开8e7给过了==</li>
</ul>
<h3 id="Primes-and-Queries"><a href="#Primes-and-Queries" class="headerlink" title="Primes and Queries"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bcf4#problem">Primes and Queries</a></h3><p>只会set1，数据范围看错，第一个set WA到怀疑人生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;(x));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n,Q,P;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> S,L,R;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x%P == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        x/=P;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * x;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">500004</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= <span class="number">500000</span>)&#123;</span><br><span class="line">        B[x][k] += v;</span><br><span class="line">        x += (x&amp;-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += B[x][k];</span><br><span class="line">        x -= (x&amp;-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sc(t)</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(B));</span><br><span class="line">        sc(n)sc(Q)sc(P)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sc(A[j])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)&#123;</span><br><span class="line">                add(j,V(qp(A[j],k) - qp(A[j]%P,k)),k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(Q--)</span><br><span class="line">        &#123;</span><br><span class="line">            sc(op)</span><br><span class="line">            <span class="keyword">if</span>(op ==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sc(p)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)&#123;</span><br><span class="line">                add(p,-V(qp(A[p],k) - qp(A[p]%P,k)),k);</span><br><span class="line">            &#125;</span><br><span class="line">                sc(A[p])</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)&#123;</span><br><span class="line">                add(p,V(qp(A[p],k) - qp(A[p]%P,k)),k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sc(S)sc(L)sc(R)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;ask(R,S) - ask(L<span class="number">-1</span>,S)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>插值</title>
    <url>/2021/07/06/%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Lagrange插值法"><a href="#Lagrange插值法" class="headerlink" title="Lagrange插值法"></a>Lagrange插值法</h3><p>给定一组n个函数点值${(x<em>{1},f(x</em>{1})),(x<em>{2},f(x</em>{2})),\cdots,(x<em>{n},f(x</em>{n}))}$,用n-1次多项式拟合这n个点.</p>
<p>记$f(x) = l<em>{1}(x)f(x</em>{1}) + l<em>{2}(x)f(x</em>{2}) + \cdots + l<em>{n}(x)f(x</em>{n}) $</p>
<p>其中$l<em>{i}(x) = 0, x \neq x</em>{i}$</p>
<p>​       $l<em>{i}(x) =1,x = x</em>{i}$</p>
<p>可以将$l_{i}(x)$构造成</p>
<p>$l<em>{i}(x) = \frac{(x-x</em>{1})\cdots (x-x<em>{i-1})(x-x</em>{i+1})\cdots(x-x<em>{n})}{(x</em>{i}-x<em>{1})\cdots(x</em>{i}-x<em>{i-1})(x</em>{i}-x<em>{i+1})\cdots (x</em>{i}-x_{n})} $</p>
<p>当$x<em>{1},x</em>{2},\cdots,x_{n}$取连续值时，如$1,2,\cdots,n$,有</p>
<p>$l_{i}(x) = \frac{(x-1)\cdots (x-(i-1))(x-(i+1))\cdots (x-n)}{(i-1)\cdots(i-(i-1))(i-(i+1))\cdots(i-n)}$</p>
<p>分母可以化简为</p>
<p>$(-1)^{n-i}(i-1)!(n-i)!$</p>
<p>我们可以利用Lagrange插值法实现形如$\Sigma_{i=1}^{n} i^k$快速求和,==n很大，k很小==</p>
<p>我们有结论$\Sigma i^{k}$是k+1次多项式，记为$S_{i}$</p>
<p>可以预处理计算前k+2项的和，得到$S<em>{i}$的k+2项点值，从而确定$S</em>{i}$的Lagrange插值形式。</p>
<p>通过插值表达式求$S_{n}$的值。</p>
<p>我们可以预处理$1-n$阶乘的逆元，对于$l_{i}(x)$分子那个东西，可以先预处理前缀乘积和后缀乘积</p>
<p>这样每一项的计算都是$O(1)$，计算$S_{n}$总的复杂度为$O(n)$</p>
<a id="more"></a>
<p><a href="https://atcoder.jp/contests/abc208/tasks/abc208_f"><strong>F - Cumulative Sum</strong></a></p>
<p>可以看出f(n,m)是关于n的m+k次多项式</p>
<p>暴力计算前m+k+1个位置点值$f(1,m),f(2,m),\cdots,f(m+k+1,m)$</p>
<p>然后根据插值表达式计算f(n,m)</p>
<p>不知道为啥卡常==，需要时才取模</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    x %= mod;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans*x)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x*x)%mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2500050</span>];</span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">2500050</span>];<span class="comment">//阶乘逆元</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">2500050</span>];<span class="comment">//(x-x_i)前缀</span></span><br><span class="line"><span class="keyword">int</span> B[<span class="number">2500050</span>];<span class="comment">//(x-x_i)后缀</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> m)</span><span class="comment">//预处理阶乘逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = (inv[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[m] = qp(inv[m],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">1</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = (inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//计算f(n),m为次数+1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y = (n-i)%mod;</span><br><span class="line">        <span class="comment">//assert(y != 0);</span></span><br><span class="line">        A[i] = (A[i<span class="number">-1</span>]*y)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    B[m+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        y = (n-i)%mod;</span><br><span class="line">        B[i] = B[i+<span class="number">1</span>]*y %mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>)</span><br><span class="line">            ans = (ans - ((A[i<span class="number">-1</span>]*B[i+<span class="number">1</span>])%mod*inv[i<span class="number">-1</span>]%mod * inv[m-i]%mod*f[i]%mod)+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = (ans + ((A[i<span class="number">-1</span>]*B[i+<span class="number">1</span>])%mod*inv[i<span class="number">-1</span>]%mod * inv[m-i]%mod*f[i]%mod))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    init(m+k+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m+k+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = qp(i,k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &gt; mod)dp[j] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = dp[m]%mod;</span><br><span class="line">        <span class="keyword">if</span>(i == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cal(n,m+k+<span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>linux内核</title>
    <url>/2021/07/04/linux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用通过返回一个long类型来表示成功与否，（通常0成功、负值失败</p>
<p>系统调用出错时，将错误码写入全局<code>errno</code>中，通过调用<code>perror()</code>可翻译成字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123; </span><br><span class="line">         <span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SYSCALL_DEFINE0</code>是一个宏，定义一个无参数(0个)的系统调用</p>
<p><code>asmlinkage long sys_getpid(void)</code></p>
<p><code>asmlinkage</code>限定词。是一个编译指令，通知编译器仅从栈中提取该函数的参数，所有的系统调用需要这一限定词</p>
<p>函数返回值为long,系统调用在内核空间、用户空间的返回值分别为long,int</p>
<p>系统调用在内核中定义都加<code>sys_</code>前缀</p>
<ul>
<li><p>系统调用号</p>
<p>每个系统调用赋予了一个系统调用号，通过系统调用号关联系统调用</p>
<p>当用户进程执行一个系统调用时，这个系统调用号就用来指明到底是要执行哪个系统调用。</p>
<p>系统调用号一经分配不能变更，linux中有一个未实现的sys_ni_syscall() 只返回-ENOSYS，这个错误号是为无效系统调用设置的</p>
</li>
<li><p>用户空间程序无法执行内核代码，应该通过一定方式通知系统，告诉内核自己需要执行一个系统调用</p>
<p>通知内核的机制是通过软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序</p>
<p>此时的异常处理程序就是系统调用处理程序，在x86系统上预定义的软中断是中断号128，通过<code>int$0x80</code>触发中断</p>
</li>
<li><p>指定恰当系统调用</p>
<p>系统调用号通过<code>eax</code>寄存器传递给内核</p>
<p>sys_call()函数通过给定的NR_syscalls作比较来检查其有效性，如果大于等于NR_syscalls,则返回-ENOSYS,否则执行相应系统调用</p>
<p><code>call *sys_call_table(,%rax,8)</code></p>
<p>系统调用表表项是以64位（8字节）类型存放的</p>
</li>
<li><p>参数传递</p>
<p>通过<code>ebx ecx edx esi edi</code>按照顺序存放前五个参数</p>
<p>需要六个及六个以上参数的情况，需要一个单独的寄存器存放指向所有这些参数在用户空间地址的指针</p>
</li>
<li><p>参数验证</p>
<p>系统调用需要检查所有参数是否合法有效</p>
<p>在接受一个用户空间的指针之前，内核需要保证：</p>
<ul>
<li>指针指向的内存区域属于用户空间，进程不能哄骗内核去读内核空间的数据</li>
<li>指针指向的内存区域在进程的地址空间，进程绝不能哄骗内核去读其他进程的数据</li>
<li>如果是读，该内存应被标记位可读，如果是写，该内存应被标记为可写，如果是可执行，该内存被标记为可执行</li>
</ul>
<p>为了向用户空间写入数据，内核提供了<code>copy_to_user()</code>,他需要三个参数，第一个是进程空间的目的内存地址，一个是内核空间的源地址，最后一个是数据长度</p>
<p>为了向内核空间写入数据，<code>copy_from_user()</code></p>
<p>如果执行失败，这两个函数返回的都是没能完成拷贝的数据字节数，如果成功返回0，当出现错误时，返回标准-EFAULT</p>
<p><code>copy_to_user</code>,<code>copy_from_user</code>都可能引起阻塞，当包含用户数据的页被换出时，这种情况就会发生，此时进程就会休眠，直到却也处理程序将该页重新换入物理内存</p>
<p>最后一项检查针对是否有合法权限</p>
<ul>
<li>老版Linux内核需要超级用户权限的系统调用才可以调用<code>suser()</code>函数完成检查</li>
<li>新的系统允许检查针对特定资源的特殊权限，调用者可以使用<code>capable()</code>来检查是否有劝能对指定的资源进行操作</li>
</ul>
</li>
<li><p>系统调用上下文</p>
<p>内核在执行系统调用时处于进程上下文</p>
<p>current指针指向当前任务，即引发系统调用的进程</p>
<p>在进程上下文中，内核可以休眠（比如在系统调用阻塞或者显示调用schedule()的时候）并且可以抢占</p>
<p>首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能</p>
<p>在进程上下文中能够被抢占表明，像用户空间中的进程一样，当前的进程可以被其他进程抢占</p>
<p>因为新的进程可以使用相同的系统调用，所以需要保证系统调用是可重入的</p>
<p>当系统调用返回后，控制权仍在system_call()中，它最终会负责切换到用户空间</p>
</li>
<li><p>绑定一个系统调用</p>
<p>首先，在系统调用表中最后加入一个表项，从0开始计算，系统调用在该表中的位置就是它的系统调用号</p>
<p>对于所支持的各种体系结构，系统调用号都必须定义于<code>&lt;asm/unistd.h&gt;</code></p>
<p>系统调用必须被编译进内核映像（不能编译成模块），这只要把它放进kernel/下的一个相关文件中就可以了</p>
</li>
<li><p>从用户空间访问系统调用</p>
<p>open()系统调用的定义：</p>
<p><code>long open(const char *filename,int flags,int mode)</code></p>
<p>不靠库支持，直接调用此系统调用的宏形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_open 5</span></span><br><span class="line">_syscall3(<span class="keyword">long</span>,open,<span class="keyword">const</span> <span class="keyword">char</span> *,filename,<span class="keyword">int</span>,flags,<span class="keyword">int</span>,mode)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><code>&lt;linux/list.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>令人迷惑的宏</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">name</span> =</span> LIST_HEAD_INIT(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开一下就能看懂了==</span></span><br><span class="line"><span class="comment">//struct list_head list = &#123;&amp;list,&amp;list&#125;</span></span><br></pre></td></tr></table></figure>
<p>遍历list</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line">	<span class="keyword">for</span> (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) ((size_t)&amp;((TYPE*)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p>对地址0强转？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span><span class="comment">//0</span></span><br><span class="line">	<span class="keyword">char</span> c;<span class="comment">//8</span></span><br><span class="line">	<span class="keyword">int</span> a;<span class="comment">//12，这里发生了内存对齐，64位机器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(struct Node * node)</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里只计算相对首地址偏移量，不会发生段错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n%u\n%u\n%u\n&quot;</span>,node,&amp;node-&gt;next,&amp;node-&gt;c,&amp;node-&gt;a);</span><br><span class="line">	<span class="comment">//printf(&quot;%d&quot;,node-&gt;a);只有去访问一个成员才会出现段错误</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,<span class="keyword">sizeof</span>(*node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>64位系统<code>long</code>竟然是和<code>long long</code>数据范围一致，8位</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr,type,member) (&#123;\</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">(((type*)<span class="number">0</span>)-&gt;member)</span>*__mptr </span>= (ptr);\</span><br><span class="line">    (type*)((<span class="keyword">char</span>*)__mptr -offsetof(type,member));&#125;)</span><br></pre></td></tr></table></figure>
<p> 其中<code>typeof</code>是GNU中获取变量类型的关键字</p>
<p>为啥要有第一句？</p>
<p>因为宏没有参数检查的功能，增加这个<code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr)</code>赋值语句之后，如果类型不匹配，会有警告</p>
<p><code>ptr</code>，是指向<code>member</code>的指针，<code>type</code>，是容器结构体的类型，<code>member</code>就是结构体中的成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)				\</span></span><br><span class="line">	<span class="keyword">for</span> (pos = list_first_entry(head, typeof(*pos), member);	\</span><br><span class="line">	     !list_entry_is_head(pos, head, member);			\</span><br><span class="line">	     pos = list_next_entry(pos, member))</span><br></pre></td></tr></table></figure>
<p>安全遍历list,用n缓存下一个节点，可以在遍历时删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line">	<span class="keyword">for</span> (pos = list_first_entry(head, typeof(*pos), member),	\</span><br><span class="line">		n = list_next_entry(pos, member);			\</span><br><span class="line">	     !list_entry_is_head(pos, head, member); 			\</span><br><span class="line">	     pos = n, n = list_next_entry(n, member))</span><br></pre></td></tr></table></figure>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><code>&lt;linux/kfifo&gt;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kfifo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	in;<span class="comment">//入口偏移</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	out;<span class="comment">//出口偏移</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	esize;</span><br><span class="line">	<span class="keyword">void</span>		*data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>__attribute__((aligned(n)))</code>：此属性指定了指定类型的变量的最小对齐(以字节为单位),如果结构中有成员的长度大于n，则按照最大成员的长度来对齐.</p>
<p>注意：对齐属性的有效性会受到链接器(linker)固有限制的限制，即如果你的链接器仅仅支持8字节对齐，即使你指定16字节对齐，那么它也仅仅提供8字节对齐。</p>
<p><code>__attribute__((packed))</code>此属性取消在编译过程中的优化对齐</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>Linux内核提供唯一标志数（UID)到一个指针的映射</p>
<p><code>idr</code>数据结构用于映射用户空间的UID,比如将<code>inodify watch</code>的描述符或者POSIX的定时器ID映射到内核中相关联的数据结构上</p>
<ul>
<li>初始化一个idr</li>
</ul>
<p>静态或动态分配一个idr数据结构</p>
<p>然后调用<code>idr_init()</code></p>
<p><code>void idr_init(struct idr *idp)</code></p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">id_huh</span>;</span><span class="comment">/*静态定义idr结构*/</span></span><br><span class="line">idr_init(&amp;id_huh);</span><br></pre></td></tr></table></figure>
<ul>
<li>分配一个新的UID</li>
</ul>
<p>一旦建立了idr，就可以分配新的UID</p>
<ol>
<li>告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小</li>
</ol>
<p><code>int idr_pre_get(struct idr *idp,gfp_t gfp_mask);</code></p>
<p>该函数在需要时进行<code>UID</code>分配工作，调整由<code>idp</code>指向的<code>idr</code>大小，如果真的需要调整大小，则内存分配例程使用<code>gfp</code>标志：<code>gfp_mask</code></p>
<p>==该函数成功时返回1，失败时返回0==</p>
<ol>
<li>请求新的UID</li>
</ol>
<p>实际执行获取新的UID，并将其加到idr中</p>
<p><code>int idr_get_new(struct idr *idp,void *ptr,int *id);</code></p>
<p>该方法使用<code>idp</code>所指向的idr去分配一个新的UID,并且将其关联到指针ptr上，成功时该方法返回0，并将新的UID存于id。</p>
<p>错误时，返回非0错误码，错误码是<code>-EAGAIN</code>说明需要再次调用<code>idr_pre_get()</code>,如果idr已满，错误码为<code>-ENOSPC</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!idr_pre_get(&amp;id_huh,GFP_KERNEL))&#123;</span><br><span class="line"> <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">ret = idr_get_ner(&amp;idr_huh,ptr,&amp;id);</span><br><span class="line">&#125;<span class="keyword">while</span>(ret == -EAGAIN);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查找UID</p>
<p><code>void *idr_find(struct idr*idp,int id);</code></p>
<p>如果调用成功，则返回id关联的指针，如果错误，则返回空指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">ptr</span> =</span> idr_find(&amp;id_huh,id);</span><br><span class="line"><span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line"> <span class="keyword">return</span> -EINVAL;<span class="comment">/*错误*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除UID</p>
<p><code>void idr_remove(struct idr*idp,int id)</code></p>
<p>删除id及id关联的指针，不提供错误信息</p>
</li>
<li><p>撤销idr</p>
<p><code>void idr_destory(struct idr *idp)</code></p>
<p>释放idr中未使用的内存，不释放已经分配给UID使用的任何内存</p>
</li>
</ul>
<p><code>void idr_remove_all(struct idr*idp)</code></p>
<p>强制删除所有UID</p>
<h4 id="rb-tree"><a href="#rb-tree" class="headerlink" title="rb tree"></a>rb tree</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;<span class="comment">//parent and current color</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_parent(r)   ((struct rb_node *)((r)-&gt;__rb_parent_color &amp; ~3))  <span class="comment">//获得父结点的地址  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_color(r)   ((r)-&gt;rb_parent_color &amp; 1) <span class="comment">//获得颜色属性</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>奇奇怪怪的结构体初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RB_ROOT	(struct rb_root) &#123; NULL, &#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="强制内联-always-inline"><a href="#强制内联-always-inline" class="headerlink" title="强制内联 __always_inline"></a>强制内联 <code>__always_inline</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *</span></span><br><span class="line"><span class="class"><span class="title">rb_find_add</span>(<span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span>, <span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">tree</span>,</span></span><br><span class="line"><span class="class">	    <span class="title">int</span> (*<span class="title">cmp</span>)(<span class="keyword">struct</span> <span class="title">rb_node</span> *, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">rb_node</span> *));</span></span><br></pre></td></tr></table></figure>
<p>带缓存的根节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rb_root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>O(1)获取最小节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rb_first_cached(root) (root)-&gt;rb_leftmost</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"># define likely(<span class="name">x</span>)  __builtin_expect(!!(<span class="name">x</span>), <span class="number">1</span>)</span><br><span class="line"># define unlikely(<span class="name">x</span>)    __builtin_expect(!!(<span class="name">x</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>述源码中采用了内建函数<strong>builtin_expect来进行定义，即 built in function。<br>　　`</strong>builtin_expect<code>的函数原型为</code>long <strong>builtin_expect (long exp, long c)<code>，返回值为完整表达式</code>exp<code>的值，它的作用是期望表达式</code>exp<code>的值等于</code>c<code>（如果</code>exp == c<code>条件成立的机会占绝大多数，那么性能将会得到提升，否则性能反而会下降）。注意，</code></strong>builtin_expect (exp, c)<code>的返回值仍是</code>exp<code>值本身，并不会改变</code>exp<code>的值。</code>__builtin_expect<code>函数用来引导</code>gcc`进行条件分支预测。在一条指令执行时，由于流水线的作用，CPU可以同时完成下一条指令的取指，这样可以提高CPU的利用率。在执行条件分支指令时，CPU也会预取下一条执行，但是如果条件分支的结果为跳转到了其他指令，那CPU预取的下一条指令就没用了，这样就降低了流水线的效率。<br>　　另外，跳转指令相对于顺序执行的指令会多消耗CPU时间，如果可以尽可能不执行跳转，也可以提高CPU性能。<br>　　简单从表面上看if(likely(value)) == if(value)，if(unlikely(value)) == if(value)。<br>也就是likely和unlikely是一样的，但是实际上执行是不同的，加likely的意思是value的值为真的可能性更大一些，那么执行if的机会大，而unlikely表示value的值为假的可能性大一些，执行else机会大一些。<br>　　加上这种修饰，编译成二进制代码时likely使得if后面的执行语句紧跟着前面的程序，unlikely使得else后面的语句紧跟着前面的程序，这样就会被cache预读取，增加程序的执行速度。</p>
<h4 id="radix-tree"><a href="#radix-tree" class="headerlink" title="radix_tree"></a>radix_tree</h4><p>linux的基数树结构是将指针与long类型的整数键值相映射的机制，可以提到查找的效率，是典型的以空间换取时间的做法.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">radix_tree_root</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">gfp_t</span> gfp_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">rnode</span>;</span>  <span class="comment">/*间接指针，指向节点而非数据条目，通过设置root-&gt;rnode的低位表示是否是间接指针*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  height;  <span class="comment">/*从叶子节点向上计算的树高度*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;    <span class="comment">/*非叶子节点包含一个count域，表示出现在该节点的孩子节点的数量*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    <span class="keyword">void</span>*  slot[RADIX_TREE_MAP_SIZE];  <span class="comment">//64个指针，指示该几点的子节点最多有64个，该值是可以进行设置的，参考下面的全局变量的设置*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以index=0x5BFB68为例，化为二进制，每6位为一组：10110(22,第一层编号),111111(63,第2层编号),101101(45,第三层编号),101000(40,第四层编号)</p>
<p>dix_tree_node.tags:  标识该节点的每个子节点中的标志位，是通过位图的方式进行表示的。该域是一个2X2的数组，其中每个成员都是32位。在该节点结构中每个slot都用2位标识，用于记录该节点下面的子节点的响应标识位有没有被置位。行数对应于有多少个标识，比如，如果有两个标识，PAGE_DIRTY和PAGE_WRITEBACK，那么就需要使用两行；如果有三个标识，就使用三行。列数对应于有多少个子节点，例如，如果有64个子节点，那么每一列代表其中的一个子节点。因此，该2x2数组中的每个值代表了每个slot中的每个标识是否被设置（当然需要将long类型的整数对应成二进制位才行，那么64个子节点恰好是需要64位，恰好是两个long  int 类型，每位代表一个子节点；每行代表一个标识）。该标识对于基数树的查找非常有帮助。如果tag[0]=0（PAGE_DIRTY为全为0），那么标识该节点对应的子节点中没有相应的节点有存在脏页，则在寻找脏页的过程中可以绕过该节点所对应的所有子节点，而不用遍历整棵树，提高了查找的效率；tag[1]=0（PAGE_WRITEBACK标志全为0)。</p>
<h3 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h3><p>中断使得硬件得以发出通知给处理器。中断本质上是一种特殊的电信号，由硬件设备发向处理器，处理器接收到中断后，会马上向操作系统反映此信号到来，然后就由操作系统负责处理这些新到来的数据。</p>
<p>中断本质上是一种电信号，由硬件设备生成，并直接送入中断控制器的输入引脚中。</p>
<p>当接收到一个中断后，中断控制器会给处理器发送一个电信号。</p>
<p>不同设备对应的中断不同，而每个中断都通过一个唯一的数字标识。</p>
<p>这些中断值通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量。</p>
<ul>
<li>异常：</li>
</ul>
<p>异常与中断不同，它在产生时必须考虑与处理器时钟同步。</p>
<p>异常常被称为同步中断</p>
<p>中断与异常工作方式类似，差异在于中断是由硬件而不是由软件引起。</p>
<h4 id="中断处理程序（interrupt-handler"><a href="#中断处理程序（interrupt-handler" class="headerlink" title="中断处理程序（interrupt handler)"></a>中断处理程序（interrupt handler)</h4><p>在响应一个特定的中断时，内核会执行一个函数，该函数叫做中断处理函数。</p>
<p>一个设备的中断处理程序是它设备驱动程序的一部分。设备驱动程序是用于对设备进行管理的内核代码。</p>
<p>中断处理程序是被内核调用来响应中断的，他们运行在我们称之为中断上下文的特殊上下文中。该上下文中的执行代码不可阻塞。</p>
<h4 id="上半部下半部"><a href="#上半部下半部" class="headerlink" title="上半部下半部"></a>上半部下半部</h4><p>要求：</p>
<p>中断处理程序运行快，完成工作量多</p>
<p>处理：</p>
<p>把中断处理程序分为两个部分：</p>
<ul>
<li>上半部，接受一个中断，马上执行，只做有严格时限的工作。</li>
<li>能够被允许稍后完成的工作推迟到下半部。</li>
</ul>
<h4 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h4><p><code>&lt;linux/interrupt.h&gt;</code></p>
<p><code>int request_irq(unsigned int irq,irq_handler_t handler,unsigned long flags,const char *name,void *dev);</code></p>
<p>第一个参数表示要分配的中断号，对某些设备，这个值是预先确定的，对大多数设备，可以通过探测获取或者编程动态确定。</p>
<p>第二个参数handler是一个指针，指向中断处理函数。</p>
<p><code>typedef irqreturn_t (*irq_handler_t)(int, void *)</code></p>
<p>接收两个参数，返回一个<code>irqreturn_t</code></p>
<p>第三个参数flags可以为0，也可以是下列一个或多个标志的位掩码。</p>
<p><code>IRQF_DISABLED</code>: 内核在处理中断处理程序时，禁止所有其他的中断。</p>
<p><code>IRQF_SAMPLE_RANDOM</code>:表明这个设备产生的中断对内核熵池有贡献。内核熵池负责从各种随机事件中导出真正的随机数。</p>
<p><code>IRQF_TIMER</code>:系统定时器的中断处理准备的</p>
<p><code>IRQF_SHARED</code>:多个中断处理程序之间共享中断线。</p>
<p>第四个参数name是中断相关设备的ASCII文本表示。键盘中断对应<code>keyboard</code>,这些名字被<code>/proc/irq</code>和<code>/proc/interrupts</code>使用</p>
<p>第五个参数dev用于共享中断线，当一个中断处理程序需要释放时，dev将提供唯一的标志信息（cookie)，以便从共享中断线的诸多处理程序中删除指定的哪一个。</p>
<p><code>request_irq()</code>成功执行返回0，返回非零表示有错误发生。</p>
<p><code>request_irq()</code>函数可能睡眠，不能在中断上下文或其他不允许阻塞代码中调用该函数，在注册过程中，内核需要在/proc/irq文件中创建一个与中断对应的项。</p>
<p>函数<code>proc_mkdir()</code>用来创建这个<code>procfs</code>项，通过调用<code>proc_create()</code>对这个新的项进行设置，而<code>proc_create()</code>会调用<code>kmalloc()</code>,<code>kmalloc()</code>是可以睡眠的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(request_irq(irqn,my_interrupt,IRQF_SHARED,<span class="string">&quot;my_device&quot;</span>,my_dev))&#123;</span><br><span class="line">printk(KERN_ERR <span class="string">&quot;my_device:cannot register IRQ %d\n&quot;</span>,irqn);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h4><p><code>void free_irq(unsigned int irq,void * dev)</code></p>
<p>卸载驱动程序时，需要注销相应的中断处理程序，并释放总线。</p>
<p>总线非共享直接删除，共享仅删除dev对应的处理程序。</p>
<h4 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h4><p><code>static irqreturn_t intr_handler(int irq,void *dev)</code></p>
<p>第一个参数irq是这个处理程序要响应的中断的中断号。</p>
<p>第二个参数dev是一个通用指针，它与在中断处理程序注册时传递给<code>request_irq()</code>的参数dev必须一致。</p>
<p>中断处理程序返回值是一个特殊类型<code>irqreturn_t</code></p>
<p>中断处理程序可能返回两个特殊的值：<code>IRQ_NONE</code> <code>IRQ_HANDLED</code></p>
<p>当中断处理程序检测到一个中断，但该中断对应的设备并不是在注册处理函数期间产生的指定的产生源时，返回<code>IRQ_NONE</code></p>
<p>当中断处理程序被正确调用，且确是它所对应的设备产生了中断时返回<code>IRQ_HANDLED</code></p>
<p>Linux中的中断处理程序是无需重入的，当一个给定的中断处理程序正在执行，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接受另一个新的中断。但不影响其他中断线。</p>
<h4 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h4><ul>
<li>request_irq()的flags必须设为IRQF_SHARED标志</li>
<li>对于每个注册的中断处理程序，dev参数必须唯一</li>
<li>中断处理程序必须能够区分它的设备是否真的产生了中断</li>
</ul>
<p>指定IRQF_SHARED标志调用request_irq()时，只有在</p>
<ul>
<li>当前中断线未被注册</li>
<li>当前中断线所有已注册处理程序指定了IRQF_SHARED时才能成功</li>
</ul>
<p>内核在接收到一个中断后，依次调用该中断线上注册的每一个中断处理程序。因此处理程序必须知道他是否对这个中断负责。</p>
<h4 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h4><p>进程上下文是一种内核所处的操作模式，此时内核代表进程执行（执行系统调用、运行内核进程）。在进程上下文中，可以通过current宏关联当前线程。</p>
<p>中断上下文和进程无关，没有后备线程，不能睡眠，否则不能对它进行重新调度。</p>
<p>中断上下文有较为严格时间限制，因为打断了其他代码。中断上下文中的代码应该迅速简洁，尽量不使用循环。</p>
<p>中断处理程序栈是一个配置选项，（曾经共享中断进程的内核栈。</p>
<h4 id="中断处理机制的实现"><a href="#中断处理机制的实现" class="headerlink" title="中断处理机制的实现"></a>中断处理机制的实现</h4><p>设备产生中断，通过总线将电信号发送个中断控制器，如果中断线是激活的（允许被屏蔽），那么中断控制器将把中断发送给处理器。除非在处理器上禁止该中断，处理器会立刻停止正在做的事情，关闭中断系统，跳到内存中预定义位置开始执行那里的代码，这个位置是内核设置的，是中断处理的入口点。</p>
<p>对于每条中断线，处理器都会跳到对应唯一位置，这样内核就知道所接收中断的IRQ号，初始入口点只是在栈上保存这个号，并存放当前寄存器的值（这些值属于当前被中断任务）。</p>
<p>然后内核调用do_IRQ()</p>
<p><code>unsigned int do_IRQ(struct pt_regs regs)</code></p>
<p>计算出中断号，do_IRQ()对所接受的中断进行应答，禁止这条线上中断传递</p>
<p>do_IRQ()需要确保这条中断线上有一个有效的处理程序，并且这个程序已经启动，但没执行</p>
<p>调用handle_IRQ_event()来运行这条中断线所安装的中断处理程序。</p>
]]></content>
  </entry>
  <entry>
    <title>树剖</title>
    <url>/2021/07/01/%E6%A0%91%E5%89%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="POJ-2763"><a href="#POJ-2763" class="headerlink" title="POJ 2763"></a><a href="http://poj.org/problem?id=2763">POJ 2763</a></h3><ul>
<li><p>题意</p>
<p>给一棵边带权树，给定一个初始位置<code>s</code></p>
<p>有两种操作：</p>
<p>a. 从位置s转移到位置u,输出s-&gt;u距离</p>
<p>b.修改某一条边的权重</p>
</li>
<li><p>树剖，将树序列化</p>
<p>将边权转移到点上</p>
<p>树状数组支持单点修改</p>
<p>区间查询</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> son[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;G[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> n,q,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[x] = d;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    dep[x] = (f &lt;<span class="number">0</span> ? <span class="number">0</span>:dep[f]+<span class="number">1</span>);</span><br><span class="line">    son[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(a.first,x,d+a.second);</span><br><span class="line">            sz[x] += sz[a.first];</span><br><span class="line">            <span class="keyword">if</span>(son[x] == <span class="number">-1</span> || sz[son[x]] &lt; sz[a.first])</span><br><span class="line">            &#123;</span><br><span class="line">                son[x] = a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">100003</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">100004</span>];</span><br><span class="line"><span class="keyword">int</span> rev[<span class="number">100003</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">100003</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= <span class="number">100000</span>; i+= (i&amp;-i))</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i -= (i&amp;-i))</span><br><span class="line">    &#123;</span><br><span class="line">        ans += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = (f &lt; <span class="number">0</span> ? x:(son[f] == x ? top[f]:x));</span><br><span class="line">    id[x] = k;</span><br><span class="line">    rev[k++] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs1(son[x],x);</span><br><span class="line">        add(id[son[x]],dist[son[x]] - dist[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f &amp;&amp; a.first != son[x])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(a.first,x);</span><br><span class="line">            add(id[a.first],a.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">pair</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; &gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;q,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">        G[x].push_back(<span class="built_in">make_pair</span>(y,v));</span><br><span class="line">        G[y].push_back(<span class="built_in">make_pair</span>(x,v));</span><br><span class="line">        mp[i] = <span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(x,y),v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs1(s,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;v);</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; u = mp[y].first;</span><br><span class="line">            <span class="keyword">int</span> g = mp[y].second;</span><br><span class="line">            <span class="keyword">int</span> o;</span><br><span class="line">            <span class="keyword">if</span>(dep[u.first] &gt; dep[u.second])&#123;</span><br><span class="line">                o = u.first;</span><br><span class="line">            &#125;<span class="keyword">else</span> o = u.second;</span><br><span class="line"></span><br><span class="line">            add(id[o],-mp[y].second);</span><br><span class="line">            mp[y].second = v;</span><br><span class="line">            add(id[o],v);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            <span class="keyword">int</span> nxt = y;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(top[s] == top[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dep[s] &lt; dep[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += ask(id[y]) - ask(id[s]);</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += ask(id[s]) - ask(id[y]);</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//比较的是top[x] top[y]的深度</span></span><br><span class="line">                <span class="keyword">if</span>(dep[top[s]] &lt; dep[top[y]])&#123;</span><br><span class="line">                    ans += ask(id[y])- ask(id[top[y]]<span class="number">-1</span>);</span><br><span class="line">                    y = fa[top[y]];</span><br><span class="line">                </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += ask(id[s]) - ask(id[top[s]]<span class="number">-1</span>);</span><br><span class="line">                    s = fa[top[s]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">5 100 1</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">3 5 4</span></span><br><span class="line"><span class="comment">0 3</span></span><br><span class="line"><span class="comment">0 2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="POJ-3237"><a href="#POJ-3237" class="headerlink" title="POJ 3237"></a><a href="http://poj.org/problem?id=3237">POJ 3237</a></h3><ul>
<li>给一棵带权树，实现三种操作<ul>
<li>修改某一条边的权值</li>
<li>将路径u-&gt;v上所有边的权值取相反数</li>
<li>查询路径u-&gt;v上权值最大的边</li>
</ul>
</li>
<li>树链剖分</li>
<li>线段树维护单点修改，区间取反</li>
<li>注意懒标下传、上传</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> sz[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> son[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;G[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[x] = d;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    dep[x] = (f &lt;<span class="number">0</span> ? <span class="number">0</span>:dep[f]+<span class="number">1</span>);</span><br><span class="line">    son[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(a.first,x,a.second);</span><br><span class="line">            sz[x] += sz[a.first];</span><br><span class="line">            <span class="keyword">if</span>(son[x] == <span class="number">-1</span> || sz[son[x]] &lt; sz[a.first])</span><br><span class="line">            &#123;</span><br><span class="line">                son[x] = a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">10003</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">10004</span>];</span><br><span class="line"><span class="keyword">int</span> rev[<span class="number">10003</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">40005</span>];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P[<span class="number">40005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        P[x].first = P[x].second = dist[rev[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(<span class="number">2</span>*x,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*x+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">        P[x].first = P[x].second = v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x].second);</span><br><span class="line">        P[<span class="number">2</span>*x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x].second *= <span class="number">-1</span>;</span><br><span class="line">        swap(P[<span class="number">2</span>*x+<span class="number">1</span>].first,P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].first *= <span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">2</span>*x] ^= f[x];</span><br><span class="line">        f[<span class="number">2</span>*x+<span class="number">1</span>]^= f[x];</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        modify(<span class="number">2</span>*x, y,l,mid,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> modify(<span class="number">2</span>*x+<span class="number">1</span>,y,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">neg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= l &amp;&amp; b &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x] ^= <span class="number">1</span>;</span><br><span class="line">        swap(P[x].first,P[x].second);</span><br><span class="line">        P[x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[x].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x].second);</span><br><span class="line">        P[<span class="number">2</span>*x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x].second *= <span class="number">-1</span>;</span><br><span class="line">        swap(P[<span class="number">2</span>*x+<span class="number">1</span>].first,P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].first *= <span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">2</span>*x] ^= f[x];</span><br><span class="line">        f[<span class="number">2</span>*x+<span class="number">1</span>]^= f[x];</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        neg(<span class="number">2</span>*x,a,b,l,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        neg(<span class="number">2</span>*x+<span class="number">1</span>,a,b,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= l &amp;&amp; b &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> P[x].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x].second);</span><br><span class="line">        P[<span class="number">2</span>*x].first *=<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x].second *= <span class="number">-1</span>;</span><br><span class="line">        swap(P[<span class="number">2</span>*x+<span class="number">1</span>].first,P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].first *= <span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">2</span>*x+<span class="number">1</span>].second *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">2</span>*x] ^= f[x];</span><br><span class="line">        f[<span class="number">2</span>*x+<span class="number">1</span>]^= f[x];</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ask(<span class="number">2</span>*x,a,b,l,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ask(<span class="number">2</span>*x+<span class="number">1</span>,a,b,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ans = max(ask(<span class="number">2</span>*x,a,b,l,mid),ask(<span class="number">2</span>*x+<span class="number">1</span>,a,b,mid+<span class="number">1</span>,r));</span><br><span class="line">    P[x].first = min(P[<span class="number">2</span>*x].first,P[<span class="number">2</span>*x+<span class="number">1</span>].first);</span><br><span class="line">    P[x].second = max(P[<span class="number">2</span>*x].second, P[<span class="number">2</span>*x+<span class="number">1</span>].second);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = (f &lt; <span class="number">0</span> ? x:(son[f] == x ? top[f]:x));</span><br><span class="line">    id[x] = k;</span><br><span class="line">    rev[k++] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs1(son[x],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(a.first != f &amp;&amp; a.first != son[x])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(a.first,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; mp;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,v,w;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        mp.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            G[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">            G[x].push_back(<span class="built_in">make_pair</span>(y,v));</span><br><span class="line">            G[y].push_back(<span class="built_in">make_pair</span>(x,v));</span><br><span class="line">            mp[i] = <span class="built_in">make_pair</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        dfs1(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;v);</span><br><span class="line">                <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; u = mp[y];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> o;</span><br><span class="line">                <span class="keyword">if</span>(dep[u.first] &gt; dep[u.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    o = u.first;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> o = u.second;</span><br><span class="line"></span><br><span class="line">                modify(<span class="number">1</span>,id[o],<span class="number">1</span>,n,v);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">-2e9</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(top[x] == top[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dep[x] &lt; dep[y])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans = max(ans,ask(<span class="number">1</span>,id[x]+<span class="number">1</span>,id[y],<span class="number">1</span>,n));</span><br><span class="line">                            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(x != y)</span><br><span class="line">                                ans = max(ans,ask(<span class="number">1</span>,id[y]+<span class="number">1</span>,id[x],<span class="number">1</span>,n));</span><br><span class="line">                            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//比较的是top[x] top[y]的深度</span></span><br><span class="line">                    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans = max(ans,ask(<span class="number">1</span>,id[top[y]],id[y],<span class="number">1</span>,n));</span><br><span class="line">                        y = fa[top[y]];</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        ans = max(ans,ask(<span class="number">1</span>,id[top[x]],id[x],<span class="number">1</span>,n));</span><br><span class="line">                        x = fa[top[x]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(top[x] == top[y])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dep[x] &lt; dep[y])</span><br><span class="line">                        &#123;</span><br><span class="line">                            neg(<span class="number">1</span>,id[x]+<span class="number">1</span>,id[y],<span class="number">1</span>,n);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(dep[y] &lt; dep[x])</span><br><span class="line">                        &#123;</span><br><span class="line">                            neg(<span class="number">1</span>,id[y]+<span class="number">1</span>,id[x],<span class="number">1</span>,n);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        neg(<span class="number">1</span>,id[top[y]],id[y],<span class="number">1</span>,n);</span><br><span class="line">                        y = fa[top[y]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        neg(<span class="number">1</span>,id[top[x]],id[x],<span class="number">1</span>,n);</span><br><span class="line">                        x = fa[top[x]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1 2 0</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">1 4 3</span></span><br><span class="line"><span class="comment">2 5 4</span></span><br><span class="line"><span class="comment">2 6 5</span></span><br><span class="line"><span class="comment">3 7 3</span></span><br><span class="line"><span class="comment">7 8 3</span></span><br><span class="line"><span class="comment">2 9 0</span></span><br><span class="line"><span class="comment">4 10 2</span></span><br><span class="line"><span class="comment">N 4 8</span></span><br><span class="line"><span class="comment">C 2 -501</span></span><br><span class="line"><span class="comment">Q 9 4</span></span><br><span class="line"><span class="comment">Q 8 2</span></span><br><span class="line"><span class="comment">Q 1 6</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>协同过滤</title>
    <url>/2021/06/20/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="基于用户的协同过滤算法（UserCF"><a href="#基于用户的协同过滤算法（UserCF" class="headerlink" title="基于用户的协同过滤算法（UserCF)"></a>基于用户的协同过滤算法（UserCF)</h3><p>算法核心：当一个用户A需要个性化推荐时，先找和A相似兴趣的用户，把那些用户喜欢的推荐给用户A</p>
<p>a)找到和目标用户兴趣相似的用户集合</p>
<p>b)找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户</p>
<p>给定用户$u$,$v$,记$N(u)$为用户$u$给予正反馈的物品集合。</p>
<p>Jaccard公式</p>
<ul>
<li>$w<em>{uv} = \frac{\Sigma</em>{i\in N(u) \cap N(v)} \frac{1}{log(1+|N(i)|)}}{\sqrt(|N(u)||N(v)|)}$</li>
</ul>
<p>余弦公式</p>
<ul>
<li>$w_{uv} = \frac{|N(u) \cap N(v)|}{\sqrt|N(u)||N(v)|}$</li>
</ul>
<p>复杂度$O(n^2)$</p>
<p>计算$u$对物品$i$的感兴趣程度</p>
<p>$p(u,i) = \Sigma<em>{v \in S(u,K)\cap N(i)}w</em>{uv}r_{vi}$</p>
<p>其中$S(u,K)$包含和用户$u$兴趣最接近的$K$个用户，$N(i)$是对物品$i$有过行为的用户集合，$W<em>{uv}$是用户$u$与$v$的相似程度，$r</em>{vi}$是用户$v$对物品$i$的兴趣程度。</p>
<h3 id="基于物品的协同过滤算法（ItemCF"><a href="#基于物品的协同过滤算法（ItemCF" class="headerlink" title="基于物品的协同过滤算法（ItemCF)"></a>基于物品的协同过滤算法（ItemCF)</h3><p>算法思想：给用户推荐那些和他们之前喜欢的物品相似的物品</p>
<p>计算物品之间的相似度</p>
<p>$w_{ij} = \frac{|N(i)\cap N(j)|}{\sqrt|N(i)|| N(j)|} $</p>
<p>根据物品相似度和用户的历史行为给用户生成推荐列表</p>
<p>计算用户$u$对一个物品$j$的兴趣</p>
<p>$p<em>{uj} = \Sigma</em>{i\in N(u) \cap S(i,K)} W<em>{ji}r</em>{ui}$</p>
<p>$S(i,K)$表示和$i$最相似的$K$个物品集合。</p>
<p>$r_{ui}$表示用户$u$对物品$i$的感兴趣程度</p>
<p>优化：</p>
<p>1）用户活跃度对物品相似度的影响</p>
<p>$w<em>{ij} = \frac{\Sigma</em>{u \in N(i)\cap N(j)}\frac{1}{log(1+|N(u)|)}}{\sqrt(|N(i)||N(j)|)}$</p>
<p>2)物品相似度归一化</p>
<p>$w<em>{ij}’ = \frac{w</em>{ij}}{max<em>{j}w</em>{ij}}$</p>
]]></content>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2021/06/11/CMake/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="A-Basic-Starting-Point"><a href="#A-Basic-Starting-Point" class="headerlink" title="A Basic Starting Point"></a>A Basic Starting Point</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#set the project name</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="comment">#add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>
<p>The source code for <code>tutorial.cxx</code> is provided in the <code>Step1</code> directory .</p>
<h4 id="Adding-a-Version-Number-and-Configured-Header-File"><a href="#Adding-a-Version-Number-and-Configured-Header-File" class="headerlink" title="Adding a Version Number and Configured Header File"></a>Adding a Version Number and Configured Header File</h4><p>The first feature we will add is to provide our executable and project with a version number.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p>Then, configure a header file to pass the version number to the source code:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure>
<p>Since the configured file will be written into the binary tree, we must add that directory to the list of paths to search for include files. Add the following lines to the end of the <code>CMakeLists.txt</code> file:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>
<p>create <code>TutorialConfig.h.in</code> in the source directory with the following contents:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure>
<p>Next modify <code>tutorial.cxx</code> to include the configured header file, <code>TutorialConfig.h</code>.</p>
<p>Finally, let’s print out the executable name and version number by updating <code>tutorial.cxx</code> as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// report version</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; Version &quot;</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">              &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; number&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Specify-the-C-Standard"><a href="#Specify-the-C-Standard" class="headerlink" title="Specify the C++ Standard"></a>Specify the C++ Standard</h4><p>We will need to explicitly state in the CMake code that it should use the correct flags. </p>
<p>The easiest way to enable support for a specific C++ standard in CMake is by using the <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_STANDARD.html#variable:CMAKE_CXX_STANDARD"><code>CMAKE_CXX_STANDARD</code></a> variable. </p>
<p>For this tutorial, set the <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_STANDARD.html#variable:CMAKE_CXX_STANDARD"><code>CMAKE_CXX_STANDARD</code></a> variable in the <code>CMakeLists.txt</code> file to 11 and <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_STANDARD_REQUIRED.html#variable:CMAKE_CXX_STANDARD_REQUIRED"><code>CMAKE_CXX_STANDARD_REQUIRED</code></a> to True. </p>
<p>Make sure to add the <code>CMAKE_CXX_STANDARD</code> declarations above the call to <code>add_executable</code>.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Build-and-Test"><a href="#Build-and-Test" class="headerlink" title="Build and Test"></a>Build and Test</h4><p>Run the <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1"><code>cmake</code></a>) executable</p>
<p>For example, from the command line we could navigate to the <code>Help/guide/tutorial</code> directory of the CMake source code tree and create a build directory:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir step1_build</span><br></pre></td></tr></table></figure>
<p>Next, navigate to the build directory and run CMake to configure the project and generate a native build system:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd step1_build</span><br><span class="line">cmake ../step1</span><br></pre></td></tr></table></figure>
<p>Then call that build system to actually compile/link the project:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>
<h3 id="Adding-a-Library"><a href="#Adding-a-Library" class="headerlink" title="Adding a Library"></a>Adding a Library</h3><p>For this tutorial we will put the library into a subdirectory called <code>MathFunctions</code>. </p>
<p>This directory already contains a header file, <code>MathFunctions.h</code>, and a source file <code>mysqrt.cxx</code>. </p>
<p>The source file has one function called <code>mysqrt</code> that provides similar functionality to the compiler’s <code>sqrt</code> function.</p>
<p>Add the following one line <code>CMakeLists.txt</code> file to the <code>MathFunctions</code> directory:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cxx)</span><br></pre></td></tr></table></figure>
<p>To make use of the new library we will add an <a href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html#command:add_subdirectory"><code>add_subdirectory()</code></a> call in the top-level <code>CMakeLists.txt</code> file so that the library will get built. </p>
<p>We add the new library to the executable, and add <code>MathFunctions</code> as an include directory so that the <code>mysqrt.h</code> header file can be found. </p>
<p>The last few lines of the top-level <code>CMakeLists.txt</code> file should now look like:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                          <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">                          <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span></span><br><span class="line">                          )</span><br></pre></td></tr></table></figure>
<p>Now let us make the MathFunctions library optional. </p>
<p>While for the tutorial there really isn’t any need to do so, for larger projects this is a common occurrence. </p>
<p>The first step is to add an option to the top-level <code>CMakeLists.txt</code> file.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></table></figure>
<p>This option will be displayed in the <a href="https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual:cmake-gui(1"><code>cmake-gui</code></a>) and <a href="https://cmake.org/cmake/help/latest/manual/ccmake.1.html#manual:ccmake(1"><code>ccmake</code></a>) with a default value of ON that can be changed by the user. This setting will be stored in the cache so that the user does not need to set the value each time they run CMake on a build directory.</p>
<p>The next change is to make building and linking the MathFunctions library conditional. To do this we change the end of the top-level <code>CMakeLists.txt</code> file to look like the following:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_INCLUDES <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">                           <span class="variable">$&#123;EXTRA_INCLUDES&#125;</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>
<p>Note the use of the variable <code>EXTRA_LIBS</code> to collect up any optional libraries to later be linked into the executable. </p>
<p>The variable <code>EXTRA_INCLUDES</code> is used similarly for optional header files. </p>
<p>This is a classic approach when dealing with many optional components, we will cover the modern approach in the next step.</p>
<p>The corresponding changes to the source code are fairly straightforward. </p>
<p>First, in <code>tutorial.cxx</code>, include the <code>MathFunctions.h</code> header if we need it:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Then, in the same file, make <code>USE_MYMATH</code> control which square root function is used:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = mysqrt(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Since the source code now requires <code>USE_MYMATH</code> we can add it to <code>TutorialConfig.h.in</code> with the following line:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure>
<p>Run the <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1"><code>cmake</code></a>) executable or the <a href="https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual:cmake-gui(1"><code>cmake-gui</code></a>) to configure the project and then build it with your chosen build tool. Then run the built Tutorial executable.</p>
<p>Now let’s update the value of <code>USE_MYMATH</code>. The easiest way is to use the <a href="https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual:cmake-gui(1"><code>cmake-gui</code></a>) or <a href="https://cmake.org/cmake/help/latest/manual/ccmake.1.html#manual:ccmake(1"><code>ccmake</code></a>) if you’re in the terminal. Or, alternatively, if you want to change the option from the command-line, try:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake ../Step2 -DUSE_MYMATH=OFF</span><br></pre></td></tr></table></figure>
<h3 id="Adding-Usage-Requirements-for-Library"><a href="#Adding-Usage-Requirements-for-Library" class="headerlink" title="Adding Usage Requirements for Library"></a>Adding Usage Requirements for Library</h3><p>Usage requirements allow for far better control over a library or executable’s link and include line while also giving more control over the transitive property of targets inside CMake. </p>
<p>The primary commands that leverage usage requirements are:</p>
<ul>
<li>target_compile_definitions()</li>
<li>target_compile_options()</li>
<li>target_include_directories()</li>
<li>target_link_libraries()</li>
</ul>
<p>Let’s refactor our code from Adding a Library to use the modern CMake approach of usage requirements. </p>
<p>We first state that anybody linking to MathFunctions needs to include the current source directory, while MathFunctions itself doesn’t. </p>
<p>So this can become an <code>INTERFACE</code> usage requirement.</p>
<p>Remember <code>INTERFACE</code> means things that consumers require but the producer doesn’t. // ???? </p>
<p>Add the following lines to the end of <code>MathFunctions/CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">          INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>Now that we’ve specified usage requirements for MathFunctions we can safely remove our uses of the <code>EXTRA_INCLUDES</code> variable from the top-level <code>CMakeLists.txt</code>, here:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>And here:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>
<h3 id="Installing-and-Testing"><a href="#Installing-and-Testing" class="headerlink" title="Installing and Testing"></a>Installing and Testing</h3><h4 id="Install-Rules"><a href="#Install-Rules" class="headerlink" title="Install Rules"></a>Install Rules</h4><p>The install rules are fairly simple: </p>
<p>for MathFunctions we want to install the library and header file and </p>
<p>for the application we want to install the executable and configured header.</p>
<p>So to the end of <code>MathFunctions/CMakeLists.txt</code> we add:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>And to the end of the top-level <code>CMakeLists.txt</code> we add:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS Tutorial DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span></span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>That is all that is needed to create a basic local install of the tutorial.</p>
<p>Then run the install step by using the <code>install</code> option of the <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1"><code>cmake</code></a>) command (introduced in 3.15, older versions of CMake must use <code>make install</code>) from the command line. For multi-configuration tools, don’t forget to use the <code>--config</code> argument to specify the configuration. If using an IDE, simply build the <code>INSTALL</code> target. This step will install the appropriate header files, libraries, and executables. For example:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake --<span class="keyword">install</span> .</span><br></pre></td></tr></table></figure>
<p>The CMake variable <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html#variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a> is used to determine the root of where the files will be installed. If using the <code>cmake --install</code> command, the installation prefix can be overridden via the <code>--prefix</code> argument. For example:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake --<span class="keyword">install</span> . --prefix <span class="string">&quot;/home/myuser/installdir&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Testing-Support"><a href="#Testing-Support" class="headerlink" title="Testing Support"></a>Testing Support</h4><p>Next let’s test our application. At the end of the top-level <code>CMakeLists.txt</code> file we can enable testing and then add a number of basic tests to verify that the application is working correctly.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a function to simplify adding tests</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">  <span class="keyword">add_test</span>(NAME Comp<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">  <span class="keyword">set_tests_properties</span>(Comp<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test(Tutorial <span class="number">4</span> <span class="string">&quot;4 is 2&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">9</span> <span class="string">&quot;9 is 3&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">5</span> <span class="string">&quot;5 is 2.236&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">7</span> <span class="string">&quot;7 is 2.645&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">25</span> <span class="string">&quot;25 is 5&quot;</span>)</span><br><span class="line">do_test(Tutorial -<span class="number">25</span> <span class="string">&quot;-25 is [-nan|nan|0]&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">0.0001</span> <span class="string">&quot;0.0001 is 0.01&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>The first test simply verifies that the application runs, does not segfault or otherwise crash, and has a zero return value. This is the basic form of a CTest test.</p>
<p>The next test makes use of the <a href="https://cmake.org/cmake/help/latest/prop_test/PASS_REGULAR_EXPRESSION.html#prop_test:PASS_REGULAR_EXPRESSION"><code>PASS_REGULAR_EXPRESSION</code></a> test property to verify that the output of the test contains certain strings. In this case, verifying that the usage message is printed when an incorrect number of arguments are provided.</p>
<p>Lastly, we have a function called <code>do_test</code> that runs the application and verifies that the computed square root is correct for given input. For each invocation of <code>do_test</code>, another test is added to the project with a name, input, and expected results based on the passed arguments.</p>
<p>Rebuild the application and then cd to the binary directory and run the <a href="https://cmake.org/cmake/help/latest/manual/ctest.1.html#manual:ctest(1"><code>ctest</code></a>) executable: <code>ctest -N</code> and <code>ctest -VV</code>. For multi-config generators (e.g. Visual Studio), the configuration type must be specified. To run tests in Debug mode, for example, use <code>ctest -C Debug -VV</code> from the build directory (not the Debug subdirectory!). Alternatively, build the <code>RUN_TESTS</code> target from the IDE.</p>
<h3 id="Adding-System-Introspection"><a href="#Adding-System-Introspection" class="headerlink" title="Adding System Introspection"></a>Adding System Introspection</h3><p>If the platform has <code>log</code> and <code>exp</code> then we will use them to compute the square root in the <code>mysqrt</code> function. We first test for the availability of these functions using the <a href="https://cmake.org/cmake/help/latest/module/CheckSymbolExists.html#module:CheckSymbolExists"><code>CheckSymbolExists</code></a> module in <code>MathFunctions/CMakeLists.txt</code>. On some platforms, we will need to link to the m library. If <code>log</code> and <code>exp</code> are not initially found, require the m library and try again.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckSymbolExists)</span><br><span class="line">check_symbol_exists(log <span class="string">&quot;math.h&quot;</span> HAVE_LOG)</span><br><span class="line">check_symbol_exists(exp <span class="string">&quot;math.h&quot;</span> HAVE_EXP)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> (HAVE_LOG <span class="keyword">AND</span> HAVE_EXP))</span><br><span class="line">  <span class="keyword">unset</span>(HAVE_LOG CACHE)</span><br><span class="line">  <span class="keyword">unset</span>(HAVE_EXP CACHE)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_REQUIRED_LIBRARIES <span class="string">&quot;m&quot;</span>)</span><br><span class="line">  check_symbol_exists(log <span class="string">&quot;math.h&quot;</span> HAVE_LOG)</span><br><span class="line">  check_symbol_exists(exp <span class="string">&quot;math.h&quot;</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE m)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>If available, use <a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html#command:target_compile_definitions"><code>target_compile_definitions()</code></a> to specify <code>HAVE_LOG</code> and <code>HAVE_EXP</code> as <code>PRIVATE</code> compile definitions.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(MathFunctions</span><br><span class="line">                             PRIVATE <span class="string">&quot;HAVE_LOG&quot;</span> <span class="string">&quot;HAVE_EXP&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>If <code>log</code> and <code>exp</code> are available on the system, then we will use them to compute the square root in the <code>mysqrt</code> function. Add the following code to the <code>mysqrt</code> function in <code>MathFunctions/mysqrt.cxx</code> (don’t forget the <code>#endif</code> before returning the result!):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_LOG) &amp;&amp; defined(HAVE_EXP)</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="built_in">exp</span>(<span class="built_in">log</span>(x) * <span class="number">0.5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result</span><br><span class="line">            &lt;&lt; <span class="string">&quot; using log and exp&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">double</span> result = x;</span><br></pre></td></tr></table></figure>
<p>We will also need to modify <code>mysqrt.cxx</code> to include <code>cmath</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Adding-a-Custom-Command-and-Generated-File"><a href="#Adding-a-Custom-Command-and-Generated-File" class="headerlink" title="Adding a Custom Command and Generated File"></a>Adding a Custom Command and Generated File</h3><p>Suppose, for the purpose of this tutorial, we decide that we never want to use the platform <code>log</code> and <code>exp</code> functions and instead would like to generate a table of precomputed values to use in the <code>mysqrt</code> function. In this section, we will create the table as part of the build process, and then compile that table into our application.</p>
<p>First, let’s remove the check for the <code>log</code> and <code>exp</code> functions in <code>MathFunctions/CMakeLists.txt</code>. Then remove the check for <code>HAVE_LOG</code> and <code>HAVE_EXP</code> from <code>mysqrt.cxx</code>. At the same time, we can remove <code>#include &lt;cmath&gt;</code>.</p>
<p>In the <code>MathFunctions</code> subdirectory, a new source file named <code>MakeTable.cxx</code> has been provided to generate the table.</p>
<p>After reviewing the file, we can see that the table is produced as valid C++ code and that the output filename is passed in as an argument.</p>
<p>The next step is to add the appropriate commands to the <code>MathFunctions/CMakeLists.txt</code> file to build the MakeTable executable and then run it as part of the build process. A few commands are needed to accomplish this.</p>
<p>First, at the top of <code>MathFunctions/CMakeLists.txt</code>, the executable for <code>MakeTable</code> is added as any other executable would be added.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(MakeTable MakeTable.cxx)</span><br></pre></td></tr></table></figure>
<p>Then we add a custom command that specifies how to produce <code>Table.h</code> by running MakeTable.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">  <span class="keyword">COMMAND</span> MakeTable <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">  DEPENDS MakeTable</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>Next we have to let CMake know that <code>mysqrt.cxx</code> depends on the generated file <code>Table.h</code>. This is done by adding the generated <code>Table.h</code> to the list of sources for the library MathFunctions.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions</span><br><span class="line">            mysqrt.cxx</span><br><span class="line">            <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<p>We also have to add the current binary directory to the list of include directories so that <code>Table.h</code> can be found and included by <code>mysqrt.cxx</code>.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">          INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">          PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>Now let’s use the generated table. First, modify <code>mysqrt.cxx</code> to include <code>Table.h</code>. Next, we can rewrite the mysqrt function to use the table:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use the table to help find an initial value</span></span><br><span class="line">  <span class="keyword">double</span> result = x;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Use the table to help find an initial value &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    result = sqrtTable[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x)];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do ten iterations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      result = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">    result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Run the <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1"><code>cmake</code></a>) executable or the <a href="https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual:cmake-gui(1"><code>cmake-gui</code></a>) to configure the project and then build it with your chosen build tool.</p>
<p>When this project is built it will first build the <code>MakeTable</code> executable. It will then run <code>MakeTable</code> to produce <code>Table.h</code>. Finally, it will compile <code>mysqrt.cxx</code> which includes <code>Table.h</code> to produce the MathFunctions library.</p>
<p>Run the Tutorial executable and verify that it is using the table.</p>
<h3 id="Building-an-Installer"><a href="#Building-an-Installer" class="headerlink" title="Building an Installer"></a>Building an Installer</h3><p>Next suppose that we want to distribute our project to other people so that they can use it.</p>
<p> We want to provide both binary and source distributions on a variety of platforms. </p>
<p>This is a little different from the install we did previously in Installing and Testing , where we were installing the binaries that we had built from the source code. </p>
<p>In this example we will be building installation packages that support binary installations and package management features. </p>
<p>To accomplish this we will use CPack to create platform specific installers. Specifically we need to add a few lines to the bottom of our top-level <code>CMakeLists.txt</code> file.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(InstallRequiredSystemLibraries)</span><br><span class="line"><span class="keyword">set</span>(CPACK_RESOURCE_FILE_LICENSE <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION_MAJOR <span class="string">&quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION_MINOR <span class="string">&quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure>
<p>That is all there is to it. We start by including <a href="https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html#module:InstallRequiredSystemLibraries"><code>InstallRequiredSystemLibraries</code></a>. </p>
<p>This module will include any runtime libraries that are needed by the project for the current platform. </p>
<p>Next we set some CPack variables to where we have stored the license and version information for this project. </p>
<p>The version information was set earlier in this tutorial and the <code>license.txt</code> has been included in the top-level source directory for this step.</p>
<p>Finally we include the <a href="https://cmake.org/cmake/help/latest/module/CPack.html#module:CPack"><code>CPack module</code></a> which will use these variables and some other properties of the current system to setup an installer.</p>
<p>The next step is to build the project in the usual manner and then run the <a href="https://cmake.org/cmake/help/latest/manual/cpack.1.html#manual:cpack(1"><code>cpack</code></a>) executable. </p>
<p>To build a binary distribution, from the binary directory run:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpack</span><br></pre></td></tr></table></figure>
<p>To specify the generator, use the <code>-G</code> option. For multi-config builds, use <code>-C</code> to specify the configuration. For example:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpack -G ZIP -C Debug</span><br></pre></td></tr></table></figure>
<p>To create a source distribution you would type:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpack --config CPackSourceConfig.cmake</span><br></pre></td></tr></table></figure>
<p>Alternatively, run <code>make package</code> or right click the <code>Package</code> target and <code>Build Project</code> from an IDE.</p>
<p>Run the installer found in the binary directory. Then run the installed executable and verify that it works.</p>
<h3 id="Adding-Support-for-a-Dashboard"><a href="#Adding-Support-for-a-Dashboard" class="headerlink" title="Adding Support for a Dashboard"></a>Adding Support for a Dashboard</h3><p>Adding support for submitting our test results to a dashboard is simple. </p>
<p>We already defined a number of tests for our project in <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#testing-support">Testing Support</a>. </p>
<p>Now we just have to run those tests and submit them to a dashboard. </p>
<p>To include support for dashboards we include the <a href="https://cmake.org/cmake/help/latest/module/CTest.html#module:CTest"><code>CTest</code></a> module in our top-level <code>CMakeLists.txt</code>.</p>
<p>Replace:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable testing</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br></pre></td></tr></table></figure>
<p>With:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable dashboard scripting</span></span><br><span class="line"><span class="keyword">include</span>(CTest)</span><br></pre></td></tr></table></figure>
<p>The <a href="https://cmake.org/cmake/help/latest/module/CTest.html#module:CTest"><code>CTest</code></a> module will automatically call <code>enable_testing()</code>, so we can remove it from our CMake files.</p>
<p>We will also need to create a <code>CTestConfig.cmake</code> file in the top-level directory where we can specify the name of the project and where to submit the dashboard.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CTEST_PROJECT_NAME <span class="string">&quot;CMakeTutorial&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_NIGHTLY_START_TIME <span class="string">&quot;00:00:00 EST&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_METHOD <span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE <span class="string">&quot;my.cdash.org&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_LOCATION <span class="string">&quot;/submit.php?project=CMakeTutorial&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE_CDASH <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p>The <a href="https://cmake.org/cmake/help/latest/manual/ctest.1.html#manual:ctest(1"><code>ctest</code></a>) executable will read in this file when it runs. To create a simple dashboard you can run the <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1"><code>cmake</code></a>) executable or the <a href="https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html#manual:cmake-gui(1"><code>cmake-gui</code></a>) to configure the project, but do not build it yet. Instead, change directory to the binary tree, and then run:</p>
<blockquote>
<p>ctest [-VV] -D Experimental</p>
</blockquote>
<p>Remember, for multi-config generators (e.g. Visual Studio), the configuration type must be specified:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctest [-VV] -C Debug -D Experimental</span><br></pre></td></tr></table></figure>
<p>Or, from an IDE, build the <code>Experimental</code> target.</p>
<p>The <a href="https://cmake.org/cmake/help/latest/manual/ctest.1.html#manual:ctest(1"><code>ctest</code></a>) executable will build and test the project and submit the results to Kitware’s public dashboard: <a href="https://my.cdash.org/index.php?project=CMakeTutorial">https://my.cdash.org/index.php?project=CMakeTutorial</a>.</p>
<h3 id="Mixing-Static-and-Shared"><a href="#Mixing-Static-and-Shared" class="headerlink" title="Mixing Static and Shared"></a>Mixing Static and Shared</h3><p>In this section we will show how the <a href="https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html#variable:BUILD_SHARED_LIBS"><code>BUILD_SHARED_LIBS</code></a> variable can be used to control the default behavior of <a href="https://cmake.org/cmake/help/latest/command/add_library.html#command:add_library"><code>add_library()</code></a>, and allow control over how libraries without an explicit type (<code>STATIC</code>, <code>SHARED</code>, <code>MODULE</code> or <code>OBJECT</code>) are built.</p>
<p>To accomplish this we need to add <a href="https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html#variable:BUILD_SHARED_LIBS"><code>BUILD_SHARED_LIBS</code></a> to the top-level <code>CMakeLists.txt</code>. We use the <a href="https://cmake.org/cmake/help/latest/command/option.html#command:option"><code>option()</code></a> command as it allows users to optionally select if the value should be ON or OFF.</p>
<p>Next we are going to refactor MathFunctions to become a real library that encapsulates using <code>mysqrt</code> or <code>sqrt</code>, instead of requiring the calling code to do this logic. This will also mean that <code>USE_MYMATH</code> will not control building MathFunctions, but instead will control the behavior of this library.</p>
<p>The first step is to update the starting section of the top-level <code>CMakeLists.txt</code> to look like:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># control where the static and shared libraries are built so that on windows</span></span><br><span class="line"><span class="comment"># we don&#x27;t need to tinker with the path to run the executable</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build using shared libraries&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass the version number only</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br></pre></td></tr></table></figure>
<p>Now that we have made MathFunctions always be used, we will need to update the logic of that library. So, in <code>MathFunctions/CMakeLists.txt</code> we need to create a SqrtLibrary that will conditionally be built and installed when <code>USE_MYMATH</code> is enabled. Now, since this is a tutorial, we are going to explicitly require that SqrtLibrary is built statically.</p>
<p>The end result is that <code>MathFunctions/CMakeLists.txt</code> should look like:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add the library that runs</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions MathFunctions.cxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don&#x27;t.</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">                           INTERFACE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">                           )</span><br><span class="line"></span><br><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(MathFunctions PRIVATE <span class="string">&quot;USE_MYMATH&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># first we add the executable that generates the table</span></span><br><span class="line">  <span class="keyword">add_executable</span>(MakeTable MakeTable.cxx)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># add the command to generate the source code</span></span><br><span class="line">  <span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">    <span class="keyword">COMMAND</span> MakeTable <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">    DEPENDS MakeTable</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># library that just does sqrt</span></span><br><span class="line">  <span class="keyword">add_library</span>(SqrtLibrary STATIC</span><br><span class="line">              mysqrt.cxx</span><br><span class="line">              <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/Table.h</span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># state that we depend on our binary dir to find Table.h</span></span><br><span class="line">  <span class="keyword">target_include_directories</span>(SqrtLibrary PRIVATE</span><br><span class="line">                             <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">                             )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE SqrtLibrary)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the symbol stating we are using the declspec(dllexport) when</span></span><br><span class="line"><span class="comment"># building on windows</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(MathFunctions PRIVATE <span class="string">&quot;EXPORTING_MYMATH&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># install rules</span></span><br><span class="line"><span class="keyword">set</span>(installable_libs MathFunctions)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">TARGET</span> SqrtLibrary)</span><br><span class="line">  <span class="keyword">list</span>(APPEND installable_libs SqrtLibrary)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;installable_libs&#125;</span> DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>Next, update <code>MathFunctions/mysqrt.cxx</code> to use the <code>mathfunctions</code> and <code>detail</code> namespaces:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include the generated table</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Table.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions &#123;</span><br><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use the table to help find an initial value</span></span><br><span class="line">  <span class="keyword">double</span> result = x;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Use the table to help find an initial value &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    result = sqrtTable[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x)];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do ten iterations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      result = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">    result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We also need to make some changes in <code>tutorial.cxx</code>, so that it no longer uses <code>USE_MYMATH</code>:</p>
<ol>
<li>Always include <code>MathFunctions.h</code></li>
<li>Always use <code>mathfunctions::sqrt</code></li>
<li>Don’t include cmath</li>
</ol>
<p>Finally, update <code>MathFunctions/MathFunctions.h</code> to use dll export defines:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined(EXPORTING_MYMATH)</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> DECLSPEC __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> DECLSPEC __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// non windows</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> DECLSPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions &#123;</span><br><span class="line"><span class="function"><span class="keyword">double</span> DECLSPEC <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At this point, if you build everything, you may notice that linking fails as we are combining a static library without position independent code with a library that has position independent code. The solution to this is to explicitly set the <a href="https://cmake.org/cmake/help/latest/prop_tgt/POSITION_INDEPENDENT_CODE.html#prop_tgt:POSITION_INDEPENDENT_CODE"><code>POSITION_INDEPENDENT_CODE</code></a> target property of SqrtLibrary to be True no matter the build type.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state that SqrtLibrary need PIC when the default is shared libraries</span></span><br><span class="line">  <span class="keyword">set_target_properties</span>(SqrtLibrary PROPERTIES</span><br><span class="line">                        POSITION_INDEPENDENT_CODE <span class="variable">$&#123;BUILD_SHARED_LIBS&#125;</span></span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE SqrtLibrary)</span><br></pre></td></tr></table></figure>
<h3 id="Adding-Generator-Expressions"><a href="#Adding-Generator-Expressions" class="headerlink" title="Adding Generator Expressions"></a>Adding Generator Expressions</h3><p><a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7"><code>Generator expressions</code></a>) are evaluated during build system generation to produce information specific to each build configuration.</p>
<p><a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7"><code>Generator expressions</code></a>) are allowed in the context of many target properties, such as <a href="https://cmake.org/cmake/help/latest/prop_tgt/LINK_LIBRARIES.html#prop_tgt:LINK_LIBRARIES"><code>LINK_LIBRARIES</code></a>, <a href="https://cmake.org/cmake/help/latest/prop_tgt/INCLUDE_DIRECTORIES.html#prop_tgt:INCLUDE_DIRECTORIES"><code>INCLUDE_DIRECTORIES</code></a>, <a href="https://cmake.org/cmake/help/latest/prop_tgt/COMPILE_DEFINITIONS.html#prop_tgt:COMPILE_DEFINITIONS"><code>COMPILE_DEFINITIONS</code></a> and others. They may also be used when using commands to populate those properties, such as <a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command:target_link_libraries"><code>target_link_libraries()</code></a>, <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html#command:target_include_directories"><code>target_include_directories()</code></a>, <a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html#command:target_compile_definitions"><code>target_compile_definitions()</code></a> and others.<br><a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7"><code>Generator expressions</code></a>) may be used to enable conditional linking, conditional definitions used when compiling, conditional include directories and more. The conditions may be based on the build configuration, target properties, platform information or any other queryable information.</p>
<p>There are different types of <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7"><code>generator expressions</code></a>) including Logical, Informational, and Output expressions.</p>
<p>Logical expressions are used to create conditional output. The basic expressions are the 0 and 1 expressions. A <code>$&lt;0:...&gt;</code> results in the empty string, and <code>&lt;1:...&gt;</code> results in the content of “…”. They can also be nested.</p>
<p>A common usage of <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7"><code>generator expressions</code></a>) is to conditionally add compiler flags, such as those for language levels or warnings. A nice pattern is to associate this information to an <code>INTERFACE</code> target allowing this information to propagate. Let’s start by constructing an <code>INTERFACE</code> target and specifying the required C++ standard level of <code>11</code> instead of using <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CXX_STANDARD.html#variable:CMAKE_CXX_STANDARD"><code>CMAKE_CXX_STANDARD</code></a>.</p>
<p>So the following code:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>Would be replaced with:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(tutorial_compiler_flags INTERFACE)</span><br><span class="line"><span class="keyword">target_compile_features</span>(tutorial_compiler_flags INTERFACE cxx_std_11)</span><br></pre></td></tr></table></figure>
<p>Next we add the desired compiler warning flags that we want for our project. As warning flags vary based on the compiler we use the <code>COMPILE_LANG_AND_ID</code> generator expression to control which flags to apply given a language and a set of compiler ids as seen below:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(gcc_like_cxx <span class="string">&quot;$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(msvc_cxx <span class="string">&quot;$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">target_compile_options</span>(tutorial_compiler_flags INTERFACE</span><br><span class="line">  <span class="string">&quot;$&lt;$&#123;gcc_like_cxx&#125;:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;&quot;</span></span><br><span class="line">  <span class="string">&quot;$&lt;$&#123;msvc_cxx&#125;:$&lt;BUILD_INTERFACE:-W3&gt;&gt;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Looking at this we see that the warning flags are encapsulated inside a <code>BUILD_INTERFACE</code> condition. This is done so that consumers of our installed project will not inherit our warning flags.</p>
<h3 id="Adding-Export-Configuration"><a href="#Adding-Export-Configuration" class="headerlink" title="Adding Export Configuration"></a>Adding Export Configuration</h3><p>During <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#installing-and-testing-step-4">Installing and Testing (Step 4)</a> of the tutorial we added the ability for CMake to install the library and headers of the project. During <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#building-an-installer-step-7">Building an Installer (Step 7)</a> we added the ability to package up this information so it could be distributed to other people.</p>
<p>The next step is to add the necessary information so that other CMake projects can use our project, be it from a build directory, a local install or when packaged.</p>
<p>The first step is to update our <a href="https://cmake.org/cmake/help/latest/command/install.html#command:install"><code>install(TARGETS)</code></a> commands to not only specify a <code>DESTINATION</code> but also an <code>EXPORT</code>. The <code>EXPORT</code> keyword generates and installs a CMake file containing code to import all targets listed in the install command from the installation tree. So let’s go ahead and explicitly <code>EXPORT</code> the MathFunctions library by updating the <code>install</code> command in <code>MathFunctions/CMakeLists.txt</code> to look like:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(installable_libs MathFunctions tutorial_compiler_flags)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">TARGET</span> SqrtLibrary)</span><br><span class="line">  <span class="keyword">list</span>(APPEND installable_libs SqrtLibrary)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;installable_libs&#125;</span></span><br><span class="line">        DESTINATION lib</span><br><span class="line">        <span class="keyword">EXPORT</span> MathFunctionsTargets)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>Now that we have MathFunctions being exported, we also need to explicitly install the generated <code>MathFunctionsTargets.cmake</code> file. This is done by adding the following to the bottom of the top-level <code>CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">  <span class="keyword">FILE</span> MathFunctionsTargets.cmake</span><br><span class="line">  DESTINATION lib/cmake/MathFunctions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>At this point you should try and run CMake. If everything is setup properly you will see that CMake will generate an error that looks like:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Target &quot;MathFunctions&quot; INTERFACE_INCLUDE_DIRECTORIES property contains</span><br><span class="line">path:</span><br><span class="line"></span><br><span class="line">  &quot;/Users/robert/Documents/CMakeClass/Tutorial/Step11/MathFunctions&quot;</span><br><span class="line"></span><br><span class="line">which is prefixed in the source directory.</span><br></pre></td></tr></table></figure>
<p>What CMake is trying to say is that during generating the export information it will export a path that is intrinsically tied to the current machine and will not be valid on other machines. The solution to this is to update the MathFunctions <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html#command:target_include_directories"><code>target_include_directories()</code></a> to understand that it needs different <code>INTERFACE</code> locations when being used from within the build directory and from an install / package. This means converting the <a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html#command:target_include_directories"><code>target_include_directories()</code></a> call for MathFunctions to look like:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">                           INTERFACE</span><br><span class="line">                            $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>&gt;</span><br><span class="line">                            $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;</span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>
<p>Once this has been updated, we can re-run CMake and verify that it doesn’t warn anymore.</p>
<p>At this point, we have CMake properly packaging the target information that is required but we will still need to generate a <code>MathFunctionsConfig.cmake</code> so that the CMake <a href="https://cmake.org/cmake/help/latest/command/find_package.html#command:find_package"><code>find_package()</code></a> command can find our project. So let’s go ahead and add a new file to the top-level of the project called <code>Config.cmake.in</code> with the following contents:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@PACKAGE_INIT@</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> ( <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MathFunctionsTargets.cmake&quot;</span> )</span><br></pre></td></tr></table></figure>
<p>Then, to properly configure and install that file, add the following to the bottom of the top-level <code>CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">  <span class="keyword">FILE</span> MathFunctionsTargets.cmake</span><br><span class="line">  DESTINATION lib/cmake/MathFunctions</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br><span class="line"><span class="comment"># generate the config file that is includes the exports</span></span><br><span class="line">configure_package_config_file(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Config.cmake.in</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfig.cmake&quot;</span></span><br><span class="line">  INSTALL_DESTINATION <span class="string">&quot;lib/cmake/example&quot;</span></span><br><span class="line">  NO_SET_AND_CHECK_MACRO</span><br><span class="line">  NO_CHECK_REQUIRED_COMPONENTS_MACRO</span><br><span class="line">  )</span><br><span class="line"><span class="comment"># generate the version file for the config file</span></span><br><span class="line">write_basic_package_version_file(</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfigVersion.cmake&quot;</span></span><br><span class="line">  VERSION <span class="string">&quot;$&#123;Tutorial_VERSION_MAJOR&#125;.$&#123;Tutorial_VERSION_MINOR&#125;&quot;</span></span><br><span class="line">  COMPATIBILITY AnyNewerVersion</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># install the configuration file</span></span><br><span class="line"><span class="keyword">install</span>(FILES</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfig.cmake</span><br><span class="line">  DESTINATION lib/cmake/MathFunctions</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>At this point, we have generated a relocatable CMake Configuration for our project that can be used after the project has been installed or packaged. If we want our project to also be used from a build directory we only have to add the following to the bottom of the top level <code>CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">  <span class="keyword">FILE</span> <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsTargets.cmake&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>With this export call we now generate a <code>Targets.cmake</code>, allowing the configured <code>MathFunctionsConfig.cmake</code> in the build directory to be used by other projects, without needing it to be installed.</p>
<h3 id="Packaging-Debug-and-Release"><a href="#Packaging-Debug-and-Release" class="headerlink" title="Packaging Debug and Release"></a>Packaging Debug and Release</h3><p><strong>Note:</strong> This example is valid for single-configuration generators and will not work for multi-configuration generators (e.g. Visual Studio).</p>
<p>By default, CMake’s model is that a build directory only contains a single configuration, be it Debug, Release, MinSizeRel, or RelWithDebInfo. It is possible, however, to setup CPack to bundle multiple build directories and construct a package that contains multiple configurations of the same project.</p>
<p>First, we want to ensure that the debug and release builds use different names for the executables and libraries that will be installed. Let’s use d as the postfix for the debug executable and libraries.</p>
<p>Set <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_DEBUG_POSTFIX.html#variable:CMAKE_DEBUG_POSTFIX"><code>CMAKE_DEBUG_POSTFIX</code></a> near the beginning of the top-level <code>CMakeLists.txt</code> file:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_DEBUG_POSTFIX d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(tutorial_compiler_flags INTERFACE)</span><br></pre></td></tr></table></figure>
<p>And the <a href="https://cmake.org/cmake/help/latest/prop_tgt/DEBUG_POSTFIX.html#prop_tgt:DEBUG_POSTFIX"><code>DEBUG_POSTFIX</code></a> property on the tutorial executable:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"><span class="keyword">set_target_properties</span>(Tutorial PROPERTIES DEBUG_POSTFIX <span class="variable">$&#123;CMAKE_DEBUG_POSTFIX&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br></pre></td></tr></table></figure>
<p>Let’s also add version numbering to the MathFunctions library. In <code>MathFunctions/CMakeLists.txt</code>, set the <a href="https://cmake.org/cmake/help/latest/prop_tgt/VERSION.html#prop_tgt:VERSION"><code>VERSION</code></a> and <a href="https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html#prop_tgt:SOVERSION"><code>SOVERSION</code></a> properties:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> MathFunctions PROPERTY VERSION <span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> MathFunctions PROPERTY SOVERSION <span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>From the <code>Step12</code> directory, create <code>debug</code> and <code>release</code> subbdirectories. The layout will look like:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">- Step12</span><br><span class="line">   - debug</span><br><span class="line">   - release</span><br></pre></td></tr></table></figure>
<p>Now we need to setup debug and release builds. We can use <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html#variable:CMAKE_BUILD_TYPE"><code>CMAKE_BUILD_TYPE</code></a> to set the configuration type:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd debug</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br><span class="line">cmake --build .</span><br><span class="line">cd ../release</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>
<p>Now that both the debug and release builds are complete, we can use a custom configuration file to package both builds into a single release. In the <code>Step12</code> directory, create a file called <code>MultiCPackConfig.cmake</code>. In this file, first include the default configuration file that was created by the <a href="https://cmake.org/cmake/help/latest/manual/cmake.1.html#manual:cmake(1"><code>cmake</code></a>) executable.</p>
<p>Next, use the <code>CPACK_INSTALL_CMAKE_PROJECTS</code> variable to specify which projects to install. In this case, we want to install both debug and release.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;release/CPackConfig.cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPACK_INSTALL_CMAKE_PROJECTS</span><br><span class="line">    <span class="string">&quot;debug;Tutorial;ALL;/&quot;</span></span><br><span class="line">    <span class="string">&quot;release;Tutorial;ALL;/&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>From the <code>Step12</code> directory, run <a href="https://cmake.org/cmake/help/latest/manual/cpack.1.html#manual:cpack(1"><code>cpack</code></a>) specifying our custom configuration file with the <code>config</code> option:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cpack --config MultiCPackConfig.cmake</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>B-tree</title>
    <url>/2021/05/31/B-tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>给定key,要求从树中删除key指定的元素</p>
<ol>
<li><p>首先找到K的位置，如果没有找到，error</p>
</li>
<li><p>如果K在内部节点内（非叶子），找到当前节点的左子树C,将K换为C中最大的元素$K<em>{new}$，然后在子树中递归删除$K</em>{new}$</p>
</li>
<li><p>重复步骤2,直到删到到叶子节点,此时删除$K’$ ,若叶子节点的key数量仍然满足最小要求，删除完成</p>
</li>
<li><p>删除后，叶子节点可能少于最低要求，假设目标节点在父节点中位于$K<em>{left}$与$K</em>{right}$之间，首先检查它的左兄弟的键数量是否大于最低要求。</p>
<ul>
<li>如果是，把$K<em>{left}$移到当前节点，用左兄弟中的最大的key$K</em>{leftchild}$取代$K_{left}$</li>
<li>否则，检查右兄弟，如果右兄弟key数量大于最低要求，把右兄弟中最小的key$K<em>{rightchild}$取代$K</em>{right}$,$K_{right}$移到当前节点</li>
<li>如果当前节点是最左、最右子树，忽略检查不存在的兄弟</li>
<li>如果没有找到合适的兄弟节点，执行step 6</li>
</ul>
</li>
<li><p>对于非叶子节点，如果左兄弟有多于最低要求的keys,记$C<em>{left}$为左兄弟中最大的儿子,将$K</em>{left}$换为$K<em>{leftchild}$，将$K</em>{left}$挪到目标位置，同时把$C<em>{left}$也挪过来接到$K</em>{left}$左边。右兄弟类似</p>
</li>
<li><p>如果当前节点没有兄弟有多于最低要求的keys, 将目标节点与一个兄弟节点合并，如果左兄弟存在，合并左兄弟，否则合并右兄弟，同时也把父节点对应key移下来，（如果合并的是左兄弟，则为$K<em>{left}$,否则为$K</em>{right}$,父节点此时少了一个key,如果key数量不满足要求</p>
<p>递归执行4-6，如果满足了key的最低数量要求，算法完成</p>
</li>
<li><p>如果到达了根节点，且key的数量少于最低要求，删除根节点，合并孩子节点，树高减1</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/05/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><img src="/2021/05/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lake-5990540.jpg" class="">
<a id="more"></a>
<p>批处理操作系统</p>
<p>操作系统是一个简单的串行程序调度器和一系列库函数</p>
<p>操作系统中开始有设备文件任务，但只有一个独占计算机运行的程序。</p>
<ul>
<li>并发（Concurrent)多个执行流可以不按照一个特定顺序执行</li>
<li>并行（Parallel)允许多个执行流同时执行（多个处理器</li>
</ul>
<p>线程：多个执行流并发、并行执行，并且他们共享内存</p>
<ul>
<li>两个执行流共享代码和所有全局变量（数据、堆区）(寄存器，堆栈独享)</li>
<li>线程之间指令执行顺序是不确定（non-deterministic）的</li>
<li>共享代码：所有线程的代码都来自当前进程的代码</li>
<li>共享数据：全局数据、堆区可以自由引用</li>
<li>独立堆栈：每个线程都有独立的堆栈</li>
</ul>
<p>POSIX线程库（pthreads)</p>
<p>使用pthread_create创建并运行线程</p>
<p>使用pthread_join等待某个线程结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__thread <span class="keyword">int</span> id; <span class="comment">//thread-local variables</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用pmap可以查看到8192KiB内存映射区域和4KiB（一页的）guard（防止爆栈对其他线程造成影响</p>
</li>
<li><p>原子性（atomicity)</p>
<p>一段代码不允许和其他代码并发</p>
</li>
<li><p>指令序列可以在任意时刻被中断，操作系统切换到其他线程</p>
<ul>
<li>即使是最简单的x++，也不能保证原子性</li>
</ul>
</li>
</ul>
<p>编译优化</p>
<ul>
<li>允许源代码中内存访问指令不在按顺序甚至不再出现</li>
<li>编译器假设优化对象是单线程程序</li>
<li>假设程序是读写序列，编译器：<ul>
<li>在值能被确定的前提下，R(x)可能被删除</li>
<li>在未来x一定被覆盖的前提下，W(x)可能被删除</li>
<li>x,y读写可以交换顺序</li>
</ul>
</li>
<li>for(int i = 0; i &lt; n; i++)sum++</li>
</ul>
<p>-O1 tmp = R(sum); for (int i = 0; i &lt; n; i++); tmp += n; W(sum,tmp)</p>
<p>-O2 tmp = R(sum); tmp += n; W(sum,tmp);</p>
<ul>
<li><p>可见性的丧失</p>
<p>为了使CPU运行得更快，CPU可以不按顺序执行指令</p>
</li>
<li><p>现代处理器</p>
<ul>
<li>如果两条指令没有数据依赖关系，就能让他们并行执行</li>
<li>乱序执行<ul>
<li>多处理器上执行的结果可以不等价指令按照某个顺序执行的结果</li>
</ul>
</li>
</ul>
</li>
<li><p>C代码</p>
<ul>
<li>编译器优化-&gt;顺序丧失</li>
</ul>
</li>
<li><p>二进制文件</p>
</li>
<li><p>处理器执行</p>
<ul>
<li>中断、并行-&gt;原子性丧失</li>
<li>乱序执行-&gt;可见性丧失</li>
</ul>
</li>
<li><p>共享内存并发程序问题：</p>
<p>内存访问不保证按代码书写顺序发生</p>
<p>代码的原子性随时被破坏</p>
<p>执行过的指令可能在多处理器之间不可见</p>
</li>
<li><p>保证顺序</p>
<p>控制编译器行为、阻止编译优化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DELAY_COUNT,i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证内存访问（指令）顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() asm volatile(<span class="meta-string">&quot;&quot;</span>:::<span class="meta-string">&quot;memory&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   x++;</span><br><span class="line">   barrier();</span><br><span class="line">   x++;<span class="comment">//阻止x的访问被合并</span></span><br><span class="line">   y++;<span class="comment">//y的访问不能移到barrier之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有限状态机Finite State Machine(FSM)</p>
<ul>
<li>有向图G(V,E)<ul>
<li>节点$v \in V$是状态</li>
<li>边$e \in E$是状态的转换</li>
<li>边上有label代表执行某个动作</li>
</ul>
</li>
</ul>
<p>程序=有限状态机</p>
<p>（操作系统上的）程序执行时，状态是有限的</p>
<ul>
<li>寄存器（PC指针）</li>
<li>内存：代码，数据、堆栈</li>
</ul>
<p>构造有限状态机：</p>
<ul>
<li>每个不同的configuration(内存/寄存器)都是状态机的节点<ul>
<li>$s = (M,R)\in V$,代表某个时刻程序内存/寄存器的快照</li>
<li>16MiB内存就有$2^{2^{64}}$种不同状态</li>
</ul>
</li>
<li>$s = (M,R)$ 的下一个状态是执行$M[R[\%rip]]$处指令得到的$s’ = (M’,R’)$<ul>
<li>取出PC指针处的指令、译码、执行、写回数据</li>
<li>$(s,s’)\in E$</li>
</ul>
</li>
</ul>
<p>大部分状态s有唯一的后续状态（deterministic)</p>
<p>不确定（non-deterministic）指令可能有多种后续状态</p>
<ul>
<li><p>（时间）rdtsc/rdtscp</p>
</li>
<li><p>(机器状态)rdrand</p>
<p>处理器自身提供的真随机数指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">uint64_t</span> val;</span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdrand %0&quot;</span>: <span class="string">&quot;=r&quot;</span>(val))</span></span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;rdrand returns %016lx\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>系统调用（syscall)</p>
<p>read(fd,buf,size)</p>
</li>
<li><p>不确定性的来源：程序运行在操作系统/计算机硬件上，他们有自己的状态</p>
</li>
</ul>
<p>gdb:</p>
<p>info registers会列出所有的寄存器</p>
<p>/proc/[pid]/maps有内存映射信息</p>
<ul>
<li><p>应用</p>
<ul>
<li><p>在计算机硬件上的应用：高性能处理器的实现</p>
<p>超标量（superscalar)处理器</p>
<ul>
<li>insight:允许在状态机上跳跃</li>
</ul>
</li>
<li><p>在计算机系统上的应用：程序分析技术</p>
<ul>
<li>静态分析：根据程序代码推导出状态机的性质</li>
<li>动态分析：检查运行时观测到状态机的执行</li>
</ul>
</li>
</ul>
</li>
<li><p>程序执行能否在时间上后退？</p>
<p>记录所有的$s<em>{i}$开销太大（$s</em>{i}$由内存+寄存器组成）</p>
<p>但一条指令的side-effect通常有限</p>
<ul>
<li>只记录初始状态，和每条指令前后的diff</li>
</ul>
</li>
<li><p>线程</p>
<p>共享代码和数据</p>
<p>拥有独立的寄存器和堆栈</p>
<ul>
<li>堆栈也位于同一地址空间中</li>
<li>允许把局部变量的指针（&amp;local_var)传递给另一线程</li>
</ul>
</li>
<li><p>Peterson算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> turn = T1,x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x = <span class="number">1</span>; turn = T2;</span><br><span class="line">    <span class="keyword">while</span>(y &amp;&amp; turn == T2);</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    y = <span class="number">1</span>; turn = T1;</span><br><span class="line">    <span class="keyword">while</span>(x &amp;&amp; turn == T1);</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设：机器每次原子地（atomically)执行一行代码，内存访问立即可见</p>
</li>
</ul>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul>
<li><p>实现lock_t数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lk)</span></span>;<span class="comment">//试图获得锁的独占访问，成功获得后返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lk)</span></span>;<span class="comment">//释放锁的独占访问</span></span><br></pre></td></tr></table></figure>
<p>一把排他性的锁—对于锁对象lk</p>
<ul>
<li><p>在任何线程调度下</p>
<ul>
<li>若某个线程持有锁（lock(lk)返回未释放）</li>
<li>则任何其他线程lock(lk)都不能返回</li>
</ul>
</li>
<li><p>在共享内存上，共享资源的访问太危险（原子性、顺序、可见性丧失），互斥用来阻止代码块之间的并发，实现串行化</p>
<ul>
<li>lock/unlock保护区域成为一个原子的黑盒子</li>
<li>黑盒子的代码不能随意并发</li>
<li>且先完成的黑盒子的内存访问在之后的黑盒子中可见</li>
</ul>
</li>
<li><p>共享内存上实现互斥</p>
<ul>
<li>共享内存多线程：独立的寄存器、堆栈，共享内存</li>
<li>支持的基本操作<ul>
<li>线程本地（thread-local）计算(寄存器、堆栈上的数值读写、修改)（其他线程不可见</li>
<li>load，读共享内存</li>
<li>store，写共享内存</li>
<li>假设load,store是原子的</li>
</ul>
</li>
<li>困难在于：不能同时读写内存</li>
</ul>
</li>
<li><p>一条不可分割的指令</p>
<ul>
<li>一次共享内存的load</li>
<li>向同一共享内存地址的store</li>
<li>以及一些线程本地的计算</li>
</ul>
</li>
<li><p>原子操作保证：</p>
<ul>
<li>原子性：load/store不会被打断</li>
<li>顺序：线程执行乱序不能越过原子操作</li>
<li>多处理器之间的可见性：若原子操作A发生在B之前，在A之前的store对B之后的load可见</li>
</ul>
</li>
<li><p>x86原子操作</p>
<p>lock指令前缀</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock addq $1,%0&quot;</span>:<span class="string">&quot;=m&quot;</span>(sum))</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xchg</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> * addr,<span class="keyword">int</span> newval)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">     : <span class="string">&quot;+m&quot;</span>(*addr),<span class="comment">//[%0] addr (内存、读写)</span></span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="string">&quot;=a&quot;</span>(result)<span class="comment">//[%1]result (%eax)</span></span></span></span><br><span class="line"><span class="function"><span class="params">      :<span class="string">&quot;1&quot;</span>(newval)<span class="comment">//[%1]</span></span></span></span><br><span class="line"><span class="function"><span class="params">      :<span class="string">&quot;cc&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自旋锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> table = KEY;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> got = xchg(&amp;locked,NOTE);</span><br><span class="line"><span class="keyword">if</span>(got == KEY)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">xchg(&amp;table,KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(xchg(&amp;locked,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">xchg(&amp;locked,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RISC-V:另一种原子操作</p>
<p>原子操作本质：</p>
<p>load(x)</p>
<p>设置处理器局部（寄存器）状态</p>
<p>store(x)</p>
</li>
<li><p>多处理器自旋锁：</p>
<ol>
<li><p>线程获得锁后发生中断，此时锁没被释放，其他线程无法获得锁</p>
<p>获得自旋锁的线程不应该被中断，否则将导致大量其他线程浪费在自旋上</p>
<p>关闭中断后，处理器上的执行流完全确定了</p>
</li>
</ol>
</li>
<li><p>中断的原子性/顺序</p>
<ul>
<li>关闭中断后，操作系统上的程序<ul>
<li>独占处理器执行</li>
<li>不会被打断</li>
</ul>
</li>
<li>asm volatile汇编保证编译器不会调换指令顺序</li>
</ul>
</li>
<li><p>中断可见性</p>
<ul>
<li>硬件保证中断必发生在指令边界</li>
<li>中断前的数据全部写入（缓存/内存</li>
</ul>
</li>
<li><p>关中断+自旋</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> &amp;lk)</span></span>&#123;</span><br><span class="line">cli();</span><br><span class="line"><span class="keyword">while</span>(atomic_xchg(&amp;lk-&gt;locked,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> &amp;lk)</span></span>&#123;</span><br><span class="line">atomic_xchg(&amp;lk-&gt;locked,<span class="number">0</span>);</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先关中断再自旋</p>
<p>先释放锁再开中断</p>
</li>
<li><p>在线程第一次lock时保存中断状态，关闭中断</p>
</li>
<li><p>在线程最后一次unlock时恢复保存的中断状态</p>
</li>
</ul>
<p>关中断+自旋：用来保护一段较短的临界区</p>
<ul>
<li><p>持有锁期间，线程不能被中断</p>
</li>
<li><p>其他等待锁的线程在关中断的前提下自旋</p>
<p>无法等待、必须立即执行否则不能继续的场景</p>
</li>
</ul>
</li>
<li><p>互斥锁</p>
<ul>
<li>持有锁线程<ul>
<li>允许处理器响应中断</li>
<li>允许切换到其他线程执行<ul>
<li>访问磁盘的线程不能阻碍系统其他部分执行</li>
</ul>
</li>
</ul>
</li>
<li>等待锁的线程<ul>
<li>不要占用处理器资源自旋</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(<span class="keyword">mutexlock_t</span> *lk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> acquired = <span class="number">0</span>;</span><br><span class="line">    spin_lock(&amp;lk-&gt;spinlock);</span><br><span class="line">    <span class="keyword">if</span>(lk-&gt;locked != <span class="number">0</span>)&#123;</span><br><span class="line">        enqueue(lk-&gt;wait_list,current);</span><br><span class="line">        current-&gt;status = BLOCKED;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">        acquired = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;lk-&gt;spinlock);</span><br><span class="line">    <span class="keyword">if</span>(!acquired) yield();<span class="comment">//主动切换到其他线程执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">metex_unlock</span><span class="params">(<span class="keyword">mutexlock_t</span> *lk)</span></span>&#123;</span><br><span class="line">    spin_lock(&amp;lk-&gt;spinlock);</span><br><span class="line">    <span class="keyword">if</span>(!empty(lk-&gt;wait_list))&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_t</span> * <span class="title">task</span> =</span> dequeue(lk-&gt;wait_list);</span><br><span class="line">        task-&gt;status = RUNNNABLE;<span class="comment">//唤醒之前睡眠的线程</span></span><br><span class="line">       </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;lk-&gt;spinlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>（Synchronization）两个或两个以上随时间变化的量在变化过程中保持一定的相对关系</p>
<ul>
<li>生产者消费者问题<ul>
<li>生产者（线程)生产资源（一个对象），生产时间不确定</li>
<li>消费者（线程）消费资源（取走一个对象），消费时间也不确定</li>
</ul>
</li>
</ul>
<p>条件变量</p>
<ul>
<li>同步的本质：当某个条件满足时，线程执行，否则等待</li>
</ul>
<p>用一个对象来表示条件的满足/不满足</p>
<ul>
<li>条件不满足，随时可以在这个对象上等待</li>
<li>另一线程发现条件满足，唤醒一个（或所有）正在等待的线程</li>
</ul>
<p>对于一个条件变量cv:</p>
<ul>
<li>wait(cv)<ul>
<li>进入睡眠状态，等待cv上的事件的发生</li>
</ul>
</li>
<li>signal/notify(cv)<ul>
<li>报告cv上的事件发生</li>
<li>如果有线程正在等待cv，则唤醒其中一个线程</li>
</ul>
</li>
<li>broadcast/notifyAll(cv)<ul>
<li>报告cv上的事件发生</li>
<li>唤醒全部正在等待的cv线程</li>
</ul>
</li>
</ul>
<p>和互斥锁联合使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">//任意代码</span></span><br><span class="line">wait(&amp;cv,&amp;mutex);</span><br><span class="line"><span class="comment">//任意代码</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">//signal不受互斥锁约束</span></span><br></pre></td></tr></table></figure>
<ul>
<li>wait会立即释放锁并等待</li>
<li>被signal后恢复执行，会首先试图获得mutex</li>
</ul>
<p>//错误代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == n)wait(&amp;cv,&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        count++; signal(&amp;cv);</span><br><span class="line">        mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)wait(&amp;cv,&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        count--; signal(&amp;cv);</span><br><span class="line">        mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个条件变量无法解决</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == n)wait(&amp;empty,&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        count++; signal(&amp;fill);</span><br><span class="line">        mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//if 改为while</span></span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)wait(&amp;fill,&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        count--; signal(&amp;empty);</span><br><span class="line">        mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码保证了safety wait 结束后条件一定为真</li>
<li>如果需要liveness,只需再任何可能条件为真时broadcast唤醒所有人</li>
</ul>
<p>信号量</p>
<p>信号量=互斥锁和条件变量的结合体</p>
<ul>
<li>互斥锁<ul>
<li>仅有一个手环的情况</li>
<li>P=lock V=unlock</li>
</ul>
</li>
<li>条件变量<ul>
<li>手环的数量作为等待的条件</li>
<li>P=wait V = signal</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">P(&amp;empty);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    V(&amp;fill);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(&amp;fill);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    V(&amp;empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>死锁</p>
<p>出现线程互相等待的情况</p>
<p>ABBA类型死锁</p>
<p>四个必要条件：</p>
<p>互斥：一个资源每次只能被一个进程使用</p>
<p>请求与保持：一个进程请求阻塞时，不释放已获得资源</p>
<p>不剥夺：进程已获得的资源不能强行剥夺</p>
<p>循环等待：若干线程之间形成头尾相接的循环资源等待关系</p>
<ul>
<li><p>AA-Deadlock</p>
<p>AA类型死锁容易检测，及早报告，及早修复</p>
</li>
<li><p>ABBA-Deadlock</p>
<p>任意时刻系统中的锁是有限的</p>
<p>严格按照固定顺序获得所有锁</p>
<p>T1:A-&gt;B-&gt;C ;T2:B-&gt;C是安全</p>
<ul>
<li>在任意时刻总有一个线程（获得最靠后锁的）可以继续执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>互斥锁-原子性</p>
<p>条件变量-同步</p>
<ul>
<li>忘记上锁-原子性违反</li>
<li>忘记同步-顺序违反</li>
</ul>
<p>操作系统</p>
<p>操作系统是管理多个应用程序执行的软件</p>
<ul>
<li>应用视角：一组系统调用API</li>
<li>硬件视角：就是个状态机（C程序）</li>
</ul>
<p>状态机的虚拟化</p>
<ul>
<li>操作系统模拟了其中所有进程的状态机</li>
<li>程序彷佛自己独占CPU执行，但它独占的只是CPU的一部分</li>
</ul>
<p>进程：运行的程序</p>
<ul>
<li>任意时刻、进程都可以看成是状态机的状态</li>
</ul>
<p>操作系统在中断后，可以选择将进程（状态机）调度到CPU上执行</p>
<ul>
<li><p>进程执行系统调用，会使用指令（syscall)等回到操作系统</p>
</li>
<li><p>操作系统是一个中断处理程序</p>
<ul>
<li>被动的中断：硬件</li>
<li>主动的中断：系统调用</li>
</ul>
</li>
<li><p>三类系统调用</p>
<ul>
<li><p>进程管理：</p>
<p>fork,execve,exit-状态机的创建、改变、删除</p>
</li>
<li><p>存储管理</p>
<p>mmap-对进程虚拟地址空间的一部分进行映射</p>
<p>brk-虚拟地址空间管理</p>
</li>
<li><p>文件管理</p>
<p>open、close文件访问管理</p>
<p>read、write数据管理</p>
<p>mkdir、link、unlink目录管理</p>
</li>
</ul>
</li>
</ul>
<p>创建状态机fork()</p>
<p>替换状态机execve(filename,argc,enpv)</p>
<ul>
<li>执行名为filename的程序</li>
<li>分别传入参数argv(V)和环境变量envp(e)</li>
</ul>
<p><code>env</code>查看当前环境变量</p>
<p>PATH:可执行文件搜索路径</p>
<p>PWD:当前路径</p>
<p>HOME:home目录</p>
<p>DISPLAY:图形输出</p>
<p>PS1：shell提示符</p>
<ul>
<li>export:告诉shell在创建子进程时设置环境变量</li>
</ul>
<p>终止状态机exit</p>
<ul>
<li>销毁当前状态机，并允许有一个返回值</li>
<li>子进程终止会通知父进程</li>
</ul>
<ul>
<li><p>进程的地址空间</p>
<p>进程的地址空间=内存中若干连续的段</p>
<ul>
<li><p>每一段是可访问的（读/写/执行）内存</p>
<p>可能映射到某个文件/或在进程间共享</p>
</li>
</ul>
<p>管理进程地址空间的系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">//修改映射权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>vsyscall的例子</p>
<ul>
<li>时间：内核维护秒级的时间（所有进程映射同一个页面）<ul>
<li>time(2)</li>
</ul>
</li>
<li>getcpu per-CPU映射页面</li>
</ul>
<p>让内核和进程共享数据（内核可写，进程只读）</p>
<ul>
<li>vvar:内核和进程共享的数据</li>
<li>vdso:系统调用代码实现</li>
</ul>
<p>系统调用不一定陷入内核态执行</p>
</li>
<li><p>syscall batching</p>
<p>如果系统调用很多，可以打包处理</p>
</li>
<li><p>让进程和内核共享内存</p>
<ul>
<li>有一个内核线程在spinning等待系统调用的到来</li>
<li>系统调用准备好后，只需要一个memory store,系统调用立即开始执行</li>
<li>进程spin等待系统调用完成</li>
</ul>
</li>
<li><p>mmap并不需要真的为进程分配任何页面</p>
<p>只需要让操作系统知道这么映射就够了</p>
<p>进程访问页面会发生缺页进入操作系统</p>
<ul>
<li><p>根据操作系统维护的进程地址空间信息分配页面</p>
</li>
<li><p>如果访问合法，分配一页</p>
<ul>
<li><p>匿名内存-&gt;直接返回</p>
</li>
<li><p>文件-&gt;执行read把文件数据读到内存</p>
<p>所以即便映射整个磁盘，也只有touch的页面被访问</p>
</li>
</ul>
</li>
<li><p>如果访问非法，发送信号（SIGSEGV)</p>
<p>段错误</p>
</li>
</ul>
</li>
<li><p>通过/proc/[pid]/maps查看进程的内存映射（pmap [pid])</p>
</li>
<li><p>地址空间终究是属于进程（运行的程序）的</p>
</li>
</ul>
<h3 id="链接与加载"><a href="#链接与加载" class="headerlink" title="链接与加载"></a>链接与加载</h3><ul>
<li><p>静态链接与加载</p>
<p>允许引用其他文件里定义的符号</p>
</li>
<li><p>静态ELF加载器：加载a.out执行</p>
<ul>
<li>根据ELF program header,将文件中指定的部分移动到内存</li>
<li>操作系统在execve时完成<ul>
<li>操作系统在内核态调用mmap<ul>
<li>进程还未准备好时，由内核直接执行系统调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li>每个程序都静态链接，浪费空间很大</li>
<li>最好整个系统只有一个libc的副本<ul>
<li>文件系统里只有一个副本</li>
<li>内存里只有一个副本</li>
</ul>
</li>
<li>加载纯粹的代码</li>
</ul>
</li>
<li><p>符号地址是运行时才能确定的</p>
<ul>
<li>必须在运行时解析符号地址<ul>
<li>查表（编译成call *table[foo])</li>
</ul>
</li>
</ul>
</li>
<li><p>进程创建</p>
</li>
</ul>
<p>1） 为新进程分配一个进程标示号，并申请一个空白的PCB。</p>
<p>2） 为进程分配资源，为新进程的程序和数据，以及用户占分配必要的空间。</p>
<p>3） 初始化PCB，主要包括初始化标识信息、初始化处理器状态信息和初始化处理器控制信息，以及设置进程的空闲及。</p>
<p>4） 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。</p>
<ul>
<li><p>操作系统终止进程的过程如下：（撤消原语）</p>
<p>1） 根据被终止进程的标示符，检索PCB，从中读出该进程的状态。</p>
<p>2） 若被终止进程处于执行状态，立即终止该进程的执行，将处理器资源分配给其他进程。</p>
<p>3） 若该进程还有子进程，则应将其所有子进程终止。</p>
<p>4） 将该进程所拥有的资源、或归还给父进程或归还给操作系统。</p>
<p>5） 将该PCB从所在队列（链表）中删除。</p>
</li>
<li><p>进程切换</p>
</li>
</ul>
<p>1） 保存处理器上下文，包括程序计数器和其他寄存器。</p>
<p>2） 更新PCB信息。</p>
<p>3） 把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列。</p>
<p>4） 选择另一个进程执行，并更新其PCB。更新内存管理的数据结构。</p>
<p>5） 恢复处理器的上下文。</p>
<ul>
<li><p>SIGKILL与SIGSTOP是两个唯一不能忽略也不能捕获的信号</p>
</li>
<li><p>SIGTSTP与SIGSTOP都是使进程暂停（都使用SIGCONT让进程重新激活）。唯一的区别是SIGSTOP不可以捕获。</p>
<ul>
<li><p>捕捉SIGTSTP后一般处理如下：用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号</p>
<p>1）处理完额外的事</p>
<p>2）恢复默认处理</p>
<p>3）发送SIGTSTP信号给自己。（使进程进入suspend状态。）</p>
<p>他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.</p>
</li>
</ul>
</li>
<li><p>SIGINT：程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</p>
</li>
<li><p>SIGBUS：非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</p>
</li>
<li><p>SIGCHLD：子进程结束时, 父进程会收到这个信号。</p>
<pre><code> 如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。
</code></pre><p> ctrl-d 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。</p>
</li>
</ul>
<p>注：在shell中，ctrl-d表示推出当前shell.</p>
<ul>
<li>重新设置一个进程优先级</li>
</ul>
<p><code>renice -20 -p [pid]</code></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2021/05/24/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><img src="/2021/05/24/%E7%BD%91%E7%BB%9C/flowers-6206279.jpg" class="">
<a id="more"></a>
<ul>
<li><p>节点</p>
<p>主机或运行在其上面的应用程序</p>
<p>路由器（网络层）交换机（链路层）等网络交换设备</p>
</li>
<li><p>边：(通讯链路)</p>
<p>接入网链路</p>
<p>主干链路</p>
</li>
<li><p>协议</p>
<p>对等层实体在通信过程中应遵守的规则集合。</p>
<p>协议定义了在两个或多个通信实体之间交换的报文<strong>格式</strong>和<strong>次序</strong>，以及在报文传输和/或接收或其他事件方面所采取的<strong>动作</strong>。</p>
</li>
<li><p>互联网</p>
</li>
</ul>
<p>​       分布式应用，以及为分布式应用提供通信服务的基础设施。</p>
<ul>
<li><p>网络结构</p>
<ul>
<li><p>网络边缘</p>
<p>主机、应用程序</p>
</li>
<li><p>网络核心</p>
<p>互联着的路由器、网络的网络</p>
</li>
<li><p>接入网、物理媒体</p>
<p>有线或者无线通信链路</p>
</li>
</ul>
</li>
<li><p>网络边缘</p>
<ul>
<li>客户端、服务器模式</li>
</ul>
<p>客户端向服务器请求、接收服务</p>
<p>问题：可扩展性差，随着请求载荷增加，性能变差。</p>
<ul>
<li>对等（peer-peer）模式</li>
</ul>
<p>面向连接的通信方式（仅端系统连接）</p>
<p>有连接</p>
<p><strong>TCP</strong></p>
<p>可靠、保序</p>
<p>流量控制</p>
<p>拥塞控制</p>
<p><strong>UDP</strong></p>
<p>无连接、不可靠、无流量、拥塞控制</p>
</li>
<li><p>网络核心</p>
<p>路由器的网状网络</p>
<p>数据怎么通过网络进行传输？</p>
<ul>
<li>电路交换</li>
</ul>
<p>端到端的资源被分配给从源端到目标端的呼叫</p>
<p>独享资源（每个呼叫一旦建立起来就能保证性能）</p>
<p>如果呼叫没有数据发送，被分配的资源会被浪费</p>
<p>通常被传统电话网络采用</p>
<p>网络资源（如带宽）被分成片</p>
<p>为呼叫分配片</p>
<p>如果某个呼叫没有数据，则其资源片处于空闲状态</p>
<p>将带宽分成片</p>
<p>频分、时分、波分</p>
<p>连接建立时间长</p>
<p>计算机通信有突发性，如果使用线路交换则浪费的片较多</p>
<p>可靠性不高</p>
<ul>
<li>分组交换</li>
</ul>
<p>以分组为单位存储转发方式</p>
<p>被传输到下一个链路之前，整个分组必须到达路由器，<strong>存储转发</strong></p>
<p>在一个速率为R bps的链路，一个长度为L bits的分组的存储转发延时：L/R s.</p>
<p>排队与延迟</p>
<p><strong>如果到达速率&gt;链路传输速率</strong>：</p>
<p>分组将会排队，等待传输</p>
<p>如果路由器缓存用完了，分组将会被抛弃</p>
<ul>
<li><p>网络核心的关键功能</p>
<p>路由：决定分组采用的源到目标的路径</p>
<p>转发：将分组从路由器的输入链路转移到输出链路。</p>
<p>统计多路复用</p>
</li>
</ul>
<p>分组交换允许更多用户使用网络。</p>
<p>适合于对突发式数据传输</p>
<ul>
<li>资源共享</li>
<li>简单、不必建立呼叫</li>
</ul>
<p>过度使用会造成网络拥塞</p>
<p>分组交换网络按照有无网络层连接：</p>
<ul>
<li><p>数据报网络(不建立连接)</p>
<p>分组的目标地址决定下一跳</p>
<p>在不同阶段，路由可以改变</p>
</li>
<li><p>虚电路网络（有连接）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>接入网与物理媒体</p>
<p>住宅接入：modem</p>
<p>企业接入网络</p>
<p>无线接入网络</p>
<p>(无线LANs、广域无线接入)</p>
<p>物理媒体</p>
<p>物理链路：在每个传输-接收对，跨越一种物理媒体</p>
<ul>
<li><p>导引型媒体</p>
<p>信号沿着固体媒介被导引，（同轴电缆、光纤、双绞线、光缆）</p>
</li>
<li><p>非导引型媒体</p>
<p>信号自由传播，如无线电</p>
</li>
</ul>
</li>
<li><p>Internet结构和ISP</p>
<p>端系统通过接入ISPs（Internet Service Providers）接入到互联网</p>
<p>接入ISPs相应的必须是互联的</p>
</li>
<li><p>在路由器缓存区得分组队列</p>
<p>分组到达链路得速率超过了链路输出能力</p>
<p>分组等待排到队头，被输出</p>
<ul>
<li><p>节点处理延时</p>
<p>检查bit级差错</p>
<p>检查分组首部和决定将分组导向何处</p>
</li>
<li><p>排队延时</p>
<p>在输出链路上等待输出的时间</p>
<p>依赖于路由器的拥塞程度</p>
</li>
<li><p>传输延时</p>
<p>R = 链路带宽（bps)</p>
<p>L = 分组长度（bits)</p>
<p>将分组发送到链路上的时间L/R</p>
<p>存储转发延时</p>
</li>
<li><p>传播延时</p>
<p>d = 物理链路长度</p>
<p>s = 在媒体上的传播速度$(2*10^8m/s)$</p>
<p>传播延时 = d/s</p>
</li>
<li><p>流量强度</p>
<p>$I = La/R$</p>
<p>$R$=链路带宽（bps)</p>
<p>$L$=分组长度（bits)</p>
<p>$a$=分组到达队列的平均速率</p>
</li>
<li><p>分组丢失</p>
<p>链路队列缓冲区容量有限</p>
<p>当分组到达一个满的队列时，该分组会丢失</p>
<p>丢失的分组可能会被前一个节点或源端系统重传或根本不重传。</p>
</li>
<li><p>吞吐量</p>
<p>在源端和目标端之间传输的速率（数据量/单位时间）</p>
<p>瞬间吞吐量：在一个时间点的速率</p>
<p>平均吞吐量：在一个长时间内的平均值</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>协议层次及服务模型</p>
<p>将网络复杂功能分成功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务。</p>
<p>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务。</p>
<p>在实现本层协议的时候，直接利用了下层所提供的服务。</p>
<p>本层的服务：借助下层服务实现的本层协议实体之间的交互带来的新功能（上层可以利用的）+更下层所提供的服务。</p>
<ul>
<li><p>服务（Service):底层实体向上层实体提供它们之间的通信能力。服务用户（service user) 服务提供者（service provider)</p>
</li>
<li><p>原语（primitive):上层使用下层服务的形式，高层使用低层提供的服务，以及底层向高层提供服务都是通过服务访问源于来进行交互的—形式</p>
</li>
<li><p>服务访问点SAP(Services Access Point):上层使用下层提供的服务通过层间的接口—地点：</p>
<p>地址（address)：下层的一个实体支撑着上层的多个实体，SAP有标志不同上层实体的作用。 </p>
<p>传输层的SAP、端口</p>
</li>
<li><p>面向连接的服务、无连接的服务。</p>
</li>
<li><p><strong>服务与协议的区别</strong></p>
<p>服务(service)：底层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</p>
<p>协议（protocol）：对等层(peer entity)实体之间在互相通信过程中需要遵循的规则的集合，水平</p>
</li>
<li><p>服务与协议的联系</p>
<p>本层的协议实现要靠下层提供的服务来实现。</p>
<p>本层实体通过协议为上层提供更高级的服务。</p>
</li>
<li><p>数据单元（SDU,ICI,PDU)</p>
</li>
<li><p>Internet协议栈</p>
<p><strong>应用层</strong>：网络应用（应用报文与应用报文交互</p>
<p>为人类用户或其他应用进程提供网络应用服务。</p>
<p>FTP,SMTP,HTTP,DNS</p>
<p><strong>传输层</strong>：主机之间的数据传输(进程到进程传输、不可靠变为可靠</p>
<p>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠通信变成可靠地通信。</p>
<p>TCP,UDP</p>
<p><strong>网络层</strong>：为数据报从源到目的选择路由（传输以分组为单位端到端的数据 E2E</p>
<p>主机主机之间的通信、端到端通信，不可靠</p>
<p>IP、路由协议</p>
<p><strong>链路层</strong>：相邻网络节点之间的数据传输（在相邻两点之间传输以帧为单位的数据 P2P</p>
<p>2个相邻2点的通信，点到点的通信，可靠或不可靠。</p>
<p>点对对协议PPP,802.11(Wifi),Ethernet</p>
<p><strong>物理层</strong>：在线路上传送bit,（把输入数据转成物理信号</p>
</li>
<li><p>ISO/OSI参考模型：</p>
<p>表示层：允许应用解释传输的数据 e.g.加密、压缩、机器相关的表示转换</p>
<p>会话层：数据交换的同步、检查点、恢复(建立会话、维持会话)</p>
</li>
<li><p>各层次的协议数据单元</p>
<p>应用层：报文（message)</p>
<p>传输层：报文段（segment); TCP段，UDP数据报</p>
<p>网络层：分组packet(如果无连接方式：数据报（datagram))</p>
<p>数据链路层：帧（frame）</p>
<p>物理层：位（bit)</p>
</li>
</ul>
</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h4><p><strong>可能的应用架构</strong></p>
<p>  客户-服务器模式（C/S:Client/Serve)</p>
<ul>
<li><p>服务器</p>
<p>一直运行</p>
<p>固定的IP地址和周知的端口号（约定）</p>
<p>扩展性：服务器场（数据中心进行扩展，扩展性差，可靠性差）</p>
</li>
<li><p>客户端</p>
<p>主动与服务器通信</p>
<p>与互联网有间歇性的连接</p>
<p>可能是动态IP地址</p>
<p>不直接与其他客户端通信</p>
<p>对等模式（P2P:Peer to Peer)</p>
</li>
<li><p>几乎没有一直运行的服务器</p>
</li>
<li>任意端系统之间可以通信</li>
<li>每一个节点既是客户端又是服务器</li>
<li><p>参与的主机间歇性连接且可以改变IP地址</p>
<p>(难以管理)</p>
<p>混合体：客户-服务器和对等体系结构</p>
</li>
</ul>
<p><strong>进程通信</strong></p>
<p>  客户端进程：发起通信的进程</p>
<p>  服务器进程：等待连接的进程</p>
<p>不同主机，通过交换报文（Message)来通信</p>
<p>使用OS提供的通信服务</p>
<p>按照应用协议交换报文（借助传输层提供的服务）</p>
<p>（P2P架构之间也有客户端服务器进程之分）</p>
<p>问题：</p>
<p>进程表示与寻址问题（服务用户）</p>
<p>传输层-应用层提供服务是如何（服务）</p>
<ul>
<li>位置：层间界面的SAP(TCP/IP: socket)</li>
<li>形式：应用程序接口API(TCP/IP: socket API)</li>
</ul>
<p>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）</p>
<p>定义应用层协议：报文格式、解释、时序等</p>
<p>编制程序，使用OS提供的API,调用网络基础设施提供的通信服务传报文，实现应用时序。</p>
<h4 id="对进程进行编址"><a href="#对进程进行编址" class="headerlink" title="对进程进行编址"></a>对进程进行编址</h4><p>进程为了接受报文，必须有一个唯一标识。</p>
<p>即:SAP</p>
<ul>
<li><p>主机：唯一的32位IP地址</p>
</li>
<li><p>所采用的传输层协议TCP or UDP</p>
</li>
<li><p>端口号（Port Number)$(2^{16})$</p>
<p>web应用HTTP tcp 80，ftp tcp 2, Mail: tcp 25</p>
</li>
<li><p>一个进程：用IP+port标识，端节点</p>
</li>
</ul>
<h4 id="传输层提供服务-需要穿过层间的信息"><a href="#传输层提供服务-需要穿过层间的信息" class="headerlink" title="传输层提供服务-需要穿过层间的信息"></a>传输层提供服务-需要穿过层间的信息</h4><ul>
<li>要传输的报文（SDU)</li>
<li>谁传的：自己应用进程标识</li>
<li>传给谁：对方应用进程标识（IP+TCP(UDP)端口号</li>
</ul>
<p>传输层实体（tcp或udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装</p>
<ul>
<li>源端口号、目标端口号、数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报，源IP,目标IP.</li>
</ul>
<p>如果Socket API每次传输报文都携带如此多的信息，太繁琐易错，不便于管理。</p>
<p>用个代号标示通信的双方或者单方：socket</p>
<p>就像OS打开文件返回的句柄</p>
<ul>
<li><p>TCP socket:</p>
<ul>
<li>TCP服务。两个进程之间的通信要先建立连接</li>
<li>可以用一个整数表示两个应用实体之间的通信关系，本地标识。</li>
<li>穿过层间接口的信息量最小</li>
<li>TCP socket :源IP，源端口，目标IP,目标端口</li>
</ul>
<p>对于面向连接服务TCP的应用而言，套接字是4元组的一个具有本地意义的标示。</p>
<ul>
<li>4元组（:源IP，源port，目标IP,目标port</li>
<li>唯一指定了一个会话（2个进程之间的会话关系</li>
<li>应用这个标识，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都指定这四元组</li>
<li>简单、便于管理。</li>
</ul>
</li>
<li><p>UDP socket</p>
<ul>
<li>UDP服务，两个进程之间通信无需建立连接</li>
<li>每个报文都是独立传输</li>
<li>前后报文可能给不同的分布式进程</li>
<li>只能用一个整数标识本应用实体的标识</li>
<li>穿过层间接口的信息大小最小</li>
<li>UPD socket:本IP,本端口</li>
<li>传输报文时，必须提供对方IP、port</li>
</ul>
<p>对于UDP,套接字是2元组的一个具有本地意义的标识。</p>
<p>2元组：IP、port</p>
<p>UDP套接字制定了应用所在的一个端节点（end point)</p>
</li>
</ul>
<p><strong>套接字</strong>（socket)</p>
<p>进程向套接字发送报文或从套接字接受报文</p>
<p>套接字&lt;-&gt;门户</p>
<p>发送进程将报文推出门户，发送进程依赖于传输层设施在另一侧的门将报文交付给接受进程</p>
<p>接收进程从另外一端的门户收到报文（依赖于传输层设施）</p>
<h4 id="如何使用传输层提供的服务实现应用"><a href="#如何使用传输层提供的服务实现应用" class="headerlink" title="如何使用传输层提供的服务实现应用"></a>如何使用传输层提供的服务实现应用</h4><p>定义应用层协议：报文格式、解释、时序等</p>
<p>编制程序，使用API调用网络基础设施提供的通信服务传报文，解析报文、实现应用时序等。</p>
<h5 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h5><p>定义了：运行在不同端系统上的应用<strong>进程</strong>如何相互交换报文</p>
<p>交换报文类型：请求与应答报文</p>
<p>各种报文类型语法：报文中的各个字段及其描述</p>
<p>字段的语义：即字段取值的含义</p>
<p>进程何时、如何发送报文及对报文进行响应的规则</p>
<ul>
<li><p>应用协议仅仅是应用的一个组成部分。</p>
<p>Web应用：HTTP协议，web客户端、web服务器、HTML</p>
</li>
<li><p>公开协议</p>
<p>由RFC文档定义</p>
<p>允许互操作</p>
<p>如HTTP,SMTP</p>
</li>
<li><p>专用协议</p>
<p>协议不公开 Skype</p>
</li>
</ul>
<p>性能要求：</p>
<ul>
<li>数据丢失率</li>
<li>延迟</li>
<li>吞吐</li>
<li>安全性（机密性、完整性、可认证性</li>
</ul>
<p>Internet传输层提供的服务</p>
<p><strong>TCP服务</strong></p>
<ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接受方</li>
<li>拥塞控制：当网络出现拥塞，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全</li>
<li>面向连接：要求在客户端进程与服务器进程之间建立连接</li>
</ul>
<p><strong>UDP服务</strong></p>
<ul>
<li>不可靠数据传输</li>
<li>不提供服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接</li>
</ul>
<p>UDP存在的必要性</p>
<ul>
<li><p>能够区分不同的进程，而IP服务不能</p>
<ul>
<li>在IP提供的主机到主机端到端功能基础上，区分了主机的应用进程。</li>
</ul>
</li>
<li><p>无需建立连接、省去了建立连接时间、适合事务性应用</p>
</li>
<li><p>不做可靠性工作，如检错重发，适合于实时性要求高正确性要求低的应用</p>
</li>
<li><p>没用拥塞流量控制、应用能够按照设定的速度发送数据</p>
<ul>
<li>在TCP上的应用，应用发送数据的速度和主机向网络发送的实际速度不一样，因为由流量、拥塞控制。</li>
</ul>
</li>
</ul>
<p>安全TCP</p>
<p>TCP&amp;UDP</p>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输</li>
</ul>
<p>SSL</p>
<ul>
<li><p>在TCP上面实现，提供加密的TCP连接</p>
</li>
<li><p>私密性</p>
</li>
<li><p>数据完整性</p>
</li>
<li><p>端到端的鉴别</p>
</li>
<li><p>SSL在应用层，应用采用SSL库，SSL库采用TCP通信</p>
</li>
<li><p>应用通过API将明文给socket,SSL将其加密在互联网上传播</p>
</li>
</ul>
<h4 id="Web与HTTP"><a href="#Web与HTTP" class="headerlink" title="Web与HTTP"></a>Web与HTTP</h4><p>Web页：由一些对象组成</p>
<p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p>
<p>Web页含有一个基本的HTML文件、该基本HTML文件又包含若干对象的引用（链接）</p>
<p>通过URL对每个对象进行引用</p>
<ul>
<li>访问协议、用户名、口令字、端口等</li>
</ul>
<p>URL格式：</p>
<p>Prot://user:psw@www.someSchool.edu/someDept/pic.gif:port</p>
<p>协议名 用户名:口令 主机名[:port]                             路径名     端口</p>
<p>HTTP概况</p>
<p>HTTP:超文本传输协议</p>
<ul>
<li><p>Web的应用层协议</p>
</li>
<li><p>客户/服务器模式</p>
<ul>
<li>客户：请求、接收和显示Web对象的浏览器</li>
<li>服务器：对请求进行响应，发送对象的Web服务器</li>
</ul>
<p>HTTP request HTTP response</p>
</li>
<li><p>使用TCP</p>
<ul>
<li>客户发起一个与服务器的TCP链接（建立套接字）端口号为80</li>
<li>服务器接受客户的TCP链接</li>
<li>在浏览器（HTTP客户端）与Web服务器（HTTP服务器server)交换HTTP报文（应用层协议报文）</li>
<li>TCP连接关闭</li>
</ul>
</li>
<li><p>HTTP是无状态的</p>
<p>服务器不维护关于客户的任何信息</p>
<p>维护状态的协议很复杂，必须维护历史信息</p>
<p>如果服务器、客户端死机，他们的状态信息不一致</p>
<p>无状态的服务器能支持更多的客户端</p>
</li>
<li><p>HTTP链接</p>
<ul>
<li><p>非持久HTTP</p>
<p>最多只有一个对象在TCP连接上发送</p>
<p>下载多个对象需要多个TCP链接</p>
<p>HTTP/1.0使用非持久连接</p>
</li>
<li><p>持久HTTP</p>
<p>多个对象可以在一个TCP连接上传输</p>
<p>HTTP/1.1默认采用持久连接</p>
</li>
</ul>
</li>
<li><p>响应时间模型：</p>
<p>往返时间RTT(round-trip time):一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）</p>
<p><strong>响应时间</strong>：</p>
<p>一个RTT用来发起TCP连接</p>
<p>一个RTT用来HTTP请求并等待HTTP响应</p>
<p>文件传输时间：</p>
<p>2*RTT+传输时间</p>
</li>
<li><p>非持久HTTP缺点：</p>
<ul>
<li>每个对象要2个RTT</li>
<li>操作系统必须为每个TCP连接分配资源</li>
<li>但浏览器通常打开并行TCP连接、以获取引用对象</li>
</ul>
</li>
<li><p>持久HTTP</p>
<ul>
<li>服务器在发送响应后仍保持TCP链接</li>
<li>在相同客户端服务器之间的后续请求和响应报文通过相同的链接进行传送。</li>
<li>客户端在遇到一个引用对象的时候，可以尽快发送该对象的请求</li>
<li>非流水方式的持久HTTP:<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
</li>
<li>流水方式的持久HTTP<ul>
<li>HTTP/1.1默认模式</li>
<li>客户端遇到一个引用对象就立即发送一个请求</li>
<li>所有引用对象只花费一个RTT是可能的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><ul>
<li><p>两种类型的HTTP报文：请求、响应</p>
</li>
<li><p>HTTP请求报文</p>
<ul>
<li><p>ASCII</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1 /*请求行（GET、POST（上载）、HEAD（头）命令*/</span><br><span class="line">/*首部行*/</span><br><span class="line">Host: www.someschool.edu 主机名</span><br><span class="line">User-agent:Mozilla/4.0 用户代理程序、浏览器版本</span><br><span class="line">Connection:close 关连接</span><br><span class="line">Accept-language:fr</span><br><span class="line"></span><br><span class="line">（一个额外的换行回车符，标识报文结束</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>提交表单输入</strong></p>
<ul>
<li><p>Post方式</p>
<ul>
<li>网页通常包括表单输入</li>
<li>包含在实体主体（entity body)中输入被提交到服务器</li>
</ul>
</li>
<li><p>URL方式</p>
<ul>
<li><p>方法：GET</p>
</li>
<li><p>输入通过请求行的URL字段上载</p>
<p>www.somesite.com/animalsearch?monkeys&amp;banana</p>
<p><a href="http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3</a></p>
<p>参数：wd.cl</p>
<p>参数值XX+YY+zzz, 3</p>
</li>
</ul>
</li>
</ul>
<p>HTTP/1.1</p>
<ul>
<li>PUT 将实体主体中的文件载到URL字段规定的路径</li>
<li>DELETE删除URL字段规定的文件</li>
</ul>
<img src="/2021/05/24/%E7%BD%91%E7%BB%9C/img1.png" class="">
<p>HTTP响应状态码：</p>
<p>200 OK</p>
<p>301 Moved Permanently</p>
<p>400 Bad Request</p>
<p>404 Not Found</p>
<p>505 HTTP Version Not Supported</p>
<h5 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a>用户-服务器状态：cookies</h5><p>4个组成部分：</p>
<p>1）在HTTP响应报文中有一个cookie的首部行</p>
<p>2）在HTTP请求报文中含有一个cookie首部行</p>
<p>3）在用户端系统中保留有一个cookie文件，由用户的浏览器管理</p>
<p>4）在Web站点有一个后端数据库</p>
<ul>
<li>Cookies能<ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态（Web e-mail)</li>
</ul>
</li>
<li>如何维持状态<ul>
<li>协议端节点：在多个事务上，发送端和接收端维持状态</li>
<li>cookies: http报文携带状态信息</li>
</ul>
</li>
</ul>
<h5 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h5><p>目标：不访问原始服务器，就满足客户请求</p>
<p>用户设置浏览器：通过缓存访问Web</p>
<p>浏览器将所有HTTP请求发给缓存</p>
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>不在缓存中，缓存请求原始服务器</li>
</ul>
<p>缓存既是客户端又是服务器</p>
<p>通常缓存是由ISP安装</p>
<p>为什么要使用缓存？</p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li>
<li>互联网大量采用了缓存，可以是较弱的ICP也能有效提供内容。</li>
</ul>
<p>条件GET方法</p>
<ul>
<li><p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</p>
</li>
<li><p>缓存器：在HTTP请求中指定缓存拷贝的日期</p>
<p>If-modified-since <date></p>
</li>
<li><p>服务器：如果缓存拷贝陈旧，则响应报文没包含对象：</p>
<p>HTTP/1.0 304 Not Modified</p>
</li>
</ul>
<h4 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h4><ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户/服务器模式<ul>
<li>客户端：发起传输的一端</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>ftp:RFC 959</li>
<li>ftp服务器：端口号21</li>
</ul>
<p>FTP客户端与FTP服务器通过端口21联系、并使用TCP作为传输协议</p>
<p>客户端通过控制连接获得身份确认</p>
<p>客户端通过控制连接发送命令浏览远程目录</p>
<p>收到一个文件传输命令，服务器打开一个客户端的数据连接（客户端20号端口）</p>
<p>一个文件传输完成，服务器关闭连接</p>
<p>服务器打开第二个TCP数据连接用来传输另一个文件</p>
<p>控制连接：带外（out of band) 传送 （带内传数据</p>
<p>FTP服务器维护用户的状态信息、当前路径、用户账户与控制连接对应</p>
<ul>
<li><p>与HTTP区别：</p>
<p>有状态，控制、数据在两个TCP连接上进行</p>
</li>
</ul>
<h4 id="EMail"><a href="#EMail" class="headerlink" title="EMail"></a>EMail</h4><p>三个主要组成部分：</p>
<ul>
<li><p>用户代理</p>
<p>邮件软件（Outlook,Foxmail</p>
</li>
<li><p>邮件服务器</p>
<p><strong>邮箱</strong>中管理和维护发送给用户的邮件</p>
<p>输出<strong>报文队列</strong>保持待发送邮件报文</p>
<p>邮件服务器之间的<strong>SMTP</strong>协议：发送email报文</p>
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接受端邮件服务器</li>
</ul>
</li>
<li><p>简单邮件传输协议SMTP(发送), 拉取：POP3,IMAP,HTTP</p>
</li>
</ul>
<p>使用TCP在客户端与服务器之间传输报文，端口号为25</p>
<p>直接传输：从发送方服务器到接收方服务器</p>
<p>传输的3个阶段</p>
<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
<p>命令/响应交互</p>
<ul>
<li>命令:ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
<p>报文必须为7位ASCII码。</p>
<ul>
<li>SMTP使用持久连接</li>
<li>SMTP要求报文（首部和主体）为7位ASCII编码</li>
<li>SMTP服务器使用CRLF,CRLF决定报文的尾部</li>
</ul>
<p><strong>HTTP比较</strong></p>
<ul>
<li>HTTP:拉（pull)</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令/响应交互、状态码</li>
<li>HTTP:每个对象封装在各自的响应报文中</li>
<li>SMTP:多个对象包含在一个报文中</li>
</ul>
<h5 id="MIME多媒体邮件扩展"><a href="#MIME多媒体邮件扩展" class="headerlink" title="MIME多媒体邮件扩展"></a>MIME多媒体邮件扩展</h5><p>在报文首部用额外的行申明MIME内容类型</p>
<p>base64：把不在ASCII码范围内的字符转位ASCII字符</p>
<h5 id="Pop3协议"><a href="#Pop3协议" class="headerlink" title="Pop3协议"></a>Pop3协议</h5><p>用户确认阶段</p>
<ul>
<li><p>客户端命令</p>
<p>user:声明用户名</p>
<p>pass:口令</p>
</li>
<li><p>服务器响应</p>
</li>
</ul>
<p>事务处理阶段（客户端</p>
<p>list:报文号列表</p>
<p>retr:根据报文号检索报文</p>
<p>dele:删除</p>
<p>quit</p>
<ul>
<li>Pop3本地管理文件夹，无状态</li>
<li>IMAP远程管理文件夹，保留用户状态</li>
</ul>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>域名到IP转换</p>
<p><strong>DNS的必要性</strong></p>
<ul>
<li>IP地址标识主机、路由器</li>
<li>IP地址不好记忆、不便于使用</li>
<li>倾向于字符串标识Internet上的设备</li>
<li>存在字符串-IP地址转换的必要性</li>
<li>人类用户提供要访问机器的字符串名称</li>
<li>由DNS负责转换为二进制网络地址</li>
</ul>
<p>问题：</p>
<ul>
<li>如何命名设备</li>
<li>如何完成名字到IP地址转换</li>
<li>如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ul>
<h5 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h5><ul>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址转换</li>
<li>运行在UDP之上端口号为53的应用服务</li>
<li>核心Internet功能、但以应用层协议实现</li>
</ul>
<h5 id="DNS主要目的"><a href="#DNS主要目的" class="headerlink" title="DNS主要目的"></a>DNS主要目的</h5><p>实现主机名-IP地址转换</p>
<p>其他目的：</p>
<p>主机别名到规范名字转换</p>
<p>邮件服务器别名到邮件服务器正规名字的转换</p>
<p>负载均衡</p>
<h5 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h5><ul>
<li><p>一个层面命名设备会有很多重名</p>
</li>
<li><p>NDS采用层次树状结构命名法</p>
</li>
<li><p>Internet根被划为几百个顶级域名</p>
<ul>
<li><p>通用</p>
<p>.com .edu .gov .int .mil .net .org .firm .hsop .wed .arts .rec</p>
</li>
<li><p>国家</p>
<p>.cn .us .nl .jp</p>
</li>
</ul>
</li>
<li><p>每个（子）域下面可划分为若干个子域</p>
</li>
<li><p>树叶是主机</p>
</li>
</ul>
<p>DNS:根名字服务器</p>
<ul>
<li><p>域名</p>
<p>从本域往上，直到树根</p>
<p>中间使用.间隔不同的级别</p>
<ul>
<li>域的域名：可以用来表示一个域</li>
<li>主机的域名：一个域上的一个主机</li>
</ul>
</li>
<li><p>域名的管理：</p>
<ul>
<li>一个域管理其下的子域</li>
<li>创建一个新的域，须征得它所属域的同意。</li>
</ul>
</li>
<li><p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
</li>
</ul>
<h5 id="解析问题"><a href="#解析问题" class="headerlink" title="解析问题"></a>解析问题</h5><ul>
<li><p>一个名字服务器的问题</p>
<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离集中式数据库</li>
</ul>
</li>
<li><p>区域（Zone)</p>
<ul>
<li>区域的划分由区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分。</li>
<li>名字服务器<ul>
<li>每个区域都有一个名字服务器，维护着它所管辖区域的权威信息</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
<li>权威DNS服务器：组织机构的DNS服务器，提供组织机构服务器（如Web和mail)可访问的主机与IP之间的映射。</li>
<li>组织机构可以选择实现自己维护或由某个服务器提供商来维护</li>
</ul>
</li>
<li><p>TLD服务器</p>
<ul>
<li>顶级域（TLD)服务器：负责顶级域名（如com,org,net,edu,gov)和所有国家级的顶级域名（如cn,uk,fr,ca,jp)</li>
</ul>
</li>
<li><p>区域名字服务器维护资源记录</p>
<ul>
<li>资源记录（resource records)<ul>
<li>作用：维护域名-IP地址（其他）的映射关系</li>
<li>位置：Name Server的分布式服务器中</li>
</ul>
</li>
<li>RR格式：（domain_name,ttl,type,class,Value)<ul>
<li>Domain_name 域名</li>
<li>Ttl: time to live:生存时间(权威记录：ttl时间很长，时间较短则为缓冲记录)</li>
<li>Class类别（internet 为IN)</li>
<li>Value值(IP地址)</li>
<li>Type类别</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS记录</p>
<p>DNS保存资源记录（RR)的分布式数据库</p>
<ul>
<li>Type = A<ul>
<li>Name为主机</li>
<li>Value为IP地址</li>
</ul>
</li>
<li>Type=NS<ul>
<li>Name为域名</li>
<li>Value为该域名的权威服务器域名</li>
</ul>
</li>
<li>Type = CNAME<ul>
<li>Name为规范名字的别名</li>
<li>value为规范名字</li>
</ul>
</li>
<li>Type = MX<ul>
<li>Value为name对应的邮件服务器名字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="DNS工作过程"><a href="#DNS工作过程" class="headerlink" title="DNS工作过程"></a>DNS工作过程</h5><ul>
<li>应用调用解析器（resolver)</li>
<li>解析器作为客户向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文（Name/ip)</li>
</ul>
<p>本地名字服务器（Local Name Server)</p>
<ul>
<li><p>并不严格属于层次结构</p>
</li>
<li><p>每个ISP都有一个本地DNS服务器</p>
</li>
<li><p>当一个主机发起一个DNS查询时，查询被送到本地DNS服务器</p>
<ul>
<li>起着代理的作用、将查询转发到层次结构中</li>
</ul>
</li>
<li><p>名字解析过程：</p>
<ul>
<li>目标名字在Local Name Server中<ul>
<li>case 1：查询的名字在该区域内部</li>
<li>case 2: 缓存（cashing)</li>
</ul>
</li>
</ul>
<p>当与本地名字服务器不能解析的名字时、联系根名字服务器，顺着根-TLD一直找到权威名字服务器</p>
<ul>
<li>递归查询<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器负担太重</li>
<li>解决：迭代查询</li>
</ul>
</li>
<li>迭代查询<ul>
<li>根（及各级域名）服务器返回的不是查询结果，而是下一个NS地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务器给出可以联系的服务器名字</li>
<li>我不知道这个名字，但可以向这个服务器请求</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS协议、报文</p>
<p>DNS协议：查询与响应报文报文格式相同</p>
<p>报文首部：</p>
<ul>
<li>标识符（ID)：16位</li>
<li>flags:</li>
</ul>
</li>
</ul>
<h5 id="提高性能-缓存"><a href="#提高性能-缓存" class="headerlink" title="提高性能 缓存"></a>提高性能 缓存</h5><ul>
<li>一旦名字服务器学到了一个映射，就将映射缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着<ul>
<li>使得根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>存在问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案TTL(默认2天)</li>
</ul>
<h5 id="维护问题-新增一个域"><a href="#维护问题-新增一个域" class="headerlink" title="维护问题 新增一个域"></a>维护问题 新增一个域</h5><ul>
<li>在上级名字服务器中增加两条记录，指向这个新增的子域域名和域名服务器地址</li>
<li>在新增子域名字服务器上运行名字服务器，负责本域的名字解析：名字-&gt;IP地址</li>
</ul>
<p>例子：在com域中建立一个 Netwirk Utopia</p>
<ul>
<li>到注册登记机构注册域名networkutopia.com<ul>
<li>需要向该机构提供权威DNS服务器（基本的、辅助的）名字和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录<ul>
<li>(networkutopia.com,dnsl.networkutopia.com,NS)</li>
<li>(dnsl.networkutopia.com,212.212.212.1, A)</li>
</ul>
</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有<ul>
<li>用于Web服务器的www.networkuptopia.com的类型为A的记录</li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
<h5 id="攻击DNS"><a href="#攻击DNS" class="headerlink" title="攻击DNS"></a>攻击DNS</h5><p>DDoS攻击</p>
<ul>
<li>对根服务器进行流量轰炸攻击：发送大量Ping<ul>
<li>没有成功</li>
<li>根目录服务器配置了流量过滤器，防火墙</li>
<li>Local DNS服务器缓存了TLD服务器的IP地址，因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击：发送大量查询<ul>
<li>可能更危险</li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<p>重定向攻击</p>
<ul>
<li>中间人攻击<ul>
<li>截获查询、伪造回答、从而攻击某个（DNS回答指定ip）站点</li>
</ul>
</li>
<li>DNS中毒<ul>
<li>发送伪造的应答给DNS服务器，希望他缓存这个虚假结果</li>
</ul>
</li>
<li>技术上较困难：分布式截获与伪造</li>
</ul>
<p>利用DNS基础设施进行DDoS</p>
<ul>
<li>伪造某个IP进行查询、攻击这个目标ip</li>
<li>查询放大，响应报文币查询报文大</li>
<li>效果有限</li>
</ul>
<h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p>纯P2P架构</p>
<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>peer节点间歇上网，每次IP地址都可能变化</li>
</ul>
<p>例子：</p>
<ul>
<li>文件分发</li>
<li>流媒体</li>
<li>VoIP</li>
</ul>
<p>文件分发时间：C/S模式</p>
<ul>
<li><p>服务器传输:都是由服务器发给peer，服务器必须顺序传输（上载）N个文件的拷贝</p>
<ul>
<li>发送一个copy $F/u_{s}$</li>
<li>发送N个copy $NF/u_{s}$</li>
</ul>
</li>
<li><p>客户端：每个客户端必须下载一个文件拷贝</p>
<ul>
<li>$d_{min}$ = 客户端最小的下载速率</li>
<li>下载带宽最小的客户端下载时间：$F/d_{min}$</li>
</ul>
</li>
<li><p>采用C/S方法将一个F大小的文件分发给N个客户端耗时</p>
<p>$D<em>{c/s}\geq max{NF/u</em>{s},F/d_{min}}$</p>
</li>
</ul>
<p>文件分发时间：P2P模式</p>
<ul>
<li>服务器传输：最少需要上载一份拷贝</li>
</ul>
<p>发送一个拷贝时间：$F/u_{s}$</p>
<ul>
<li>客户端：每个客户端必须下载一个拷贝</li>
</ul>
<p>最小下载带宽客户耗时：$F/d_{min}$</p>
<p>客户端：所有客户端总体下载量NF</p>
<ul>
<li>最大上载带宽$u<em>{s} + \Sigma u</em>{i}$</li>
<li>除了服务器可以上载，其他所有peer节点也可以上载</li>
</ul>
<p>采用P2P方法将一个F大小的文件分发给N个客户端耗时</p>
<p>$D<em>{p2p} \geq max{F/u</em>{s},F/d<em>{min},NF/(u</em>{s} + \Sigma u_{i}}$</p>
<p>分子随着N线性变化，每个节点需要下载，整体下载量随着N增大</p>
<ul>
<li><p>非结构化P2P</p>
<p>集中化目录</p>
<p>完全分布式</p>
<p>混合体</p>
</li>
<li><p>DHT(结构化)P2P</p>
</li>
</ul>
<ul>
<li><p>两大问题</p>
<ul>
<li>如何定位所需资源</li>
<li>如何处理对等方的加入与离开</li>
</ul>
</li>
<li><p>可能的方案</p>
<ul>
<li><p>集中</p>
</li>
<li><p>分散</p>
</li>
<li><p>半分散</p>
</li>
</ul>
</li>
</ul>
<h5 id="集中式目录"><a href="#集中式目录" class="headerlink" title="集中式目录"></a>集中式目录</h5><ul>
<li><p>当对等方连接时，它告知中心服务器：</p>
<ul>
<li>IP地址</li>
<li>内容</li>
</ul>
</li>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<h5 id="查询洪泛：Gnutella"><a href="#查询洪泛：Gnutella" class="headerlink" title="查询洪泛：Gnutella"></a>查询洪泛：Gnutella</h5><ul>
<li>全分布式<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多Gnutella客户端实现了Gnutella协议<ul>
<li>类似HTTP有许多的浏览器</li>
</ul>
</li>
<li>覆盖网络：图<ul>
<li>如果X与Y之间有一个TCP连接，则二者之间存在一条边</li>
<li>所有活动对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于10个</li>
</ul>
</li>
<li>Gnutella协议：<ul>
<li>在已有的TCP连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
</li>
<li><p>可扩展性：限制范围的洪泛查询</p>
</li>
<li><p>Gnutella:对等方加入</p>
<ul>
<li><p>对等方X必须首先发现某些已经在覆盖网络中的其他对等方，使用可用对等方列表。</p>
<p>自己维持一张对等方列表（经常开机的对等方IP)</p>
<p>联系维持列表的Gnutella站点</p>
</li>
<li><p>X接着试图与列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</p>
</li>
<li><p>X向Y发送一个Ping报文，Y转发该Ping报文</p>
</li>
<li><p>所有收到ping报文的对等方以pong报文响应</p>
<p>IP地址、共享文件数量、总字节数</p>
</li>
<li><p>X收到许多pong报文，然后它能建立其他TCP连接</p>
</li>
</ul>
</li>
</ul>
<h5 id="利用不匀称性：KaZaA"><a href="#利用不匀称性：KaZaA" class="headerlink" title="利用不匀称性：KaZaA"></a>利用不匀称性：KaZaA</h5><ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长。<ul>
<li>对等方与其组长之间有TCP连接</li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有孩子的内容</li>
<li>组长与其他组长联系<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
</li>
<li>查询<ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应：<ul>
<li>对每个匹配：元数据、散列标识码、IP地址</li>
</ul>
</li>
<li>如果组长将查询转发给其他组长、其他组长也以匹配进行响应。</li>
<li>客户端选择要下载的文件<ul>
<li>向拥有文件的对等体发送一个带散列标识码的HTTP请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>通过CDN，全网部署缓存节点，存储服务内容就近为用户提供服务，提高用户体验。</p>
<ul>
<li><p>enter deep :将CDN服务器深入到许多接入网</p>
<p>在Local ISP内部署，离用户近</p>
</li>
<li><p>bring home:部署在少数关键位置，如将服务器簇安装于POP附近</p>
</li>
<li><p>CDN：在CDN节点中存储内容的多个拷贝</p>
</li>
<li><p>用户从CDN中请求内容</p>
<ul>
<li>重定向到最近的拷贝，请求内容</li>
</ul>
</li>
<li><p>域名解析重定向</p>
</li>
</ul>
<h4 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h4><p>应用进程使用传输层提供的服务才能交换报文，实现应用协议，实现应用</p>
<p>TCP/IP：应用进程使用Socket API访问传输服务</p>
<p>地点：界面上的SAP，方式：Socket API</p>
<p><strong>Socket</strong> 分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
<p>TCP:可靠的、字节流服务</p>
<p>UDP:不可靠、数据UDP数据报服务</p>
<p>TCP套接字编程：</p>
<p>==套接字==:应用进程与端到端传输协议（TCP,UDP）之间的门户</p>
<p>TCP服务：从一个进程向另一个进程可靠地传输字节流</p>
<h5 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h5><ul>
<li>服务器首先运行，等待连接建立<ul>
<li>创建欢迎socket</li>
<li>和本地端口捆绑</li>
<li>在欢迎socket上阻塞式等待接受用户的连接(调用accept</li>
</ul>
</li>
<li>客户端主动和服务器建立连接<ul>
<li>指定服务器进程IP地址与端口号，与服务器进程连接（调用connect</li>
</ul>
</li>
<li>当客户端连接请求到来时<ul>
<li>服务器接受来自客户端的请求，解除阻塞式等待，返回一个新的socket(与欢迎socket不一样)，与客户端通信<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口区分不同的客户端</li>
</ul>
</li>
</ul>
</li>
<li>连接API调用有效时，客户端P与服务器建立了TCP连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IP地址与port捆绑关系数据结构（标识进程的端节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> sim_family; <span class="comment">// AF_INET地址族</span></span><br><span class="line">  u_short sin_port; <span class="comment">//port</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//IP address unsigned long</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//align对齐</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//完成域名到IP地址解析</span></span><br><span class="line"><span class="comment">//域名与IP地址的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;<span class="comment">//主机域名</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;<span class="comment">//主机别名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;</span><br><span class="line">    <span class="keyword">int</span> h_length;<span class="comment">//地址长度</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list;<span class="comment">//IP地址列表</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作为调用域名解析函数时的参数</span></span><br><span class="line"><span class="comment">//返回后，将IP地址拷贝到sockaddr_in的IP地址部分</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span><span class="comment">/*structure to hold an IP address of server*/</span></span><br><span class="line">    <span class="keyword">int</span> clientSocket;<span class="comment">/*socket descriptor*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span><span class="comment">/*pointer to a host table entry*/</span></span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    host = argv[<span class="number">1</span>];<span class="comment">/*服务器端域名*/</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);<span class="comment">/*服务器端端口号*/</span></span><br><span class="line">    clientSocket = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));<span class="comment">/*clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET;<span class="comment">/*set family to Internet*/</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">//解决大端小端问题</span></span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line">    <span class="comment">/*Convert host name to IP address*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr,ptrh-&gt;h_addr,ptrh-&gt;h_length);</span><br><span class="line">    <span class="comment">//将IP地址拷贝到sad.sin_addr</span></span><br><span class="line">    connect(clientSocket,(struct sockaddr *)&amp;sad,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    gets(Sentence);<span class="comment">/*get input stream from usr*/</span></span><br><span class="line">    n = write(clientSocket, Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>);</span><br><span class="line">    n = read(clientSocket, modifiedSentence,<span class="keyword">sizeof</span>(modifiedSentence));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER %s\n&quot;</span>,modifiedSentence);</span><br><span class="line">    <span class="comment">/*close socket*/</span></span><br><span class="line">    close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*server.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span><span class="comment">/*client*/</span></span><br><span class="line">    <span class="keyword">int</span> welcomeSocket, connectionSocket;<span class="comment">/*socket descriptor*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span><span class="comment">/*pointer to a host table entry*/</span></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    welcomeSocket = socket(PF_INTE,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY;<span class="comment">/*set the local IP address*/</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">/*set the port number*/</span></span><br><span class="line">    bind(welcomeSocket, (struct sockaddr*)&amp;sad,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="comment">/*specify the maximum number of clients that can be queued*/</span></span><br><span class="line">    listen(welcomeSocket,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        connectionSocket = accept(welcomeSocket,(struct sockaddr *)&amp;cad,&amp;alen);</span><br><span class="line">        n = read(connectionSocket,clientSentence,<span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line">        n = write(connectionSocket,capitalizedSentence,<span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>);</span><br><span class="line">        close(connectionSocket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h5><p>UDP：在客户端与服务器之间没有连接</p>
<p>没有握手</p>
<p>发送端在每一个报文中明确指定目标的IP地址与端口号</p>
<p>服务器必须从收到的分组中提取出发送端的IP地址和端口号</p>
<p>UDP：传送数据可能乱序，也可能丢失</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210529165523606.png" alt="image-20210529165523606"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*client.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socketaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientSocket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span></span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//创建客户端，没有连接</span></span><br><span class="line">    clientSocket = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*determine the server&#x27;s address*/</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr,ptrh-&gt;h_addr,ptrh-&gt;h_length);</span><br><span class="line">    gets(Sentence);</span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    n = sendto(clientSocket,Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>,</span><br><span class="line">              (struct sockaddr *)&amp;sad,&amp;addr_len);</span><br><span class="line">    </span><br><span class="line">    n = recvfrom(clientSocket,modifiedSentence,<span class="keyword">sizeof</span>(modifiedSentence),(struct sockaddr *)&amp;sad,&amp;addr_len);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER :%s\n&quot;</span>,modifiedSentence);</span><br><span class="line">    close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*server.c*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="keyword">int</span> serverSocket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    serverSocket = socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    bind(serverSocket,(struct sockaddr *)&amp;sad,<span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n = recvfrom(serverSocket,clientSentence,<span class="keyword">sizeof</span>(clientSentence),<span class="number">0</span>,(struct sockaddr *)&amp;cad,&amp;addr_len);</span><br><span class="line">        </span><br><span class="line">        n = sendto(serverSocket,capitalizedSentence,<span class="built_in">strlen</span>(capitalizedSentence),(struct sockaddr *)&amp;cad,&amp;addr_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="传输服务与协议"><a href="#传输服务与协议" class="headerlink" title="传输服务与协议"></a>传输服务与协议</h4><ul>
<li>为运行在不同主机上的应用进程提供逻辑通信</li>
<li>传输协议运行在端系统<ul>
<li>发送方：将应用层报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供选择<ul>
<li>Internet TCP、UDP</li>
</ul>
</li>
</ul>
<h4 id="传输层VS-网络层"><a href="#传输层VS-网络层" class="headerlink" title="传输层VS.网络层"></a>传输层VS.网络层</h4><p>网络层服务：主机之间的逻辑通信</p>
<p>传输层服务：进程之间的逻辑通信</p>
<ul>
<li>依赖于网络层服务<ul>
<li>延时带宽</li>
</ul>
</li>
<li>对网络层服务进行加强<ul>
<li>数据丢失、顺序混乱、加密</li>
</ul>
</li>
</ul>
<h4 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h4><ul>
<li>可靠的、保序的传输：TCP<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序传输：UDP<ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的IP服务添加更多的其他额外服务</li>
</ul>
</li>
<li>都不提供<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<h4 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h4><ul>
<li><p>在发送方主机多路复用</p>
<p>从多个套接字接收来自多个应用进程的报文，根据套接字对应的IP地址和端口号等信息对报文段的用头部加以封装（该头部信息用于以后的解复用</p>
</li>
<li><p>在接收方主机多路解复用</p>
<p>根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字（和对应的应用进程）</p>
</li>
<li><p>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确socket,从而交给正确的进程</p>
</li>
<li><p>主机收到IP数据报</p>
<ul>
<li><p>每个数据报有源IP地址和目标地址</p>
</li>
<li><p>每个数据包承载一个传输层报文段</p>
</li>
<li><p>每个报文段有一个源端口号和目标端口号</p>
<p>（特定应用有著名端口号</p>
</li>
</ul>
</li>
<li><p>主机联合使用IP地址和端口号将报文段发送给合适的套接字</p>
</li>
</ul>
<h4 id="UDP：用户数据报协议"><a href="#UDP：用户数据报协议" class="headerlink" title="UDP：用户数据报协议"></a>UDP：用户数据报协议</h4><ul>
<li><p>尽力而为的服务，报文段可能</p>
<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序</li>
</ul>
</li>
<li><p>无连接</p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li><p>UDP被用于</p>
<ul>
<li>流媒体（丢失不敏感、速率敏感、应用可控制传输速率</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li><p>在UDP上实现可靠传输</p>
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
</li>
<li><p>为什么要有UDP?</p>
<ul>
<li><p>不建立连接，（会增加延时</p>
</li>
<li><p>简单，在发送端与客户端没有连接状态</p>
</li>
<li><p>报文段头部很小（开销小）</p>
</li>
<li><p>无拥塞控制和流量控制</p>
<p>UDP可以尽可能快地发送报文段</p>
<p>应用-&gt;传输速率 = 主机-&gt;网络速率</p>
</li>
</ul>
</li>
<li><p>UDP报文段头部8个字节</p>
<ul>
<li>源端口号、目标端口号、长度、校验和</li>
</ul>
</li>
<li><p>UDP校验和</p>
<ul>
<li><p>目标：检测在被传输报文段的查错（如比特翻转</p>
</li>
<li><p>发送方</p>
<ul>
<li>将报文段的内容视为16比特整数</li>
<li>检验和：报文段的加法和（1的补运算</li>
<li>发送方将检验和放在UDP的检验和字段</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li><p>计算接收到的报文段校验和</p>
</li>
<li><p>检查计算出的校验和与校验和字段内容是否相等</p>
<ul>
<li><p>不相等—检测到差错</p>
</li>
<li><p>相等：没有检测到差错，但也许还是有差错</p>
<p>残存错误</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可靠数据传输（rdt-原理"><a href="#可靠数据传输（rdt-原理" class="headerlink" title="可靠数据传输（rdt)原理"></a>可靠数据传输（rdt)原理</h4><ul>
<li><p>rdt在应用层、传输层、数据链路层都很重要</p>
</li>
<li><p>信道的不可靠特点决定了可靠数据传输协议的复杂性</p>
</li>
<li><p>问题描述</p>
<p>rdt_send()被上层（如应用层）调用，以将数据交付给下方的发送实体</p>
<p>udt_send():被rdt调用，用以将分组放到不可靠的信道上传输到接收方</p>
<p>udt_rev():当分组通过信道到达接收方时被调用</p>
<p>deliver_data():被rdt调用，将数据交付给上层</p>
</li>
<li><p>渐增式地开发可靠数据传输协议（rdt)的发送方和接收方</p>
</li>
<li><p>只考虑单向数据传输</p>
<ul>
<li>控制信息是双向流动的</li>
</ul>
</li>
<li><p>双向的数据传输实际上是2个单向数据传输实现的</p>
</li>
<li><p>使用有限状态机（FSM)来描述发送方和接收方）</p>
</li>
</ul>
<h5 id="1-0-在可靠信道上的可靠数据传输"><a href="#1-0-在可靠信道上的可靠数据传输" class="headerlink" title="1.0 在可靠信道上的可靠数据传输"></a>1.0 在可靠信道上的可靠数据传输</h5><ul>
<li>下层信道是完全可靠的<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的FSM<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<h5 id="2-0-具有比特差错的信道"><a href="#2-0-具有比特差错的信道" class="headerlink" title="2.0 具有比特差错的信道"></a>2.0 具有比特差错的信道</h5><ul>
<li>下层信道可能会出错：将分组中的比特翻转<ul>
<li>用检验和来检测比特差错</li>
</ul>
</li>
<li>怎么从差错中恢复<ul>
<li>确认(ACK):接收方显式地告诉发送方分组已被正确接收</li>
<li>否认确定（NAK):接收方显式地告诉发送方分组发生了差错</li>
</ul>
</li>
<li>rdt2.0:采用差错控制编码进行差错检测<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK,NAK)接收方-&gt;发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
<li>rdt 2.1:发送方处理出错的ACK/NAK<ul>
<li>发送方<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAL是否出错（EDC)</li>
<li>状态数变成了两倍（必须记住当前分组序列号是0还是1</li>
</ul>
</li>
<li>接收方<ul>
<li>必须检测收到的分组是否是重复的<ul>
<li>状态会只是希望收到的分组序号是0还是1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了ACK/NAK</li>
</ul>
</li>
</ul>
</li>
<li>rdt2.2 无NAK协议<ul>
<li>只使用NAK</li>
<li>接收方对最后正确接受的分组发ACK,以代替NAK<ul>
<li>接收方必须显式地包含被正确接受分组的序号</li>
</ul>
</li>
<li>当收到重复的ACK时，发送方与收到NAK采取相同动作，重传该分组</li>
<li>为后面的一次发送多个数据单位做一个准备<ul>
<li>一次能够发送多个</li>
<li>每一个应道都有ACK,NAK(麻烦)</li>
<li>使用对前一个数据单位的ACK,代替本单位的NAK</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-0-具有比特差错和分组丢失的信道"><a href="#3-0-具有比特差错和分组丢失的信道" class="headerlink" title="3.0 具有比特差错和分组丢失的信道"></a>3.0 具有比特差错和分组丢失的信道</h5><p>新的假设：下层信道可能会丢失分组（数据或ACK)</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状况<ul>
<li>检验和</li>
<li>序列号</li>
<li>ACK</li>
<li>重传</li>
</ul>
</li>
<li>方法：发送方等待ACK一段合理的时间<ul>
<li>发送端超时重传：如果到时没有收到ACK-&gt;重传</li>
<li>问题:如果分组（ACK)只是被延迟了<ul>
<li>重传会导致数据重复。序列号</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
</li>
<li>rdt3.0性能<ul>
<li>rdt3.0可以工作、但链路容量比较大的情况下，性能很大<ul>
<li>链路容量比较大，一次发一个PDU的不能充分利用链路传输能力</li>
</ul>
</li>
<li>瓶颈在于：网络协议限制了物理资源的利用</li>
</ul>
</li>
</ul>
<h5 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h5><p>流水线：允许发送方在未得到对方确认情况下一个发送多个分组</p>
<ul>
<li><p>必须增加序号的范围，用多个bit表示分组的序号</p>
</li>
<li><p>在发送方、接收方要有缓存区</p>
<ul>
<li><p>发送方缓冲：未得到确认，可能需要重传</p>
</li>
<li><p>接收方缓存：上层用户去用数据速率$\neq$接收到数据速率：接收到的数据可能乱序、排序交付（可靠）</p>
</li>
<li><p>两种通用的流水线协议：</p>
<p>回退N步（GBN）sw &gt; 1 rw = 1</p>
<p>选择重传（SR）sw &gt; 1 rw &gt; 1</p>
</li>
</ul>
</li>
</ul>
<h5 id="通用：滑动窗口协议"><a href="#通用：滑动窗口协议" class="headerlink" title="通用：滑动窗口协议"></a>通用：滑动窗口协议</h5><ul>
<li>发送缓存区<ul>
<li>形式：内存中的一个区域，落入缓存区的分组可以发送</li>
<li>功能：用于存放已发送、未确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li>发送缓冲区大小：一次最多可以发送多少个未经确认的分组<ul>
<li>停止等待协议 = 1</li>
<li>流水线协议&gt;1,合理的值，不能很大，链路利用率不能超100%</li>
</ul>
</li>
<li><p>发送缓冲区的分组</p>
<ul>
<li>未发送的：落入缓冲区的分组，可以连续发送出去</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能被删除</li>
</ul>
</li>
<li><p>发送窗口：发送缓冲区内容的一个范围</p>
<p>那些已发送但是未经确认的分组序号构成的空间</p>
</li>
<li><p>发送窗口的最大值$\leq$发送缓存区的值</p>
</li>
<li><p>一开始：没有发送任何一个分组</p>
<p>后沿 = 前沿</p>
<p>之后为发送窗口的尺寸</p>
</li>
<li><p>每发送一个分组，前沿前移一个单位</p>
</li>
<li><p>发送窗口前沿移动的极限：不能超过发送缓存区</p>
</li>
<li><p>接收窗口用于控制哪些分组可以接收</p>
<ul>
<li>只有收到的分组序号落入接收窗口才允许被接受</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li><p>接收窗口尺寸Wr = 1,则只能顺序接收</p>
</li>
<li><p>接收窗口尺寸Wr &gt; 1，则可以乱序接收</p>
<p>但提交给上层的分组，需按序</p>
</li>
<li><p>正常情况下2个窗口互动：</p>
<ul>
<li>发送窗口<ul>
<li>有新的分组落入缓冲区范围，发送-&gt;前沿滑动</li>
<li>来了老的低序号分组确认-&gt;后沿前移-&gt;新的分组落入发送缓冲区范围</li>
</ul>
</li>
<li>接受窗口<ul>
<li>收到分组，落入到接受窗口范围，接受</li>
<li>是低序号，发送确认给对方</li>
</ul>
</li>
</ul>
</li>
<li>异常情况下GBN的2窗口互动<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿移动</li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去</li>
<li>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区范围</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，没有落入到接受窗口范围内，抛弃</li>
<li>(重复)发送老分组的确认，累计确认</li>
</ul>
</li>
</ul>
</li>
<li>SR<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿移动</li>
<li>超时重发机制让发送端将超时的分组重新发送出去</li>
<li>来了乱序的分组确认-&gt;后沿不向前滑动-&gt;新的分组无法落入缓冲区的范围</li>
</ul>
</li>
<li>接受窗口<ul>
<li>收到乱序分组，落入到接收窗口范围内，接受</li>
<li>发送该分组的确认，单独确认</li>
</ul>
</li>
</ul>
</li>
<li>GBN : 简单、所需资源少,一旦出错，回退N步代价大</li>
<li>SR:出错时、重传一个代价小，复杂，所需资源多</li>
<li>适用范围：<ul>
<li>出错率低：比较适合GBN,出错罕见、没必要用复杂的SR</li>
<li>链路容量大，比较适合SR而不是GBN</li>
</ul>
</li>
</ul>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li><p>点到点</p>
<p>一个发送方，一个接收方</p>
</li>
<li><p>可靠的、按顺序的字节流</p>
<p>没有报文边界</p>
</li>
<li><p>管道化（流水线）</p>
<p>TCP拥塞控制和流量控制设置窗口大小</p>
</li>
<li><p>发送与接受缓存</p>
</li>
<li><p>全双工数据</p>
<ul>
<li>在同一链接中数据双向流动</li>
<li>MSS:最大报文段大小</li>
</ul>
</li>
<li><p>面向连接</p>
<ul>
<li>在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方状态变量</li>
</ul>
</li>
<li><p>有流量控制</p>
<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
<li><p>TCP序号</p>
<p>报文段首字节的在字节流的编号</p>
</li>
<li><p>确认号</p>
<p>期望从发送方收到的下一字节的序号</p>
<p>累计确认</p>
</li>
<li><p>TCP往返延时、超时</p>
<p>怎么设置TCP超时</p>
<ul>
<li>比RTT要长<ul>
<li>但RTT是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
</li>
<li><p>怎么估计RTT</p>
<ul>
<li>SampleRTT：测量从报文段发出到收到确认的时间<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li>SampleRTT会变化，因此估计的RTT应该比较平滑<ul>
<li>多次测量取均值</li>
</ul>
</li>
<li>$EstimatedRTT = (1-\alpha)<em>EstimatedRTT + \alpha </em> SampleRTT$<ul>
<li>指数加权移动平均</li>
<li>过去样本的影响成指数衰减</li>
<li>推荐值：$\alpha = 0.125$</li>
</ul>
</li>
</ul>
</li>
<li><p>设置超时</p>
<ul>
<li><p>EstimatedRTT + 安全边界时间</p>
<ul>
<li>EstimatedRTT变化大（方差大）-&gt;较大的安全边界时间</li>
</ul>
</li>
<li><p>SampleRTT会偏离EstimatedRTT多远</p>
<p>$DevRTT = (1-\beta)<em>DevRTT + \beta </em> |SampleRTT - EstimatedRTT|$</p>
<p>推荐值：$\beta = 0.25$</p>
</li>
<li><p>超时时间间隔设置：</p>
<p>$TimeoutInterval = EstimatedRTT + 4*DevRTT$</p>
</li>
</ul>
</li>
</ul>
<h5 id="TCP-可靠数据传输"><a href="#TCP-可靠数据传输" class="headerlink" title="TCP:可靠数据传输"></a>TCP:可靠数据传输</h5><ul>
<li><p>TCP在IP不可靠服务基础上建立了rdf</p>
<ul>
<li>管道化的报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累计确认（像GBN</li>
<li>单个重传定时器（GBN</li>
<li>是否可以接受乱序，没有规范</li>
</ul>
</li>
<li><p>通过以下事件触发重传</p>
<ul>
<li>超时（只重发那个最早未确认的</li>
<li>重复的确认</li>
</ul>
</li>
<li><p>考虑简化的TCP发送方</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制与拥塞控制</li>
</ul>
</li>
<li><p>TCP发送方事件</p>
<ul>
<li><p>从应用层接受数据</p>
<p>用nextseq创建报文段</p>
<p>序号nextseq为报文段首字节的字节流编号</p>
<p>如果还没有运行，启动定时器</p>
<ul>
<li><p>定时器与最早未确认的报文段关联</p>
</li>
<li><p>过期间隔</p>
<p>TimeOutInterval</p>
</li>
</ul>
</li>
<li><p>超时：</p>
<p>重传后沿最老的报文段</p>
<p>重启定时器</p>
</li>
<li><p>收到确认：</p>
<p>如果是对尚未确认的报文段确认</p>
<p>更新已被确认的报文序号</p>
<p>如果当前还有未被确认的报文段，重启定时器</p>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210531135224845.png" alt="image-20210531135224845"></p>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210531135257112.png" alt="image-20210531135257112"></p>
<h5 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h5><p>缓冲区TCP往里面写，app从当中读</p>
<p>流量控制：接收方控制发送方，不让发送方发送太多太快以至于让接收方的缓存区溢出</p>
<ul>
<li>接收方在其向发送方的TCP段头部的rwnd字段通告其空闲buffer大小<ul>
<li>RcvBuffer 大小通过socket选项设置（典型默认大小为4096字节</li>
<li>很多操作系统自动调整RcvBuffer</li>
</ul>
</li>
<li>发送方限制未确认字节数$\leq$ 接收方发送过来的rwnd值</li>
<li>保证接收方不被淹没</li>
</ul>
<h5 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h5><p>在正式交换数据之前，发送方和接受方握手建立通信关系</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接</li>
<li>同意连接参数</li>
</ul>
<ul>
<li><p>同意建立连接</p>
<ul>
<li>变化的延迟（连接请求没有丢、但可能超时</li>
<li>由于丢失造成的重传</li>
<li>报文乱序</li>
<li>互相看不到对方</li>
</ul>
</li>
<li><p>半连接</p>
<p>（只在服务器端维护了连接） 服务器发回的同意建立连接报文丢失</p>
</li>
<li><p>老数据被当成新的数据接收了</p>
</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210531141833815.png" alt="image-20210531141833815"></p>
<h5 id="TCP-关闭连接"><a href="#TCP-关闭连接" class="headerlink" title="TCP 关闭连接"></a>TCP 关闭连接</h5><p>客户端，服务器分别关闭它自己这一侧的连接</p>
<ul>
<li>发送FIN bit = 1的TCP段</li>
</ul>
<p>一旦接受到FIN,用ACK回应</p>
<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li>
</ul>
<p>可以处理同时的FIN交换</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li>拥塞<ul>
<li>太多的数据需要网络传输，超过了网络处理能力</li>
<li>与流量控制不同</li>
<li>拥塞的表现<ul>
<li>分组丢失（路由器缓冲区溢出</li>
<li>分组经历比较长的延迟（在路由器的队列中排队</li>
</ul>
</li>
<li>代价：<ul>
<li>延迟大</li>
<li>为了达到一个有效输出、网络需要做更多的工作（重传</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝<ul>
<li>没有丢失却超时的分组</li>
<li>降低了的goodput</li>
</ul>
</li>
<li>当分组丢失时，任何关于这个分组的上游传输能力都被浪费了</li>
</ul>
</li>
</ul>
</li>
<li>2种常用拥塞控制方法<ul>
<li>端到端拥塞控制<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否拥塞</li>
<li>TCP采用的方法</li>
</ul>
</li>
<li>网络辅助拥塞控制<ul>
<li>路由器提供给端系统以反馈信息<ul>
<li>单个bit置位，显示有拥塞</li>
<li>显示提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><ul>
<li><p>端到端的拥塞控制机制</p>
<ul>
<li>路由器不向主机提供拥塞反馈信息<ul>
<li>路由器负担轻</li>
<li>符合网络核心简单的TCP/IP架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息判断是否发生拥塞，从而采取动作</li>
</ul>
</li>
<li><p>拥塞控制的几个问题</p>
<ul>
<li>如何检测拥塞<ul>
<li>轻微拥塞</li>
<li>拥塞</li>
</ul>
</li>
<li>控制策略<ul>
<li>在拥塞发生时，降低速率</li>
<li>在拥塞缓解时，增加速率</li>
</ul>
</li>
</ul>
</li>
<li><p>检测拥塞</p>
<ul>
<li>某个段超时了（丢失事件）：拥塞</li>
<li>有关某个段的3次重复ACK：轻微拥塞</li>
</ul>
</li>
<li><p>速率控制方法</p>
<ul>
<li><p>维持一个拥塞窗口的值CongWin</p>
</li>
<li><p>发送端限制已发送但是未确认的数据量的上线</p>
<p>$LatsByteSent - LastByteAcked \leq CongWin$</p>
</li>
<li><p>从而粗略地控制发送方的往网络中注入的速率</p>
</li>
<li><p>$rate = \frac{CongWin}{RTT} bytes/sec$</p>
</li>
<li><p>congwin是动态的，是感知到的网络拥塞程度的函数</p>
<p>超时或者3个重复ACK，Congwin:</p>
<ul>
<li>超时：CongWin 将为1MSS,进入SS阶段然后再倍增到CongWin/2(每个RTT),从进入CA阶段</li>
<li>3个重复ack,CongWin将为CongWin/2,CA阶段</li>
</ul>
<p>否则（正常收到ACK),CongWin跃跃欲试</p>
<ul>
<li>SS阶段：加倍增加（每个RTT)</li>
<li>CA阶段：线性增加（每个RTT)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="联合控制"><a href="#联合控制" class="headerlink" title="联合控制"></a>联合控制</h5><ul>
<li>发送端控制发送但是未确认的量的同时，也不能够超过接收窗口，满足流量控制要求<ul>
<li>sendWin = min(CongWin,RecvWin)</li>
<li>同时满足拥塞控制、流量控制要求</li>
</ul>
</li>
<li>拥塞控制策略<ul>
<li>慢启动</li>
<li>AIMD:线性增、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
</li>
</ul>
<h5 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h5><ul>
<li><p>连接刚建立，CongWin = 1MSS</p>
<p>MSS = 1460bytes &amp; RTT = 200 msec</p>
<p>初始速率=58.4kbps</p>
</li>
<li><p>可用带宽可能$&gt;&gt;$MSS/RTT</p>
</li>
<li><p>当链接开始时，指数性增加发送速率，直到发生丢失的事件</p>
<ul>
<li>启动初值很低</li>
<li>速度很快</li>
</ul>
</li>
<li><p>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件</p>
<ul>
<li>每一个RTT，CongWin加倍</li>
<li>每收到一个ACK，CongWin+1</li>
<li>慢启动阶段，只要不超时或者3个重复ACK,一个RTT,CongWin加倍</li>
</ul>
</li>
<li><p>总结：初始速率很慢，但是加速确实指数性的</p>
<ul>
<li>指数增加，SS时间很短</li>
</ul>
</li>
</ul>
<h5 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h5><ul>
<li><p>乘性减</p>
<p>丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段</p>
</li>
<li><p>加性增</p>
<p>当CongWin大于阈值时，一个RTT如没有发生丢失事件，将CongWin加1MSS:探测</p>
</li>
<li><p>当收到3个重复的ACKs</p>
<ul>
<li>COngWin减半</li>
<li>窗口（缓冲区大小）之后线性增长</li>
</ul>
</li>
<li><p>当超时事件发生</p>
<ul>
<li>CongWin被设置为1MSS,进入SS阶段</li>
<li>之后窗口指数增长</li>
<li>增长到一个阈值（上次发生拥塞窗口的一半），线性增加</li>
</ul>
</li>
</ul>
<h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><ul>
<li><p>当CongWin &lt; Threshold,发送端处于慢启动阶段（slow-start),窗口指数性增长</p>
</li>
<li><p>当CongWin &gt; Threshold,发送端处于拥塞避免阶段，窗口线性增长</p>
</li>
<li><p>当收到三个重复的ACKs,Threshold设置为 CongWin/2,</p>
<p>CongWin = Threshold + 3</p>
</li>
<li><p>当超时事件发生时，Threshold = COngWin/2</p>
<p>CongWin = 1MSS，进入SS阶段</p>
</li>
</ul>
<h5 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h5><p>公平性目标：如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R/K</p>
<p>2个竞争的TCP会话：</p>
<ul>
<li>加性增加，斜率为1，吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><p>网络层服务</p>
<ul>
<li>在发送主机和接收主机对之间传送段（segment)</li>
<li>在发送端将段封装到数据报中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报头部</li>
</ul>
<h4 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h4><p>转发：将分组从路由器的输入接口转发到合适的输出端口</p>
<p>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径</p>
<ul>
<li>路由选择算法</li>
<li>路由选择协议</li>
</ul>
<h5 id="数据平面-1"><a href="#数据平面-1" class="headerlink" title="数据平面"></a>数据平面</h5><ul>
<li>本地，每个路由器功能</li>
<li>决定从路由器输入端口到达的分组如何转发到输出端口</li>
<li>转发功能：<ul>
<li>传统方式：基于目标地址+转发表</li>
<li>SDN:基于多个字段+流表</li>
</ul>
</li>
</ul>
<h5 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h5><ul>
<li>网络范围内的逻辑</li>
<li>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</li>
<li>2个控制平面方法：<ul>
<li>传统路由算法：在路由器中被实现</li>
<li>SDN:在远程服务器中实现</li>
</ul>
</li>
</ul>
<p>传统方式：路由与转发的相互作用</p>
<p>==控制平面==：路由算法决定端到端的路径</p>
<p>==数据平面==：IP协议根据转发表决定了IP数据报在此路由器上的局部转发</p>
<p>SDN方式：逻辑集中的控制平面</p>
<p>一个不同的控制器与本地控制代理交互</p>
<p>网络服务模型</p>
<p>对于单个数据报的服务</p>
<ul>
<li>可靠传送</li>
<li>延迟保证</li>
</ul>
<p>对于数据报流的服务</p>
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟差</li>
</ul>
<p>连接建立</p>
<ul>
<li>在某些网络架构中是第三个重要的功能</li>
<li>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接<ul>
<li>涉及路由器</li>
</ul>
</li>
<li>网络层与传输层连接服务的区别<ul>
<li>网络层：2个主机之间、涉及路径上的一些路由器</li>
<li>传输层：2个进程之间，只体现在端系统</li>
</ul>
</li>
</ul>
<h4 id="路由器结构概况"><a href="#路由器结构概况" class="headerlink" title="路由器结构概况"></a>路由器结构概况</h4><p>高层面通用路由器体系架构</p>
<ul>
<li>路由：运行路由选择算法/协议（RIP,OSPF,BGP）生成路由表</li>
<li>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</li>
<li>分布式交换<ul>
<li>根据数据报头部信息，如目标地址，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动</li>
<li>基于目标的转发：仅仅依赖于IP数据报的目标地址</li>
<li>通用转发：基于头部字段的任意集合进行转发</li>
</ul>
</li>
<li>当交换机构的速率小于输入端口的汇聚速率时-&gt;在输入端口可能要排队<ul>
<li>排队延迟以及由于输入缓存溢出造成丢失</li>
</ul>
</li>
<li>Head-of-the-Line(HOL) blocking:排在队头的数据报阻止了队列中其他数据报向前移动</li>
</ul>
<h5 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h5><ul>
<li>将分组从输入缓冲区传输到合适的输出端口</li>
<li>交换速率：分组可以按照该速率从输入传输到输出<ul>
<li>运行速度经常是输入、输出链路速率的若干倍</li>
<li>N个输入端口，交换机构的速率是输入线路的N倍比较理想、才不会成为瓶颈</li>
</ul>
</li>
<li>memory<ul>
<li>在CPU直接控制下交换</li>
<li>分组被拷贝到系统内存，CPU从头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li>
<li>转发速率被内存的带宽限制（数据报通过BUS两遍）</li>
<li>一次只能转发一个分组</li>
</ul>
</li>
<li>bus<ul>
<li>数据报通过共享总线、从输入端转发到输出端口</li>
<li>总线竞争：交换速度受限于总线带宽</li>
<li>一次处理一个分组</li>
<li>对于接入、企业级路由器，速度足够（但不适合区域或骨干网络</li>
</ul>
</li>
<li>crossbar<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
<li>Banyan网络，crossbar和其他的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口y,控制器短接相应的两个总线</li>
<li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li>
</ul>
</li>
<li>输出端口排队<ul>
<li>假设交换速率$R<em>{switch}$是$R</em>{line}$的N倍</li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存</li>
<li>排队带来延迟、由于输出端口缓存溢出则丢弃数据报</li>
</ul>
</li>
<li>调度机制<ul>
<li>选择下一个要通过链路传输的分组</li>
<li>FIFO按照分组到来的次序发送<ul>
<li>丢弃策略：<ul>
<li>tail drop</li>
<li>proiority</li>
<li>random</li>
</ul>
</li>
</ul>
</li>
<li>优先权调度</li>
<li>RR</li>
<li>Weighted Fair Queuing(WFQ)</li>
</ul>
</li>
</ul>
<h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p>网络层：</p>
<p>路由选择协议</p>
<ul>
<li>路径选择</li>
<li>RIP,OSPF,BGP</li>
</ul>
<p>IP协议</p>
<ul>
<li>地址约定</li>
<li>数据报格式</li>
<li>分组处理的约定</li>
</ul>
<p>ICMP协议</p>
<ul>
<li>错误报告</li>
<li>路由器命令</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601153141589.png" alt="image-20210601153141589"></p>
<ul>
<li><p>网络链路有MTU(最大传输单元)</p>
<p>-链路层帧所携带的最大数据长度</p>
<ul>
<li>不同的链路类型</li>
<li>不同的MTU</li>
</ul>
</li>
<li><p>大的IP数据报在网络上被分片</p>
<ul>
<li>一个数据报被分割成若干个小的数据报<ul>
<li>相同的ID</li>
<li>不同的偏移量</li>
<li>最后一个分片被标记为0</li>
</ul>
</li>
<li>重组只在最终得目标主机上进行</li>
<li>IP头部信息用于标识，排序相关分片</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601154304706.png" alt="image-20210601154304706"></p>
</li>
</ul>
<h6 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h6><ul>
<li>IP地址：32位标识，对主机或路由器接口编址</li>
<li>接口：主机、路由器和物理链路得连接处<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也可能有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
</li>
<li>一个IP地址和一个接口相关联</li>
</ul>
<h6 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h6><ul>
<li>IP地址<ul>
<li>子网部分：（高位bits)</li>
<li>主机部分：（低位bits)</li>
</ul>
</li>
<li>什么是子网（subnet)<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的高位相同，这些节点构成的网络的一部分叫做子网</li>
<li>无需路由器介入，子网内各主机可以在物理上相互可达</li>
</ul>
</li>
<li>要判断一个子网，将每一个接口从主机或路由器上分开，构成了一个个的网络孤岛</li>
<li>每一个孤岛（网络）都是一个可以被称之为subset</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601160148874.png" alt="image-20210601160148874"></p>
<p>（全零网络号、全1网络号不用）</p>
<p>（A，B,C类地址为单播地址，D类为组播地址，E类预留）</p>
<ul>
<li>特殊的IP地址<ul>
<li>子网部分：全为0—本网络</li>
<li>主机部分：全为0—本主机</li>
<li>主机部分：全为1—广播地址，这个网络的所有主机</li>
<li>127.x.x.x回路地址</li>
</ul>
</li>
<li>专用地址：地址空间的一部分供专用地址使用</li>
<li>永远不会当作共用地址来分配，不会与公用地址重复<ul>
<li>只在局部网络有意义，区分不同的设备</li>
</ul>
</li>
<li>路由器不对目标地址是专用地址的分组进行转发</li>
<li>专用地址范围：<ul>
<li>Class A 10.0.0.0 -10.255.255.255 MASK 255.0.0.0</li>
<li>Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0</li>
<li>Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0</li>
</ul>
</li>
</ul>
<h6 id="IP编址-CIDR"><a href="#IP编址-CIDR" class="headerlink" title="IP编址 CIDR"></a>IP编址 CIDR</h6><p>CIDR(Classless InterDomain Routing)</p>
<p>无类域间路由</p>
<ul>
<li>子网部分可以在任意的位置</li>
<li>地址格式： a.b.c.d/x,其中x为地址中的子网号长度</li>
</ul>
<p>转发表和转发算法</p>
<ul>
<li>获得IP数据报的目标地址</li>
<li>对于转发表中的每一个选项，如果（IP Des addr)&amp;(mask) == destination,则按照表项对应的接口转发该数据报</li>
<li>如果都没有，则使用默认表项转发数据报</li>
</ul>
<p>如何获得一个IP地址</p>
<ul>
<li><p>主机如何获得一个IP地址？</p>
<ul>
<li><p>系统管理员将地址配置在一个文件中</p>
<p>Wintel:control-panel-&gt;network-&gt;configuration-&gt;tcp/ip-&gt;properties（IP地址、字码掩码、默认网关、local name server)</p>
<p>Unix:/etc/rc.config</p>
</li>
<li><p>DHCP： Dynamic Host Configuration Protocol</p>
<p>从服务器中动态获得一个IP地址</p>
<ul>
<li>目标：允许主机在加入网络的时候，动态地从服务器那里获得IP地址<ul>
<li>可以更新对主机用IP地址的租用期</li>
<li>重新启动时，允许重新使用以前用过的IP地址</li>
<li>支持移动用户加入到该网络（短期在网）</li>
</ul>
</li>
<li>DHCP工作概况<ul>
<li>主机广播 DHCP discover 报文</li>
<li>DHCP服务器用DHCP offer提供报文响应</li>
<li>主机请求IP地址，发送DHCP request报文</li>
<li>DHCP服务器发送地址：DHCP Ack 报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何获得一个网络的子网部分？</p>
<ul>
<li>从ISP获得地址块中分配一个小地址块</li>
</ul>
</li>
<li><p>一个ISP如何获得一个地址块</p>
<p>ICANN：Internet Corporation for Assigned Names and Numbers</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名、解决冲突</li>
</ul>
</li>
</ul>
<h6 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h6><p>层次编址允许路由信息的有效广播</p>
<h6 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h6><p>所有离开本地网络的数据报具有一个相同的源地址NAT IP address ,但具有不同端口号</p>
<p>动机：本地网络只有一个有效IP地址</p>
<ul>
<li>不需要从ISP分配一块地址、可用一个IP地址用于所有的（局域网设备）—省钱</li>
<li>可以在局域网改变设备地址的情况下无需通知外界</li>
<li>可以改变ISP(地址变化)而不需改变内部的设备地址</li>
<li>局域网内部的设备没有明确地址，对外是不可见的（安全</li>
</ul>
<p>NAT路由器必须：</p>
<ul>
<li><p>外出数据包：替换源地址和端口号为Nat IP地址和新的端口号，目标IP和端口号不变</p>
<p>远端的C/S将会使用NAT IP地址，新端口号作为目标地址</p>
</li>
<li><p>记住每个轮换替换对（在NAT转换表中</p>
<p>源IP,端口 vs NAT ip 新端口</p>
</li>
<li><p>进入数据包：替换目标IP地址端口号，采用存储在NAT表中的mapping表项，用（源IP、端口</p>
</li>
</ul>
<p>NAT: Network Address Translation</p>
<ul>
<li>16-bit端口字段<ul>
<li>6万多个同时连接、一个局域网</li>
</ul>
</li>
<li>对NAT是有争议的<ul>
<li>路由器只应该对第三层信息做处理，而这里对端口号（4层）做了处理</li>
<li>违反了end-to-end原则<ul>
<li>端到端的原则，复杂性放到网络边缘<ul>
<li>无需借助中转和变换，就可以直接传送到目标主机</li>
</ul>
</li>
<li>NAT可能要被一些应用设计者考虑</li>
<li>外网的机器无法主动连接到内网机器上</li>
</ul>
</li>
<li>地址短缺可以被ipv6解决</li>
<li>Nat穿越</li>
</ul>
</li>
</ul>
<h6 id="Nat穿越"><a href="#Nat穿越" class="headerlink" title="Nat穿越"></a>Nat穿越</h6><ul>
<li><p>客户端需要连接地址为10.0.0.1的服务器</p>
<ul>
<li>服务器地址10.0.0.1LAN本地地址（客户端不能够使用其作为目标地址</li>
<li>整网只有一个外部可见地址</li>
</ul>
</li>
<li><p>方案1:静态配置NAT,转发进来的对服务器特定端口的连接请求</p>
</li>
<li><p>方案2:(IGD)协议:允许NATed主机可以：</p>
<ul>
<li>获知网络的公共IP地址</li>
<li>列举存在的端口映射</li>
<li>增删端口映射</li>
</ul>
<p>自动化静态NAT端口映射配置</p>
</li>
<li><p>方案3：中继</p>
<ul>
<li>NAT后面的服务器建立和中继的连接</li>
<li>外部的客户端链接到中继</li>
<li>中继在2个连接之间桥接</li>
</ul>
</li>
</ul>
<h6 id="IPv6-动机"><a href="#IPv6-动机" class="headerlink" title="IPv6 动机"></a>IPv6 动机</h6><ul>
<li>初始动机 32-bit地址空间将会很快被用完</li>
<li>另外的动机<ul>
<li>头部格式改变帮助加速处理和转发<ul>
<li>TTL-1</li>
<li>头部checksum</li>
<li>分片</li>
</ul>
</li>
<li>头部格式改变帮助QoS</li>
</ul>
</li>
<li>IPv6数据报格式<ul>
<li>固定的40字节头部</li>
<li>数据报传输过程中，不允许分片</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210601182357723.png" alt="image-20210601182357723"></p>
<p>TLV格式 T:type L:lenght V:Value</p>
<ul>
<li>CheckSum被移除掉，降低在每一段中处理速度</li>
<li>Options:允许，但在头部之外，被Next header字段标识</li>
<li>ICMPv6:ICMP的新报本<ul>
<li>附加了报文类型，e.g. Packet Too Big</li>
<li>多播组管理功能</li>
</ul>
</li>
<li>从IPv4到IPv6的平移<ul>
<li>不是所有的路由器能够同时升级的</li>
</ul>
</li>
<li>隧道：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报</li>
</ul>
<p>每个路由器上都有实现路由算法元件（他们之间需要相互交互）-形成传统IP实现方式的控制平面</p>
<p>1.每台设备上既实现控制功能又实现数据平面</p>
<p>2.控制功能分布式实现</p>
<p>3.路由表-粘连</p>
<ul>
<li><p>数量众多、功能各异的中间盒</p>
<ul>
<li>路由器的网络层功能<ul>
<li>IP转发：对于到来的分组按照路由表决定如何转发，数据平面</li>
<li>路由：决定路径、计算路由表、处在控制平面</li>
</ul>
</li>
<li>还有其他种类繁多的网络设备（中间盒<ul>
<li>交换机；防火墙；NAT;IDS;负载均衡设备</li>
</ul>
</li>
</ul>
</li>
<li><p>互联网网络设备：传统方式都是通过分布式、每台设备的方法来实现数据平面和控制平面</p>
</li>
<li><p>垂直集成：每台路由器或其他网络设备</p>
<ul>
<li>硬件、在私有的操作系统</li>
<li>互联网标准协议的私有实现</li>
<li>每个设备都实现了数据平面和控制平面的功能<ul>
<li>控制平面的功能是分布式实现的</li>
</ul>
</li>
<li>设备基本上只能按照固定方式工作，控制逻辑固化，不同的网络功能需要不同的middleboxes</li>
<li>(数据+控制平面)集成&gt;(控制逻辑)分布-&gt;固化<ul>
<li>代价大，升级困难，管理困难</li>
</ul>
</li>
</ul>
</li>
<li><p>SDN:逻辑上集中的控制平面</p>
<ul>
<li>一个不同的控制器与CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑</li>
</ul>
</li>
<li><p>主要思路：</p>
<ul>
<li>网络设备数据平面、控制平面分离</li>
<li>数据平面-分组交换机<ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽象：按照流表（有控制平面设置的控制逻辑)进行PDU(帧、分组)的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</li>
<li>统一化设备功能：SDN交换机（分组交换机），执行控制功能</li>
</ul>
</li>
<li>控制平面-控制器+网络应用<ul>
<li>分离、集中</li>
<li>计算、下发控制逻辑:流表</li>
</ul>
</li>
<li>水平集成控制平面的开放实现，创造了好的产业生态、促进发展</li>
<li>集中式实现控制逻辑、网络管理容易</li>
<li><p>基于流表的匹配+行动的工作方式允许可编程的分组交换机</p>
</li>
<li><p>流量工程：传统路由比较困难</p>
<ul>
<li>需要定义链路的代价、流量路由算法以此运算</li>
</ul>
</li>
<li><p>SDN特点</p>
<ul>
<li>通用的flow-based基于流的匹配+行动</li>
<li>控制平面和数据平面分离</li>
<li>控制平面功能在数据交换设备之外实现</li>
<li>可编程控制应用<ul>
<li>在控制器之上以网络应用形式实现各种网络功能</li>
</ul>
</li>
</ul>
</li>
<li><p>SDN架构：</p>
<ul>
<li>数据平面交换机<ul>
<li>快速、简单、商业化交换设备，采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li>基于南向API(例如OpenFlow),SDN控制器访问基于流的交换机</li>
<li>也定义了和控制器的协议</li>
</ul>
</li>
<li>SDN控制器（网络OS)<ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式实现</li>
</ul>
</li>
<li>网络控制应用<ul>
<li>控制的大脑：采用下层提供的服务（SDN控制器提供的API)，实现网络功能<ul>
<li>路由器、交换机</li>
<li>接入控制、防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供、与控制器厂商通常不同、与分组交换机厂商也可以不同</li>
</ul>
</li>
</ul>
</li>
<li><p>通用转发和SDN</p>
<p>每个路由器包含一个流表（被逻辑上集中的控制器计算和分发</p>
</li>
<li><p>OpenFlow数据平面抽象</p>
<ul>
<li><p>流：由分组（帧）头部字段所定义</p>
</li>
<li><p>通用转发：简单的分组处理规则</p>
<ul>
<li>模式：将分组头部字段和流表匹配</li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器</li>
<li>优先权Priority:几个模式匹配了优先采用哪个，消除歧义</li>
<li>计算器Counters#bytes以及#packets</li>
</ul>
<p>路由器中的流表定义了路由器的匹配+行动规则</p>
<p>match+action:统一化各种网络设备提供的功能</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制平面-1"><a href="#控制平面-1" class="headerlink" title="控制平面"></a>控制平面</h4><h5 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h5><p>路由协议的目标：确定从发送主机到接收主机之间、通过路由器网络较好的路径（等价于路由器序列</p>
<ul>
<li>路径：路由器序列,分组将会沿着该序列从源主机到达最后的目标主机</li>
<li>较好：最小代价、最快的、最不拥塞</li>
</ul>
<p>路由（route）的概念</p>
<ul>
<li><p>路由：按照某种指标（传输延迟、所经过的站点数目等）找到一条从源节点到目标结点的较好路径</p>
<ul>
<li><p>较好路径：按照某种指标较小的路径</p>
</li>
<li><p>指标：站数，延迟、费用、队列长度等、或者是一些单纯的指标加权</p>
</li>
<li><p>采用什么样的指标，标识网络使用者网络在什么方面表现突出、什么指标网络使用者比较重视</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>路由器-路由器最优路径=主机对之间的最优路径</p>
<ul>
<li>路由器连接子网、子网到路由器之间的跳数就一跳，必须要走</li>
<li>路由器到下一跳路由器（节点到节点）之间的最优路径找到了</li>
<li>也就找到了从源子网到目标子网所有主机对之间的最优路径</li>
<li>大大降低了路由计算的规模</li>
<li>在路由计算中按照子网到子网的路径计算为目标，而不是主机到主机</li>
</ul>
</li>
<li><p>路由选择算法（routing algorithm)网络层软件的一部分，完成路由功能</p>
</li>
</ul>
<ul>
<li><p>最优化原则</p>
<ul>
<li>汇集树（sink tree)<ul>
<li>此节点到所有其他节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
</ul>
</li>
</ul>
</li>
<li><p>路由选择算法的原则</p>
<ul>
<li><p>正确性：算法必须是正确的和完整的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应表项；没有处理不了的目标站地址</p>
</li>
<li><p>简单：算法在计算机上应简单、最优但复杂的算法、时间上延迟大、不实用、不应为了获取路由信息增加很多的通信量</p>
</li>
<li><p>健壮性：算法能适应通信量和网络拓扑的变化</p>
<p>通信量变化、网络拓扑的变化算法能很快适应</p>
<p>不向拥挤的链路发数据、不向断了的链路发数据</p>
</li>
<li><p>稳定性：产生的路由不应该摇摆</p>
</li>
<li>公平性：对每一个站点都公平</li>
<li>最优性：某一个指标的最优，时间上，费用上、等指标，或综合指标，实际上获取最优的结果代价较高，可以是次优的</li>
</ul>
</li>
<li><p>路由算法的分类</p>
<ul>
<li><p>全局</p>
<p>所有路由器拥有完整的拓扑和边的代价信息</p>
<p>link state算法</p>
</li>
<li><p>分布式</p>
<p>路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价</p>
<p>迭代地与邻居交换路由信息</p>
<p>distance vector算法</p>
</li>
<li><p>静态或动态</p>
<ul>
<li><p>静态：路由随时间变化缓慢</p>
<p>非自适应算法：不能适应网络拓扑和通信量的变化，路由表是事先计算好的</p>
</li>
<li><p>动态：路有变化很快</p>
<p>自适应路由选择、能适应网络拓扑和通信量的变化</p>
<ul>
<li><p>周期性更新</p>
</li>
<li><p>根据链路代价的变化而变化</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LS路由工作过程</p>
<ul>
<li><p>配置LS路由选择算法的路由工作过程</p>
<ul>
<li>各点通过各种渠道获得整个网络拓扑，网络中所有链路代价信息（这部分与算法无关，属于协议和实现）</li>
<li>使用LS路由算法，计算本站点到其他站点的最优路径（汇集树），得到路由表</li>
<li>按照此路由表转发分组(datagram方式)<ul>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
</li>
<li><p>LS路由的基本工作过程</p>
<p>1.发现相邻节点，获知对方网络地址</p>
<p>2.测量到相邻节点的代价（延迟、开销</p>
<p>3.组装一个LS分组，描述它到相邻节点的代价情况</p>
<p>4.将分组通过扩散的方式发送到所有其他路由器</p>
<ul>
<li>顺序号：用于控制无穷的扩散，每个路由器记录（源路由器、顺序号）发现重复的或老的就不扩散</li>
<li>解决问题的方法：年龄字段（age)<ul>
<li>生成一个分组时，年龄字段不为0</li>
<li>每过一个时间段，AGE字段-1</li>
<li>AGE字段为0的分组被抛弃</li>
</ul>
</li>
</ul>
<p>5.通过Dijkstra算法找到最短路径</p>
<ul>
<li>可能带来路径的震荡e.g. 链路代价=链路承载的流量</li>
</ul>
<p>路由器获得各站点LS分组和整个网络的拓扑</p>
<p>通过Dijkstra算法计算出到其他各路由器的最短路径（汇集树</p>
<p>将计算结果安装到路由表中</p>
<ul>
<li><p>每个节点独立算出到其他节点的最短路径</p>
</li>
<li><p>迭代算法：第k步直到本节点到k个其他节点的最短路径</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LS的应用情况</p>
<ul>
<li>OSPF是一种LS协议。被用于Internet上</li>
<li>IS-IS，被用于Internet主干上，Netware</li>
</ul>
</li>
<li><p>距离矢量路由选择(Bellman Ford)</p>
<p>动态路由选择算法之一</p>
<ul>
<li>距离矢量路由选择</li>
<li>链路状态路由选择</li>
</ul>
<p>距离矢量路由选择基本思想</p>
<ul>
<li>各路由器维护一张路由表</li>
<li>各路由器与相邻路由器交换路由表</li>
<li>根据获得的路由信息，更新路由表</li>
</ul>
</li>
<li><p>代价及相邻节点代价的获得</p>
<ul>
<li>跳数、延迟、队列长度</li>
<li>相邻节点间的代价获得、通过实测</li>
</ul>
</li>
<li><p>路由信息的更新</p>
<ul>
<li>根据实测，得到本节点A到相邻节点的代价（如延迟</li>
<li>根据各相邻节点声称他们到目标节点B的代价</li>
<li>计算出本站点A经过各相邻站点到目标节点B的代价</li>
<li>找到一个最小的代价、和相应的下一个节点Z，到达节点B经过此节点Z,并且代价为A-Z-B的代价</li>
<li>其他所有的目标节点一个计算法</li>
</ul>
<p>定期测量</p>
<p>定期交换</p>
</li>
<li><p>异步、迭代式：每次本地迭代被以下事件触发</p>
<ul>
<li>本地链路代价变化了</li>
<li>从邻居来了DV更新消息</li>
</ul>
</li>
<li><p>分布式</p>
<ul>
<li>每个节点只是在自己的DV改变之后向邻居通告</li>
<li>然后邻居们在有必要的时候通知他们的邻居</li>
</ul>
<p>每个节点</p>
<ul>
<li>等待（本地链路代价变化或者从邻居传送新的DV报文</li>
<li>重新计算各目标代价估计值</li>
<li>如果到任何目标的DV发生变化，通告邻居</li>
</ul>
</li>
<li><p>DV的无穷计算问题</p>
<ul>
<li>DV的特点<ul>
<li>好消息传得快，坏消息传得慢</li>
</ul>
</li>
<li>好消息的传播以每一个交换周期前进一个路由器的速度进行<ul>
<li>好消息：某个路由器接入或有更短的路径</li>
<li>坏消息传播速度非常慢（无穷计算问题）</li>
</ul>
</li>
<li>水平分裂算法<ul>
<li>C直到要经过B才能到达A,所以C向B报告A的距离为INF,C告诉D它到A的真实距离</li>
</ul>
</li>
</ul>
</li>
<li><p>LS和DV算法比较</p>
<ul>
<li><p>消息复杂度</p>
<ul>
<li><p>LS：有n节点、E条链路，发送报文O(nE)个</p>
<p>局部路由信息，全网传播</p>
</li>
<li><p>DV: 只与邻居交换信息</p>
<p>全网路由信息，局部传播</p>
</li>
</ul>
</li>
<li><p>收敛时间</p>
<ul>
<li>LS $O(n^2)$算法<ul>
<li>有可能震荡</li>
</ul>
</li>
<li>DV:收敛较慢<ul>
<li>可能存在路由环路</li>
<li>count-to-infinity问题</li>
</ul>
</li>
</ul>
</li>
<li><p>健壮性</p>
<p>路由器故障会发生什么</p>
<ul>
<li><p>LS:</p>
<p>节点会通告不正常的链路代价</p>
<p>每个节点只计算自己的路由表</p>
<p>错误信息影响较小，局部，路由比较健壮</p>
</li>
<li><p>DV:</p>
<p>DV节点可能通告对全网所有节点的不正确路径代价</p>
<ul>
<li><p>距离矢量</p>
</li>
<li><p>每一个节点的路由表可能被其他的节点使用</p>
<ul>
<li>错误可以扩散到全网</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="自治系统内部的路由选择"><a href="#自治系统内部的路由选择" class="headerlink" title="自治系统内部的路由选择"></a>自治系统内部的路由选择</h5><ul>
<li><p>RIP 距离矢量算法</p>
<ul>
<li>距离矢量：每条链路cost = 1,# of hops(max = 15hops）跳数</li>
<li>DV每隔30秒和邻居交换DV,通告</li>
<li>每个通告包括，最多25个目标子网</li>
</ul>
</li>
<li><p>链路失效与恢复</p>
<p>如果180s没有收到通告信息-&gt;邻居或者链路失效</p>
<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告（如果路由变化的话</li>
<li>链路失效快速地在整网中传输</li>
<li>使用毒性逆转（poison reverse)阻止ping-pong回路（不可达距离：跳数无限=16段）</li>
</ul>
</li>
<li><p>RIP以应用进程的形式实现（route-d)</p>
</li>
<li><p>通告报文通过UDP报文传输，周期性重复</p>
</li>
<li><p>网络层协议使用了传输层的服务，以应用层实体的形式实现</p>
</li>
<li><p>OSPF</p>
<ul>
<li><p>使用LS算法</p>
<ul>
<li>LS分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑，代价在每一个节点中都保持</li>
<li>路由计算采用dijkstra算法</li>
</ul>
</li>
<li><p>OSPF通告信息携带：每一个邻居路由器的表项</p>
</li>
<li><p>通告信息会传遍AS全部（通过泛洪）</p>
<ul>
<li>在IP数据报上直接传送OSPF报文</li>
</ul>
</li>
<li><p>IS-IS路由协议：几乎和OSPF一样</p>
</li>
<li><p>安全：所有OSPF报文都是经过认证的</p>
</li>
<li><p>允许有多个代价相同的路径存在（在RIP协议中只有一个）</p>
</li>
<li><p>对每一个链路，对于不同的TOS有多重代价矩阵</p>
<ul>
<li>卫星链路代价对尽力而为的服务代价设置较低，对实时服务代价设置较高</li>
<li>支持按照不同代价计算最优路径</li>
</ul>
</li>
<li><p>对单播和多播的集成支持</p>
<ul>
<li>Multicast OSPF使用相同的拓扑数据库</li>
</ul>
</li>
<li><p>在大型网络中支持层次性的OSPF</p>
</li>
</ul>
</li>
</ul>
<h5 id="ISP之间的路由选择"><a href="#ISP之间的路由选择" class="headerlink" title="ISP之间的路由选择"></a>ISP之间的路由选择</h5><ul>
<li><p>层次路由</p>
<ul>
<li>一个平面路由：<ul>
<li>一个网络中的所有路由器地位一样</li>
<li>通过LS、DV,或者其他路由算法，所有路由器都要知道其他所有路由器（子网）怎么走</li>
<li>所有路由器在一个平面</li>
</ul>
</li>
<li>平面路由的问题<ul>
<li>规模巨大的网络中，路由信息的存储、传输、计算代价巨大<ul>
<li>DV距离矢量很大，且不能收敛</li>
<li>LS:几百万个节点的LS分组泛洪传输，存储以及最短路径计算</li>
</ul>
</li>
<li>管理问题：<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己的网络细节</li>
<li>还希望与其他网络互联</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>层次路由：将互联网分成一个一个的AS(路由器区域)</p>
<ul>
<li>某个区域内的路由器集合，自治系统）autonomous systems (AS)</li>
<li>一个AS用AS Number (ASN)唯一标识</li>
<li>一个ISP可能包括一个或者多个AS</li>
</ul>
</li>
<li>路由变成了：2个层次路由<ul>
<li>AS内部路由：在同一个AS内路由器运行相同的路由协议<ul>
<li>intra-AS routing protocol：内部网关协议</li>
<li>不同的AS可能运行着不同的内部网关协议</li>
<li>能够解决规模和管理问题</li>
<li>如RIP,OSPF,IGRP</li>
<li>网关路由器：AS边缘路由器，可以连接到其他AS</li>
</ul>
</li>
<li>AS间运行AS间路由协议<ul>
<li>inter-AS routing protocol:外部网关协议</li>
<li>解决AS之间的路由问题，完成AS之间互联互通</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>解决了规模问题<ul>
<li>内部网关协议解决：AS内部数量有限的路由器互相到达问题。AS内部规模可控<ul>
<li>AS节点太多，可分割AS,使得AS内部节点有限</li>
</ul>
</li>
<li>AS之间的路由规模<ul>
<li>增加一个AS，对于AS之间的路由从总体上来说，只是增加了一个节点=子网（每个AS可以用一个点标识</li>
<li>对于其他AS只是增加一个表项，就是这个新增的路由怎么走的问题</li>
<li>扩展性强：规模增大，性能不会减太多</li>
</ul>
</li>
</ul>
</li>
<li>解决了管理问题<ul>
<li>各个AS可以运行不同的内部网关协议</li>
<li>可以使自己网络的细节不向外透露</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="互联网AS间路由：BGP"><a href="#互联网AS间路由：BGP" class="headerlink" title="互联网AS间路由：BGP"></a>互联网AS间路由：BGP</h5><ul>
<li>BGP：自治区域间路由协议事实上的标准<ul>
<li>将互联网各个AS粘在一起的胶水</li>
</ul>
</li>
<li>BGP提供给每个AS以下方法<ul>
<li>eBGP:从相邻的ASes那里获得子网可达信息</li>
<li>iBGP:将获得的子网可达信息传遍到AS内部所有路由器</li>
<li>根据子网可达信息和策略来决定到达子网的好路径</li>
</ul>
</li>
<li>允许子网向互联网其他网络通告我在这里</li>
<li><p>基于距离矢量算法（路径矢量</p>
<ul>
<li>不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS序号的列表）能够避免简单DV算法的路由环路问题</li>
</ul>
</li>
<li><p>BGP会话：</p>
<p>2个BGP路由器（peers)在一个半永久的TCP连接上交换BGP报文</p>
<ul>
<li>通告向不同目标子网前缀的路径（BGP是一个路径矢量协议</li>
</ul>
</li>
<li><p>当通告一个子网前缀时，通告包括BGP属性</p>
<ul>
<li>prefix+attributes = ‘route’</li>
</ul>
</li>
<li><p>2个重要属性</p>
<ul>
<li>AS-PATH：前缀的通告所经过的AS列表：AS 67 AS 17<ul>
<li>检测回路：多路径选择</li>
<li>在向其他AS转发时，需要将自己的AS号加在路径上</li>
</ul>
</li>
<li>NEXT-HOP：从当前AS到下一跳AS有多个链路，在NEXT-HOP属性中，告诉对方通过哪个I转发</li>
<li>其他属性：路由偏好指标，如何被插入的属性</li>
</ul>
</li>
<li><p>基于策略的路由</p>
<ul>
<li>当一个网关路由器接收到了一个路由通告，使用输入策略来接受或过滤（accept/decline)<ul>
<li>过滤原因1：不想经过某个AS，转发某些前缀的分组</li>
<li>过滤原因2：已经有了一条往某前缀的偏好路径</li>
</ul>
</li>
<li>策略也决定了是否向它别的邻居通告收到的这个路由信息</li>
</ul>
</li>
<li><p>BGP报文</p>
<ul>
<li>使用TCP协议交换BGP报文</li>
<li>BGP报文：<ul>
<li>OPEN打开TCP链接，认证发送方</li>
<li>UPDATE：通告新路径（或者撤销原路径）</li>
<li>KEEPALIVE:在没有更新时保持连接、也用于对OPEN请求的确认</li>
<li>NOTIFICATION:报告以前消息的错误，也用来关闭连接</li>
</ul>
</li>
</ul>
</li>
<li><p>BGP路径选择</p>
<ul>
<li>路由器可能获得一个网络前缀的多个路径、路由器必须进行路径的选择，路由选择可以基于：<ul>
<li>本地偏好设置：偏好策略的决定</li>
<li>最短AS-PATH:AS的跳数</li>
<li>最近的NEXT-HOP路由器：热土豆路由</li>
<li>附加的判据：使用BGP标示</li>
</ul>
</li>
<li>一个前缀对应着多种路径，采用消除规则直到留下一条路径</li>
</ul>
</li>
<li><p>为什么内部网关协议与外部网关协议不同</p>
<ul>
<li><p>策略：</p>
<ul>
<li>Inter-AS管理员需要控制通信路径，谁在使用它的网络进行数据传输</li>
</ul>
</li>
<li><p>规模</p>
<ul>
<li>Intra-AS一个管理者，所以无需策略<ul>
<li>AS内部各子网的主机尽可能地利用资源进行快速路由</li>
<li>AS内部路由规模不是一个大的问题<ul>
<li>如果AS太大，可将AS分成小的AS:规模可控</li>
<li>AS之间只不过多了一个点</li>
<li>或者AS内部路由支持层次性、层次性路由节省了表空间、降低了更新的数据流量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>性能：<ul>
<li>Intra-AS关注性能</li>
<li>Inter-AS:策略比性能更重要</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h5><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>网络节点连接方式</p>
<ul>
<li>点到点连接</li>
<li>多点连接<ul>
<li>共享介质</li>
<li>通过网络交换机</li>
</ul>
</li>
</ul>
<p>WAN:网络形式采用点到点链路</p>
<ul>
<li>带宽大、距离远（延迟大）带宽延迟积大</li>
<li>如果采用多点连接方式<ul>
<li>竞争方式：一旦冲突代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
</ul>
<p>点到点链路的链路层服务</p>
<p>实现简单、封装与解封装</p>
<p>LAN一般采用多点连接方式</p>
<ul>
<li>连接节点方便</li>
<li>接到共享性介质上（或网络交换机）就可以连接所有其他节点</li>
</ul>
<p>多点连接方式网络的链路层功能实现复杂</p>
<ul>
<li>多点接入：协调各节点对共享型介质的访问与使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生、占有和释放</li>
</ul>
<ul>
<li>主机和路由器是节点（网桥和交换机也是）nodes</li>
<li>沿着通信路径，连接各相邻节点通信信道是链路（links)<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li>第二层协议数据单元帧（frame),封装数据报</li>
<li>数据链路层负责从一个节点通过链路将帧中的数据报发送到物理相邻节点</li>
<li>数据报（分组）在不同链路上以不同的链路协议传送<ul>
<li>第一条链路：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳802.11</li>
</ul>
</li>
<li>不同的链路协议提供不同的服务<ul>
<li>e.g.在链路层上提供（或没有）可靠数据传送</li>
</ul>
</li>
</ul>
<h4 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h4><ul>
<li><p>成帧，链路接入</p>
<ul>
<li>将数据报装入帧中，加上帧头，帧尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用MAC物理地址来标识源和目的<ul>
<li>不同于IP地址</li>
</ul>
</li>
</ul>
</li>
<li><p>在相邻两个节点完成可靠数据传递</p>
<ul>
<li>在低出错率的链路（光纤、双绞线电缆）上很少使用</li>
<li>在无线链路经常使用、出错率高</li>
</ul>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务，一个特定的链路层只是提供其中的一部分服务</p>
</li>
<li><p>流量控制：</p>
<p>使得相邻的发送和接收方节点速度匹配</p>
</li>
<li><p>错误检测</p>
<ul>
<li><p>差错由信号衰减和噪声引起</p>
</li>
<li><p>接收方检测出的错误</p>
<p>通知发送端进行重传或者丢弃帧</p>
</li>
</ul>
</li>
<li><p>差错纠正</p>
<ul>
<li>接收端检查和纠正bit错误，不通过重传来纠正错误</li>
</ul>
</li>
<li><p>半双工和全双工</p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<p>链路层在哪里实现？</p>
<ul>
<li>在每一个主机上<ul>
<li>也在每个路由器上</li>
<li>交换机每个端口上</li>
</ul>
</li>
<li>链路层功能在适配器上实现（或者在一个芯片组上<ul>
<li>以太网卡，802.11网卡，以太网芯片组</li>
<li>实现链路层和相应的物理层功能</li>
</ul>
</li>
<li>接到主机的系统总线上</li>
<li>硬件、软件和固件的综合体</li>
</ul>
<p>发送方：</p>
<ul>
<li>在帧中封装数据报</li>
<li>加上差错控制编码，实现RDT和流量控制功能</li>
</ul>
<p>接收方：</p>
<ul>
<li>检查有无出错，执行rdt和流量控制功能等</li>
<li>解封装数据报，将之交给上层</li>
</ul>
<h4 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h4><p>EDC = 差错检测和纠正位（冗余位）</p>
<p>D= 数据由差错检测保护，可以包含头部字段</p>
<p>错误检测不是100%可靠</p>
<ul>
<li>协议会漏检一些错误</li>
<li>更长的EDC字段可以得到更好的检测和纠正效果</li>
</ul>
<h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><ul>
<li>单bit奇偶校验</li>
</ul>
<p>检测单个bit级错误</p>
<ul>
<li>2维奇偶校验</li>
</ul>
<p>检测和纠正单个bit错误</p>
<h5 id="检验和：CRC-循环冗余校验"><a href="#检验和：CRC-循环冗余校验" class="headerlink" title="检验和：CRC(循环冗余校验)"></a>检验和：CRC(循环冗余校验)</h5><ul>
<li><p>强大的差错检测码</p>
</li>
<li><p>将数据比特D看成二进制数据</p>
</li>
<li><p>生成多项式G,双方协商r+1位模式（r次方）</p>
<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li><p>目标：选择r位CRC附加位R，使得</p>
<ul>
<li><D,R>正好能被G整除（module 2)</li>
<li>接收方知道G,将<D,R>除以G,如果非0余数，检查出错</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul>
</li>
<li><p>CRC性能分析</p>
<ul>
<li><p>突发错误和突发长度</p>
</li>
<li><p>CRC检错性能描述</p>
<ul>
<li><p>能够检查出所有的1bit错误</p>
</li>
<li><p>能够检查出所有的双bits错误</p>
</li>
<li><p>能够检查出所有长度=r或者小于r位的错误</p>
</li>
<li><p>出现长度为r+1的突发错误，检查不出的概率为</p>
<p>$1/2^{r-1}$</p>
</li>
<li><p>出现长度大于r+1的突发错误，检查不出的概率为</p>
<p>$1/2^{r}$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h4><p>两种类型的链路：（一个子网内部链路连接形式）</p>
<ul>
<li>点对点<ul>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点到点链路</li>
</ul>
</li>
<li>广播（共享线路或媒体）<ul>
<li>传统以太网</li>
<li>HFC上行链路</li>
<li>802.11无线局域网</li>
</ul>
</li>
<li>多路访问协议<ul>
<li>单个共享的广播型链路</li>
<li>2个或更多站点同时传送：冲突<ul>
<li>多个节点同时发送、则会收到2个或多个信号的叠加</li>
</ul>
</li>
</ul>
</li>
<li>多路访问协议（介质访问控制协议：MAC）<ul>
<li>分布式算法-决定节点如何使用共享信道</li>
<li>关于共享控制的通信必须借助信道本身进行传输<ul>
<li>没有带外的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
</li>
<li>理想的多路访问协议<ul>
<li>给定Rbps的广播信道</li>
<li>必要条件：<ul>
<li>当一个节点要发送时，可以R速率发送</li>
<li>当M个节点要发送，每个可以以R/M的平均速率发送</li>
<li>完全分布的<ul>
<li>没有特殊节点协调发送</li>
<li>没有时钟和时隙同步</li>
</ul>
</li>
<li>简单</li>
</ul>
</li>
</ul>
</li>
<li>3大类<ul>
<li>信道划分<ul>
<li>将信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul>
</li>
<li>随机访问<ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li>依次轮流<ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
</li>
<li><p>信道划分MAC协议:TDMA</p>
<ul>
<li>TDMA time division multiple access<ul>
<li>轮流使用信道，信道的时间分成周期</li>
<li>每个站点使用每周其中固定的时隙（长度=帧传输时间）传输帧</li>
<li>如果站点无帧传输，时隙空闲-&gt;浪费</li>
</ul>
</li>
<li>FDMA :frequency division multiple access<ul>
<li>信道的有效频率范围被分成一个个小的频段</li>
<li>每个站点被分配一个固定的频段</li>
<li>分配给站点的频段没有被使用-&gt;空闲</li>
</ul>
</li>
<li>码分多路访问（CDMA) code division multiple access<ul>
<li>所有站点在整个频段上同时传输，采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>假定：信号同步很好，线性叠加</li>
</ul>
</li>
</ul>
</li>
<li><p>随机存取协议</p>
<ul>
<li>当节点有帧要发送时<ul>
<li>以信道带宽的全部R bps发送</li>
<li>没有结点间的预先协调</li>
</ul>
</li>
<li>两个或者更多节点同时传输，会发生冲突</li>
<li>随机存取协议规定<ul>
<li>如何检测冲突</li>
<li>如何从冲突中恢复</li>
</ul>
</li>
</ul>
</li>
<li><p>时隙ALOHA</p>
<p>假设</p>
<ul>
<li>所有帧都是等长的</li>
<li>时间被划分成相等的时隙，每个时隙可发送一帧</li>
<li>节点只在时隙开始时发送帧</li>
<li>节点在时钟上是同步的</li>
<li>如果两个或多个节点在同一时隙传输，所有的节点都能检测到冲突</li>
</ul>
<p>运行</p>
<ul>
<li><p>当节点获取到新的帧，在下一个时隙传输</p>
</li>
<li><p>传输时没有检测到冲突，成功</p>
</li>
<li><p>检测时如果检测到冲突，失败</p>
<p>节点在每一个随后的时隙以概率p重传帧直到成功</p>
</li>
</ul>
<p>优点</p>
<ul>
<li>节点可以以信道带宽全速连续传输</li>
<li>高度分布，仅需要节点之间在时隙上同步</li>
<li>简单</li>
</ul>
<p>缺点</p>
<ul>
<li>存在冲突、浪费时隙</li>
<li>即使有帧要发送，仍然可能存在空闲的时隙</li>
<li>节点检测冲突的时间&lt;帧传输的时间<ul>
<li>必须传完</li>
</ul>
</li>
<li>需要始终上同步</li>
</ul>
<p>效率：当有很多节点，每个节点有很多帧要发送时，x%的时隙时成功传输帧的时隙</p>
<ul>
<li><p>假设N个节点，每个节点都有很多帧要发送，在每个时隙中传输的概率是p</p>
</li>
<li><p>一个节点成功传输的概率为$p(1-p)^{N-1}$</p>
</li>
<li><p>任意一个节点成功的概率为$Np(1-p)^{N-1}$</p>
</li>
<li><p>N个结点的最大效率：</p>
<p>使得$f(P)=Np(1-p)^{N-1}$最大的$p^{*}$</p>
</li>
<li><p>N为无穷大时极限为$1/e = 0.37$</p>
</li>
</ul>
</li>
<li><p>纯ALOHA(非时隙)</p>
<ul>
<li>无时隙ALOHA:简单、无需节点间在时间上同步</li>
<li>当有帧需要传输，马上传输</li>
<li>冲突的概率增加</li>
</ul>
</li>
<li><p>CSMA冲突</p>
<ul>
<li><p>冲突仍然可能发生</p>
<p>由传播延迟造成：两个节点可能侦听不到正在进行的传输</p>
</li>
<li><p>冲突：</p>
<p>整个冲突帧的传输时间都被浪费了，是无效的传输</p>
</li>
<li><p>传播延迟决定了冲突的概率</p>
</li>
</ul>
<p>节点根据本地信道使用情况来判断全部信道使用情况</p>
</li>
<li><p>CSMA/CD(冲突检测)</p>
<p>CSMA/CD</p>
<ul>
<li>载波侦听CSMA:和在CSMA中一样发送侦听信道</li>
<li>没有传完一个帧就可以在短时间内检测到冲突</li>
<li>冲突发生时传输终止，减少对信道的浪费</li>
</ul>
</li>
<li><p>冲突检测CD技术，有线局域网中容易实现</p>
<ul>
<li>检测信号强度、比较传输与接收到的信号是否相同</li>
<li>通过周期的过零点检测</li>
</ul>
</li>
<li><p>以太网CSMA/CD算法</p>
<ul>
<li><p>适配器获取数据报，创建帧</p>
</li>
<li><p>发送前：侦听信道CS</p>
<p>闲：开始传输帧</p>
<p>忙：一直等到闲再发送</p>
</li>
<li><p>发送过程中，冲突检测CD</p>
<p>没有冲突：成功</p>
<p>检测到冲突放弃，之后尝试重发</p>
</li>
<li><p>发送方适配器检测到冲突</p>
<p>除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此，让所有站点都知道冲突</p>
</li>
<li><p>如果放弃，适配器进入指数退避状态</p>
</li>
<li><p>在第m次失败后，适配器随机选择一个${0,1,2,\cdots,2^{m-1}}$中的K，等待K*512位时，然后转步骤2</p>
</li>
</ul>
</li>
<li><p>无线局域网CSMA/CA</p>
<p>WLAN构成</p>
<ul>
<li>基站 ：AP</li>
<li>无线链路</li>
<li>移动主机节点</li>
</ul>
</li>
<li><p>冲突：2+站点（AP或者站点）在同一时刻发送</p>
<ul>
<li><p>802.11 CSMA- 发送前侦听信道</p>
<p>不会和其它节点正在进行的传输发生冲突</p>
</li>
<li><p>802.11：没有冲突检测</p>
<ul>
<li>无法检测冲突：自身信号远大于其他节点信号</li>
<li>即使能CD，冲突和成功没有关系</li>
<li>目标avoid collisions CSMA/C(ollision)A(voidance)<ul>
<li>无法CD,一旦发送全部发完，不CD</li>
<li>为了避免无CD带来信道利用率低的问题，事前进行冲突避免</li>
</ul>
</li>
</ul>
</li>
<li><p>发送方：</p>
<ul>
<li><p>如果站点侦听到信道空闲持续DIFS长，则传输整个帧</p>
</li>
<li><p>如果侦测到信道忙碌，那么选择一个随机会退值，并在信道空闲时递减该值，如果信道忙碌，回退值不会变化</p>
<p>当数到0时（只发生在信道闲时）发送整个帧</p>
<p>如果没有收到ACK，增加回退值，重复2</p>
</li>
</ul>
</li>
<li><p>接收方</p>
<p>如果帧正确，则在SIFS后发送ACK</p>
</li>
</ul>
<p>无线链路特性，需要每帧确认</p>
<p>无法完全避免冲突</p>
<ul>
<li><p>两个站点相互隐藏</p>
<p>A,B相互隐藏，C在传输</p>
<p>A，B选择了随机回退值</p>
<p>一个节点A先发</p>
<p>而B收不到，将count down减到0，发送</p>
<p>A,B的发送在C附近形成了干扰</p>
</li>
<li><p>选择了非常靠近的随机回退值</p>
<p>A,B选择的值比较近</p>
<p>A到0发送</p>
<p>信号没传到B，B减到0,发送</p>
<p>冲突</p>
</li>
</ul>
</li>
<li><p>冲突避免：</p>
<p>思想：允许发送方预约信道，而不是随机访问该信道</p>
<p>避免长数据帧的冲突</p>
<ul>
<li>发送方首先使用CSMA向BS发送一个小的RTS分组<ul>
<li>RTS可能冲突，但是短，浪费信道少</li>
</ul>
</li>
<li>BS广播clear-to-send CTS,作为RTS的响应</li>
<li>CTS能够被所有涉及的节点听到<ul>
<li>发送方发送数据帧</li>
<li>其他节点抑制发送</li>
</ul>
</li>
</ul>
</li>
<li><p>线缆接入网络</p>
<ul>
<li><p>多个40Mbps下行（广播）信道,FDM</p>
<ul>
<li>下行：通过FDM分成若干信道，互联网、数字电视</li>
<li>互联网信道：只有一个CMTS在其上传输</li>
</ul>
</li>
<li><p>多个30Mbps上行信道FDM</p>
<ul>
<li>多路访问：所有用户使用：接着TDM分成微时隙</li>
<li>部分时隙：分配，部分时隙：竞争</li>
</ul>
<p>预约，CMTS将预约结果通过下行信道下发</p>
</li>
</ul>
</li>
<li><p>轮流（Taking Turns) MAC协议</p>
<ul>
<li><p>信道划分MAC协议</p>
<ul>
<li><p>共享信道在高负载时时有效和公平的</p>
</li>
<li><p>在低负载时效率低下</p>
<p>只能等到自己的时隙开始发送或者利用1/N信道频率发送</p>
<p>当只有一个节点有帧传时，也只能得到1/N带宽分配</p>
</li>
</ul>
</li>
<li><p>随机访问MAC协议</p>
<ul>
<li>低负载时效率高，单个节点可以完全利用信道的全部带宽</li>
<li>高负载时效率低，冲突开销大，效率极低，时间很多浪费在冲突中</li>
</ul>
</li>
<li><p>轮流协议</p>
<p>有2者的优点</p>
</li>
</ul>
</li>
<li><p>轮流MAC协议</p>
<ul>
<li>轮询<ul>
<li>主节点邀请从节点一次传送</li>
<li>从节点一般比较dumb</li>
<li>缺点<ul>
<li>轮询开销:轮询本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传送，即使只有一个节点，也要等到轮询一周后发送</li>
<li>单点故障：主节点失效造成整个系统无法使用</li>
</ul>
</li>
</ul>
</li>
<li>令牌传递<ul>
<li>控制令牌（token)循环从一个节点到下一个节点传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点：<ul>
<li>令牌开销：本身消耗的带宽</li>
<li>延迟：只有等到抓到令牌，才能传输</li>
<li>单点故障（token）<ul>
<li>令牌丢失系统级故障，整个系统无法传输</li>
<li>复杂机制重新生成令牌</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h4><h5 id="MAC地址与ARP"><a href="#MAC地址与ARP" class="headerlink" title="MAC地址与ARP"></a>MAC地址与ARP</h5><ul>
<li>32bitIP地址<ul>
<li>网络层地址</li>
<li>用与使数据报到达目的IP子网：前n-1跳</li>
<li>从而到达子网中的目标节点：最后一跳</li>
</ul>
</li>
<li>LAN(MAC/物理/以太网)地址：<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡（同一物理网络中</li>
<li>48bit MAC地址固化在适配器的ROM，也可通过软件设定</li>
<li>理论上全球任意两个网卡的MAC地址都不相同</li>
<li>e.g. 1A-2F-BB-76-09-AD</li>
</ul>
</li>
</ul>
<h5 id="网络地址和mac地址分离"><a href="#网络地址和mac地址分离" class="headerlink" title="网络地址和mac地址分离"></a>网络地址和mac地址分离</h5><ul>
<li><p>IP地址和MAC地址作用不同</p>
<ul>
<li>IP地址是分层的<ul>
<li>一个子网所有的站点网络号一致，路由聚集，减少路由表<ul>
<li>需要一个网络中的站点地址网络号一致，如果捆绑需要定制网卡非常麻烦</li>
</ul>
</li>
<li>希望网络层地址是配置的，IP地址完成网络到网络的交付</li>
</ul>
</li>
<li>mac地址是一个平面的<ul>
<li>网卡在生产的时候不知道被用于哪个网络，因此网卡一个唯一的标志，用于区分一个网络内部不同的网卡即可</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付</li>
</ul>
</li>
</ul>
</li>
<li><p>分离好处</p>
<ul>
<li>网卡坏了，ip不变，可以捆绑到另一个网卡的mac上</li>
<li>物理网络还可以除IP之外支持其他网络层协议，链路协议为任意上层网络协议服务，如IPX等</li>
</ul>
</li>
<li><p>捆绑的问题</p>
<ul>
<li>如果仅仅使用IP地址，不使用mac地址,那么他仅支持IP协议</li>
<li>每次上电都要重新写入网卡IP地址</li>
<li>另外一个选择是不使用任何地址，不用mac地址,则每到来一个帧都要上传到IP层次，由他判断是否接收</li>
</ul>
</li>
<li><p>局域网每个适配器都有一个唯一的mac地址</p>
<p>FF-FF-FF-FF-FF-FF 广播地址</p>
</li>
<li><p>MAC地址由IEEE管理和分配</p>
</li>
<li><p>制造商购入MAC地址空间（保证唯一</p>
</li>
<li><p>类比：</p>
<ul>
<li>MAC地址：社会安全号</li>
<li>IP地址：通信地址</li>
</ul>
</li>
<li><p>MAC平面地址-&gt;支持移动</p>
<ul>
<li>可以将网卡连到其他网络</li>
</ul>
</li>
<li><p>IP地址有层次-不能移动</p>
<ul>
<li>依赖于节点连接的IP子网，与子网网络号相同（有与其相连的子网相同的网络前缀</li>
</ul>
</li>
<li><p>已知IP地址，如何确定mac地址</p>
<ul>
<li><p>在LAN上的每个IP节点都有一个ARP表</p>
</li>
<li><p>ARP表：包括一些LAN节点IP/MAC地址映射</p>
<IP address:mac address:TTL>

<p>TTL时间为地址映射失效时间，典型是20min</p>
</li>
</ul>
</li>
<li><p>ARP协议：在同一个LAN(网络)</p>
<ul>
<li>A要发送帧给B(B的IP地址已知)，但B的MAC地址不在A的ARP表中</li>
<li>A广播包含B的IP地址的ARP查询包<ul>
<li>Dest MAC Address = FF-FF-FF-FF-FF-FF</li>
<li>LAN上所有节点收到查询包</li>
</ul>
</li>
<li>B接收到ARP包，回复A自己的MAC地址<ul>
<li>帧发送给A</li>
<li>用A的MAC地址（单播）</li>
</ul>
</li>
<li>A在自己的ARP表中缓存IP-to-MAC地址转换关系，直到信息超时<ul>
<li>软状态：靠定期刷新维持的系统状态</li>
<li>定期刷新周期之间维护的状态信息可能和原有系统不一致</li>
</ul>
</li>
<li>ARP是即插即用的<ul>
<li>节点自己创建ARP表项</li>
<li>无需网络管理员干预</li>
</ul>
</li>
</ul>
</li>
<li><p>以太帧结构</p>
<ul>
<li><p>发送方适配器在以太网帧中封装IP数据报，或其他网络层协议数据单元</p>
</li>
<li><p>前导码：</p>
<ul>
<li>7B10101010 + 1B 10101011</li>
<li>用来同步接收方与发送方的时钟速率<ul>
<li>使得接收方将自己的时钟跳到发送端的时钟</li>
<li>从而按照发送端时钟来接收所发送的帧</li>
</ul>
</li>
</ul>
</li>
<li><p>地址：6字节源MAC地址、目标MAC地址</p>
<ul>
<li>帧目标地址=本站MAC地址或是广播地址，递交帧中的数据到网络层</li>
<li>否则，忽略</li>
</ul>
</li>
<li><p>类型：指出高层协议（大多数情况是IP</p>
</li>
<li><p>CRC：在接受方校验</p>
<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="以太网：无连接、不可靠服务"><a href="#以太网：无连接、不可靠服务" class="headerlink" title="以太网：无连接、不可靠服务"></a>以太网：无连接、不可靠服务</h5><ul>
<li>无连接：帧传输前，没有接收方与发送方握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul>
<li>递交给网络层的数据流报可能有gap</li>
<li>如上层使用像传输层TCP协议这样的rdt,gap会被补上（源主机，TCP实体</li>
<li>否则应用层会看到gap</li>
</ul>
</li>
<li>以太网MAC协议：采用二进制退避的CSMA/CD介质访问控制形式</li>
<li>很多不同的以太网标准<ul>
<li>相同的MAC协议（介质访问控制）和帧结构</li>
<li>不同的速率</li>
<li>不同的物理层标准</li>
<li>不同的物理层媒介：光纤，同轴电缆，双绞线</li>
</ul>
</li>
<li>CSMA/CD<ul>
<li>没有时隙</li>
<li>NIC如果侦听到其他NIC在发送就不发送（载波侦听</li>
<li>发送时，适配器侦听到其他适配器在发送就放弃对当前真的发送，冲突检测</li>
<li>冲突后重传，重传前适配器等待一个随机时间</li>
</ul>
</li>
</ul>
<h5 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a>Hubs</h5><ul>
<li>hubs本质上是一个物理层的中继器<ul>
<li>从一个端口收，转发到其他所有端口</li>
<li>速率一致</li>
<li>没有帧的缓存</li>
<li>在hub端口没有CSMA/CD机制</li>
<li>提供网络管理功能</li>
</ul>
</li>
<li>Manchester编码<ul>
<li>在10BaseT中使用</li>
<li>每一个bit位时中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步<ul>
<li>节点间不需要集中和全局时钟</li>
</ul>
</li>
<li>10Mbps,使用20M带宽，效率50%</li>
</ul>
</li>
<li>网段（LAN segments):可以允许一个站点发送的网络范围<ul>
<li>在一个碰撞域，同时只允许一个站点在发送</li>
<li>如果2个节点同时发送，则会碰撞</li>
<li>通常具有相同的前缀，比IP子网更详细的前缀</li>
</ul>
</li>
<li>所有以hub连到一起的站点处于同一个网段，处在一个碰撞域<ul>
<li>骨干hub将所有网段连到了一起</li>
</ul>
</li>
<li>通过hub可扩展节点之间的最大距离</li>
<li>通过hub，不能将10baseT和100BaseT的网络连接到一起</li>
</ul>
<h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><ul>
<li>链路层设备：扮演主动角色（端口执行以太网协议<ul>
<li>对帧进行存储转发</li>
<li>对于到来的帧，检查帧头。根据MAC地址进行选择性转发</li>
<li>当帧需要向某个网段进行转发，需要使用CSMA/CD进行控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul>
</li>
<li>透明，主机对交换机的存在可以不关心<ul>
<li>通过交换机相连的个节点好像这些站点直接相连一样</li>
<li>有MAC地址，无IP地址</li>
</ul>
</li>
<li>即插即用，自学习<ul>
<li>交换机无须配置</li>
</ul>
</li>
<li>多路同时传输<ul>
<li>主机有一个专用和直接到交换机的连接</li>
<li>交换机缓存到来的帧</li>
<li>对每个帧进入的链路使用以太网协议，没有碰撞，全双工<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC协议在其中的作用弱化了</li>
</ul>
</li>
</ul>
</li>
<li>每个交换机都有一个交换表switch table，每个表项<ul>
<li>（主机MAC地址，到达该MAC经过的接口，时戳）</li>
</ul>
</li>
<li>交换机通过学习得到哪些主机可以通过哪些端口到达<ul>
<li>当接收到帧，交换机学习到发送站点所在端口</li>
<li>记录发送方MAC地址/进入端口映射关系，在交换表中</li>
</ul>
</li>
</ul>
<p>交换机 vs.路由器</p>
<ul>
<li><p>都是存储转发设备，但是层次不同</p>
<ul>
<li>交换机：链路层设备（检查链路层头部）</li>
<li>路由器：网络层设备（检查网络层头部）</li>
</ul>
</li>
<li><p>都有转发表</p>
<ul>
<li>交换机：维护交换表，按照MAC地址转发<ul>
<li>执行过滤自学习生成树算法</li>
<li>即插即用，二层设备，速率高</li>
<li>执行生成树算法，限制广播帧转发</li>
<li>ARP表项随着站点数量增多而增多</li>
</ul>
</li>
<li>路由器维护路由表，执行路由算法<ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li>
<li>对广播分组做限制</li>
<li>不是即插即用，配置网络地址（子网前缀</li>
<li>三层设备，速率低</li>
</ul>
</li>
</ul>
</li>
<li><p>LAN 不碰撞=成功</p>
<p>帧长度$\geq 2\tau$ $\tau$最远两个站点之间的传播延时</p>
</li>
</ul>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p>机密性：只有发送方和预定的接收方能理解传输的报文内容</p>
<ul>
<li>发送方加密报文</li>
<li>接收方解密报文</li>
</ul>
<p>认证：发送方接收方需要确认对方身份</p>
<p>报文完整性：发送方、接收方需要确认报文在传输过程中或者时候没有被改变</p>
<p>访问控制和服务的可用性：服务可以接入以及对用户而言是可用的</p>
<h4 id="加密语言"><a href="#加密语言" class="headerlink" title="加密语言"></a>加密语言</h4><ul>
<li>对称密钥密码学：发送方和接收方密钥相同</li>
<li>公开密钥密码学：发送方使用接收方的公钥进行加密，接收方使用自己的私玥进行解密</li>
</ul>
<p>对称密钥加密</p>
<p>替换密码：将一个事情替换为另一个事情</p>
<p>单词替换密码：将一个字母替换成另外一个字母</p>
<p>加密$K<em>{A-B}(m)$，解密$K</em>{A-B}(K_{A-B}(m))$</p>
<ul>
<li>key分发？</li>
</ul>
<p>DES</p>
<p>初始替换</p>
<p>16轮一样的函数应用</p>
<p>每一轮使用不同的48bit密钥</p>
<p>最终替换</p>
<p>AES</p>
<p>块密码</p>
<p>密码块链</p>
<ul>
<li>密码块：如果输入块重复，将会得到相同的密文块</li>
<li>密码块链：异或第i轮的输入m(i),与前一轮的密文c(i-1)</li>
</ul>
<p>公开密钥密码学</p>
<ul>
<li>发送方接收方无需共享密钥</li>
<li>一个实体的公钥公诸于众</li>
<li>私玥只有自己知道</li>
</ul>
<p>RSA</p>
<p>认证</p>
<p>目标：避免重放攻击</p>
<ul>
<li>Nonce一生只用一次整数R</li>
<li>ap4.0 为了证明Alice的活跃性，Bob发送给Alice一个nonce R</li>
<li>Alice必须返回加密之后的R,使用双方约定好的key</li>
</ul>
<p>ap4.0需要双方共享一个对称式的密钥</p>
<p>ap5.0:使用nonce，公开加密技术</p>
<p>用Alice公钥解密</p>
<p>中间攻击</p>
<p>报文完整性</p>
<ul>
<li>数字签名</li>
</ul>
<p>数字签名类比于手写签名</p>
<ul>
<li>发送方Bob数字签署了文件，前提时它时文件拥有者，创建者</li>
<li>可验证性、不可伪造性、不可抵赖性<ul>
<li>谁签署：接收方可以向他人证明，而不是其他人签署了这个文件</li>
<li>签署了什么：这份文件而不是其他文件</li>
</ul>
</li>
<li>报文摘要</li>
</ul>
<p>对长报文进行公开密钥加密算法的实施需要耗费大量时间</p>
<p>Goal：固定长度，容易计算</p>
<ul>
<li>对m使用散列函数，得到固定长度报文摘要H(m)</li>
</ul>
<p>散列函数特性：</p>
<ul>
<li>多对一</li>
<li>结果固定长度</li>
<li>给定一个报文摘要x，反向计算原报文是不可行的</li>
</ul>
<p>散列函数算法MD5，SHA-1</p>
<p>可信赖中介</p>
<ul>
<li><p>对称密钥问题</p>
<ul>
<li><p>共享对称式密钥</p>
</li>
<li><p>trusted key distribution center (KDC)在实体之间扮演可信赖中介角色</p>
<ul>
<li>KDC:服务器和每一个注册用户都共享一个对称式的密钥</li>
<li>Alice,Bob和KDC通信时，知道他们自己的对称式密钥$K<em>{A-KDC} $,$K</em>{B-KDC}$</li>
</ul>
</li>
</ul>
</li>
<li><p>公共密钥问题</p>
<ul>
<li><p>如何保证获取的是对方公钥</p>
</li>
<li><p>可信赖的certification authority(CA)</p>
<ul>
<li>CA将每一个注册实体E和它的公钥捆绑</li>
<li>E到CA哪里注册它的公钥<ul>
<li>E提供给CA，自己身份的证据</li>
<li>CA创建一个证书，捆绑了实体信息和它的公钥</li>
<li>Certificate包括了E的公钥，而且是被CA签署的（被CA用自己的密钥加了密的）</li>
</ul>
</li>
<li>当Alice需要拿到Bob公钥<ul>
<li>获得Bob证书certificate(从Bob或者其他地方)</li>
<li>对Bob的证书，使用CA的公钥验证</li>
</ul>
</li>
</ul>
</li>
<li>证书包括<ul>
<li>串号（证书发布者唯一</li>
<li>证书拥有者信息，包括算法和密钥值</li>
</ul>
</li>
</ul>
</li>
<li><p>信任树</p>
<ul>
<li>根证书：根证书是未被签名的公钥证书或自签名证书<ul>
<li>拿到一些CA的公钥</li>
<li>渠道：安装OS自带的数字证书：从网上下载，你信任的数字证书</li>
</ul>
</li>
<li>信任树<ul>
<li>信任根证书CA颁发的证书，拿到了根CA的公钥（信任了根</li>
<li>由根CA签署的给一些机构的数字证书，包含了这些机构的数字证书</li>
<li>由于你信任了根，从而能够可靠地拿到根CA签发的证书，可靠地拿到这些机构的公钥</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="IP头部"><a href="#IP头部" class="headerlink" title="IP头部"></a>IP头部</h3><ul>
<li>第一个字段为版本字段（IPv4为4,IPv6为6）</li>
<li>Internet 头部长度，（4字节）限制头部最多为15*32位字，即60个字节</li>
<li>总长度字段（16位）IPv4数据报的数据长度最多为65535字节</li>
<li>TTL生存期，每过一个路由器减一，避免路由环路造成数据包循环传播</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>iterator</title>
    <url>/2021/04/16/iterator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="C-自定义iterator"><a href="#C-自定义iterator" class="headerlink" title="C++ 自定义iterator"></a>C++ 自定义iterator</h3><img src="/2021/04/16/iterator/lake-6256628.jpg" class="">
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not add any #include statements here.  If you have a convincing need for adding a different `#include` please post in the forum on KEATS.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO your code goes here:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node&lt;T&gt;* head;</span><br><span class="line">    Node&lt;T&gt;* tail;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="comment">// constructor with no parameters</span></span><br><span class="line">    LinkedList()&#123;</span><br><span class="line">        head = tail = <span class="literal">nullptr</span>;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor with initializer list</span></span><br><span class="line">    LinkedList( <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; ls )&#123;</span><br><span class="line">        head = tail = <span class="literal">nullptr</span>;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// add the elements to list</span></span><br><span class="line">        <span class="keyword">for</span>(T a: ls)&#123;</span><br><span class="line">            push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push a data in front of list</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * tmp = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">        tmp-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">nullptr</span>)</span><br><span class="line">            head-&gt;previous = tmp;</span><br><span class="line">        <span class="keyword">else</span> tail = tmp;</span><br><span class="line">        <span class="comment">//update head</span></span><br><span class="line">        head = tmp;</span><br><span class="line">        sz += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get first element in list</span></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> head-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push a data in the back of list</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * tmp = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">        tmp-&gt;previous = tail;</span><br><span class="line">        <span class="keyword">if</span>(tail != <span class="literal">nullptr</span>)</span><br><span class="line">            tail-&gt;next = tmp;</span><br><span class="line">        <span class="keyword">else</span> head = tmp;</span><br><span class="line">        <span class="comment">//update tail</span></span><br><span class="line">        tail = tmp;</span><br><span class="line">        sz += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return the last element</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> tail-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">NodeIterator&lt;T&gt;  <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NodeIterator&lt;T&gt;(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">NodeIterator&lt;T&gt; <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NodeIterator&lt;T&gt;(tail-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//destructor</span></span><br><span class="line">    ~LinkedList()&#123;</span><br><span class="line">        Node&lt;T&gt; * tmp;</span><br><span class="line">        <span class="comment">// free list</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tmp = head -&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse the list</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sz &lt;= <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        Node&lt;T&gt; * tmp = tail;</span><br><span class="line">        Node&lt;T&gt; * t = tmp -&gt; previous ;</span><br><span class="line">        Node&lt;T&gt; * tt = t-&gt;previous;</span><br><span class="line">        <span class="comment">// reverse the antecedent and successor relationship</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tmp-&gt;next = t;</span><br><span class="line">            t-&gt;previous = tmp;</span><br><span class="line">            tmp = t;</span><br><span class="line">            t = tt;</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="literal">nullptr</span>)</span><br><span class="line">            tt = t-&gt;previous;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//update head pointer and tail pointer</span></span><br><span class="line">        tmp = head;</span><br><span class="line">        head = tail;</span><br><span class="line">        tail = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the size of list</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert a new data to it</span></span><br><span class="line">    <span class="function">NodeIterator&lt;T&gt; <span class="title">insert</span><span class="params">(NodeIterator&lt;T&gt; it,T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; *cur = it.get();</span><br><span class="line">        Node&lt;T&gt; *tmp = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">        <span class="comment">// empty list</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> &amp;&amp; tail == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = tail = tmp;</span><br><span class="line">            sz ++;</span><br><span class="line">            <span class="keyword">return</span> NodeIterator&lt;T&gt;(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// not the end,insert data to list</span></span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            tmp-&gt;previous = cur-&gt;previous;</span><br><span class="line">            tmp-&gt;next = cur;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;previous == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp-&gt;previous-&gt;next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;previous = tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;previous = tail;</span><br><span class="line">            <span class="comment">// update tail pointer</span></span><br><span class="line">            tail = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sz ++;</span><br><span class="line">        <span class="keyword">return</span> NodeIterator&lt;T&gt;(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase one node from list</span></span><br><span class="line">    <span class="function">NodeIterator&lt;T&gt; <span class="title">erase</span><span class="params">(NodeIterator&lt;T&gt; it)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; *cur = it.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// current iterator is the tail of list</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//update tail pointer</span></span><br><span class="line">            tail = cur-&gt;previous;</span><br><span class="line">            <span class="comment">//empty list</span></span><br><span class="line">            <span class="keyword">if</span>(tail == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">            sz --;</span><br><span class="line">            <span class="comment">// return iterator of nullptr</span></span><br><span class="line">            <span class="keyword">return</span> NodeIterator&lt;T&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next-&gt;previous = cur-&gt;previous;</span><br><span class="line">            <span class="comment">// current iterator is the head of list</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;previous == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//update head pointer</span></span><br><span class="line">                head = cur-&gt;next;</span><br><span class="line">                <span class="comment">//empty list</span></span><br><span class="line">                <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)tail = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span> head-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;previous-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;T&gt; * tmp = cur-&gt;next;</span><br><span class="line">            sz --;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">            <span class="comment">// return a NodeIterator to what is now element i</span></span><br><span class="line">            <span class="keyword">return</span> NodeIterator&lt;T&gt;(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return begin of list</span></span><br><span class="line">    <span class="function">iterator&lt;T&gt; <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator&lt;T&gt;(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end of list</span></span><br><span class="line">    <span class="function">iterator&lt;T&gt; <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator&lt;T&gt;(tail-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do not edit below this line</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NODE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cerr</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not add any #include statements here.  If you have a convincing need for adding a different `#include` please post in the forum on KEATS.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO your code for the Node class goes here:</span></span><br><span class="line"><span class="comment">// (Note the &#x27;NodeIterator&#x27; class will report lots of errors until Node exists</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;<span class="comment">// data</span></span><br><span class="line">    Node * next;<span class="comment">//next Node</span></span><br><span class="line">    Node * previous;<span class="comment">//previous Node</span></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    Node(T data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeIterator</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    Node&lt;T&gt;* current;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NodeIterator(Node&lt;T&gt;* currentIn)</span><br><span class="line">        : current(currentIn) &#123;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> complete the code for NodeIterator here</span></span><br><span class="line">    <span class="comment">//return the next Node</span></span><br><span class="line">    NodeIterator <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="keyword">if</span>(current != <span class="literal">nullptr</span>)</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether two iterator is same</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> NodeIterator&lt;T&gt; &amp; nod)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;current == nod.current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether two iterator is not same</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> NodeIterator&lt;T&gt; &amp; nod)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;current != nod.current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the current pointer</span></span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    iterator(Node&lt;T&gt;* p = <span class="literal">nullptr</span>) :</span><br><span class="line">            m_ptr(p) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get data</span></span><br><span class="line">    T <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return the next Node</span></span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        m_ptr = m_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether two iterator is same</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator &amp;arg) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg.m_ptr == <span class="keyword">this</span>-&gt;m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether two iterator is not same</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator &amp;arg) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg.m_ptr != <span class="keyword">this</span>-&gt;m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do not edit below this line</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>防止条件丢失</title>
    <url>/2021/04/08/%E9%98%B2%E6%AD%A2%E6%9D%A1%E4%BB%B6%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="条件丢失"><a href="#条件丢失" class="headerlink" title="条件丢失"></a>条件丢失</h3><img src="/2021/04/08/%E9%98%B2%E6%AD%A2%E6%9D%A1%E4%BB%B6%E4%B8%A2%E5%A4%B1/campaign-6269159.jpg" class="">
<a id="more"></a>
<p>当signal发生在wait之前，就会丢失这次signal事件.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span> :</span> <span class="keyword">public</span> ConditionBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Condition()</span><br><span class="line">        : signal_(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_);</span><br><span class="line">        <span class="keyword">while</span> (!signal_)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond_, &amp;mutex_);</span><br><span class="line">        &#125;</span><br><span class="line">        signal_ = <span class="literal">false</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_);</span><br><span class="line">        signal_ = <span class="literal">true</span>;</span><br><span class="line">        pthread_cond_signal(&amp;cond_);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> signal_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>Make and Signal</title>
    <url>/2021/02/02/Make-and-Signal/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><p>hello world in make</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">hello:</span></span><br><span class="line">	echo <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>Save this in a file named ‘makefile’. Then navigate to the directory and run the command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make hello</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>Makefile syntax</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">&lt;TAB&gt; recipe</span><br></pre></td></tr></table></figure>
<ul>
<li>Make command in shell:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make target</span><br></pre></td></tr></table></figure>
<ul>
<li>Other targets can be used as prerequisites of a target</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: other_target target.c</span></span><br><span class="line"> Recipe_to_create_target</span><br><span class="line"><span class="section">other_target: other_target.c</span></span><br><span class="line"> Recipe_to_create_other_target</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">code_file1.o: code_file1.c</span></span><br><span class="line">	gcc -c code_file1.c -o code_file1.o</span><br><span class="line"><span class="section">code_file2.o: code_file2.c</span></span><br><span class="line">	gcc -c code_file2.c -o code_file2.o</span><br><span class="line"><span class="section">my_app: code_file1.o code_file2.o</span></span><br><span class="line">	gcc -o my_app code_file1.o code_file2.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o my_app</span><br></pre></td></tr></table></figure>
<ul>
<li><p>When make is ran, it looks for the <strong>target</strong> file in the directory. If the target is not found, </p>
<p>recipe to generate target is ran with all the prerequisites.</p>
</li>
<li><p>If <strong>target</strong> is found, it checks whether the dependencies have changed since last time. If </p>
<p>so, changed dependencies are run according to the configuration and the target is </p>
<p>generated.</p>
</li>
<li><p><strong>target</strong> can be different from output filename. In this case, make won’t be able to find the </p>
</li>
</ul>
<p>file and the file will be regenerated regardless of no changes. (Don’t do this when</p>
<p>compiling)</p>
<ul>
<li><p>By default the first target of the makefile is considered as the default target. If you run </p>
<p>make with no arguments, the first target is run.</p>
</li>
<li><p>By convention, the first target is set as <strong>all</strong>. It should have the recipe for the default </p>
<p>behaviour you expect from make.</p>
</li>
<li><p>Using <strong>.DEFAULT_GOAL</strong> can override the default behaviour of make</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#same behaviour if we use .DEFAULT_GOAL=my_app</span></span><br><span class="line"><span class="section">all:my_app </span></span><br><span class="line"><span class="section">code_file1.o: code_file1.c</span></span><br><span class="line">	gcc -c code_file1.c -o code_file1.o</span><br><span class="line"><span class="section">code_file2.o: code_file2.c</span></span><br><span class="line">	gcc -c code_file2.c -o code_file2.o</span><br><span class="line"><span class="section">my_app: code_file1.o code_file2.o</span></span><br><span class="line">	gcc -o my_app code_file1.o code_file2.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o my_app</span><br></pre></td></tr></table></figure>
<p><strong>Phony target</strong> is a target which is not the name of a file. Say we have a target named ‘clean’. If we also have a file named clean, make will not run the recipe for this target.</p>
<p>We can indicate such targets with <strong>.PHONY</strong> and make will run it regardless of a file.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o my_app</span><br></pre></td></tr></table></figure>
<p>You can define variables in makefile:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJECTS=code_file1.o code_file2.o</span><br><span class="line"><span class="section">my_app: <span class="variable">$(OBJECTS)</span></span></span><br><span class="line">	gcc -o my_app <span class="variable">$(OBJECTS)</span></span><br></pre></td></tr></table></figure>
<p>You can use wildcards as well.</p>
<h3 id="implicit-variables"><a href="#implicit-variables" class="headerlink" title="implicit variables"></a>implicit variables</h3><p>There are a set of implicit variables defined in make:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS</span><br><span class="line">CC</span><br><span class="line">CXX</span><br><span class="line">and etc..</span><br></pre></td></tr></table></figure>
<p>These variables can be referred without declaring them and the default value will be passed. If needed they can be overridden by declaring them as a regular variable.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">code_file1.o: code_file1.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c code_file1.c -o code_file1.o</span><br></pre></td></tr></table></figure>
<p><a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">List of implicit variables</a></p>
<h3 id="pass-command-line-arguments"><a href="#pass-command-line-arguments" class="headerlink" title="pass command line arguments"></a>pass command line arguments</h3><p>We can pass command line arguments when using make to alter the compilation.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MY_VAL = %d\n&quot;</span>, MY_VAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main:main.c</span></span><br><span class="line">	gcc <span class="variable">$(CFLAGS)</span> main.c -o main</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm main</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make CFLAGS=-DMY_VAL=3</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">MY_VAL = 3</span><br></pre></td></tr></table></figure>
<p>如何在程序中确定make指令有没有指定MY_VAL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MY_VAL</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>It won’t compile without the argument.</li>
</ul>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>Signals are events created by UNIX and Linux systems and are a method for the OS to communicate with a process. They can be acted upon or ignored.</p>
<ul>
<li>A method of interprocess communication</li>
<li>Are the result of some condition</li>
<li>Allow the process receiving the signal to take an action through a signal handler</li>
</ul>
<p>Provide a process a notification of an event.</p>
<ul>
<li><p>Event gains attention of the OS.</p>
</li>
<li><p>OS stops the application process immediately, sending it a signal.</p>
</li>
<li><p>Signal handler is executed.</p>
</li>
<li><p>Application process resumes where it left of.</p>
</li>
</ul>
<p><strong>Raise</strong></p>
<p>The generation of a signal upon a process.</p>
<p><strong>Catch</strong></p>
<p>The reception of a signal by that process.</p>
<p><strong>Handle</strong></p>
<p>How the program reacts to the signal.</p>
<h4 id="Conditions-for-signals"><a href="#Conditions-for-signals" class="headerlink" title="Conditions for signals"></a>Conditions for signals</h4><ul>
<li><p>Error conditions such as：</p>
<p>Memory segment violations</p>
<p>Floating-point processor errors</p>
<p>Illegal instructions</p>
</li>
<li><p>Explicitly sent from one process to another as a method of Inter-process communication</p>
<p>example:</p>
</li>
<li><p>Process makes illegal memory reference</p>
<p>Event gains attention of the OS.</p>
<p>OS stops application process immediately, sending it a SIGSEGV signal.</p>
<p>Signal handler for SIGSEGV signal executes to completion.</p>
<p>Default signal handler for SIGSEGV signal prints “Segmentation Fault” and exits process.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SIGINT Terminal interrupt</span><br><span class="line">SIGKILL <span class="keyword">Kill</span> process</span><br><span class="line">SIGSEGV Invalid <span class="keyword">memory</span> <span class="keyword">segment</span> <span class="keyword">access</span></span><br></pre></td></tr></table></figure></li>
<li><p>Signals can be raised using a few different methods</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Keystrokes</span></span><br><span class="line"><span class="attribute">Commands</span></span><br><span class="line"><span class="attribute">System calls</span></span><br></pre></td></tr></table></figure></li>
<li>Keystrokes</li>
</ul>
<p>​     <strong>CTRL + C</strong> -&gt; SIGINT</p>
<p>​     Default handler exits process.</p>
<p>​     <strong>CTRL + Z</strong> -&gt; SIGTSTP</p>
<p>​     Default handler suspends process.(进程暂停)</p>
<p>​     <strong>CTRL + \</strong> -&gt; SIGQUIT</p>
<p>​     Default handler exits process</p>
<ul>
<li><p>Sending signals via command</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">kill -<span class="keyword">signal</span><span class="string"> pid</span></span><br></pre></td></tr></table></figure>
<p>Send a signal of type signal to the process with id pid.</p>
<p>The kill command can send all signals</p>
<p>e.g.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -2 1234</span><br><span class="line">$ <span class="built_in">kill</span> -INT 1234</span><br></pre></td></tr></table></figure></li>
<li><p>System calls</p>
<p><strong>kill()</strong></p>
<p>Commands the OS to send a signal to the process, must have permission.</p>
<p>Both processes must have the same user ID.(具有相同的用户id)</p>
<p>Superuser can send signal to any process(超级用户可以向任何进程发送信号)</p>
<p>==Return value==:</p>
<p>Success: 0</p>
<p>Error: -1 (errno is set appropriately)</p>
<p>EINVAL if invalid</p>
<p>EPERM if no permission</p>
<p>ESRCH if specified process does not exist</p>
<p><strong>raise()</strong></p>
<p>Commands the OS to send a signal to current process</p>
<p><strong>alarm()</strong></p>
<p>Schedule a SIGALRM at some time in future.</p>
<p>Processing delays and scheduling uncertainties.</p>
<p>Value of 0 cancels any outstanding alarm request.</p>
<p>Each process can have only one outstanding alarm.</p>
<p>Calling alarm before signal is received will cause alarm to be rescheduled.</p>
</li>
</ul>
<h3 id="how-to-handle-signal"><a href="#how-to-handle-signal" class="headerlink" title="how to handle signal"></a>how to handle signal</h3><p>  <strong>signal()</strong></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">Void (*signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>  signal() returns a function which is the previous value of the function set up to handle the signal.</p>
<p>  OR one of these two special values:</p>
<p>  SIG_IGN – Ignore the signal</p>
<p>  SIG_DFL – Restore default behavior</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ouch</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(“OUCH – I got signal %d\n”, sig);</span><br><span class="line"> (<span class="keyword">void</span>) signal(SIGINT, SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> (<span class="keyword">void</span>) signal(SIGINT, ouch);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(“Hello World!\n”);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>Waiting for signal</strong></p>
<p>  <strong>pause()</strong></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Causes program to suspend execution until a signal occurs.</p>
</li>
<li><p>When it receives a signal, any established handler is run and execution </p>
<p>continues as normal.</p>
</li>
</ul>
<p><strong>Re-entrant Functions</strong></p>
<ul>
<li><p>That can be interrupted in the middle of execution and then safely called again (“re-entered”) before its previous invocations complete execution.</p>
</li>
<li><p>Never call a non-reentrant function inside a signal handler, if the function was being ran the behaviour will be changed.</p>
</li>
<li><p>Example if a global was used as a temporary value, and gets overwritten in </p>
<p>the signal handler</p>
</li>
</ul>
<p><strong>Race conditions</strong></p>
<ul>
<li><p>A flaw in a program whereby the correctness of the program is critically </p>
<p>dependent on the sequence or timing of other events</p>
</li>
<li><p>Example: a signal handler and function modifying the same value</p>
</li>
<li><p>Race conditions Example</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//deposit is running and is interrupted by a signal after copying savings to temp.</span></span><br><span class="line">savings = <span class="number">5000</span>, value = <span class="number">2000</span></span><br><span class="line"><span class="keyword">int</span> savings; <span class="comment">// 5000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="comment">// 2000</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = savings;</span><br><span class="line">---- Signal</span><br><span class="line">temp += val;</span><br><span class="line">savings = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">salary</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">savings += <span class="number">5000</span>; <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>POSIX Signal Handling</strong></p>
</li>
</ul>
<p><strong>C90 standard</strong></p>
<p>signal() and raise() functions</p>
<p>Works across all systems (UNIX, Linux, Windows)</p>
<p>But differently across some systems</p>
<p>Blocked signals during handler execution</p>
<p>Reinstall handler after every signal invocation</p>
<p>Does not provide mechanism to block signals</p>
<p><strong>POSIX standard</strong></p>
<p>sigaction() and sigprocmask() functions:</p>
<p>Works the same across all POSIX-compliant UNIX systems (Linux, Solaris etc) but…</p>
<p>Do not work on non-UNIX systems (e.g. Windows)</p>
<p>Provides mechanism to block signals in general</p>
<p>sigprocmask() is not required to use sigaction()</p>
<p><strong>sigaction()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span></span>;</span><br></pre></td></tr></table></figure>
<p>struct sigaction has at least</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*) (<span class="keyword">int</span>) sa_handler <span class="comment">// function, SIG_DFL, SIG_IGN</span></span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask <span class="comment">// signals to block in sa_handler</span></span><br><span class="line"><span class="keyword">int</span> sa_flags <span class="comment">// signal action modifiers</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> stop = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"> stop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"> sa.sa_flags = <span class="number">0</span>; <span class="comment">// no flags</span></span><br><span class="line"> sigemptyset(&amp;sa.sa_mask); <span class="comment">// clear the mask so no signals are blocked</span></span><br><span class="line"> sa.sa_handler = handler; <span class="comment">// set function pointer for handler</span></span><br><span class="line"> sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>); <span class="comment">// set the handler</span></span><br><span class="line"> <span class="keyword">while</span>(!stop) &#123;</span><br><span class="line"> ;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>setjmp &amp; longjmp</strong></p>
<ul>
<li><p>setjmp and longjmp are two flow control subroutines.</p>
</li>
<li><p>When setjmp is called, it saves the program state at that point and returns 0.</p>
</li>
<li><p>When longjmp is called, it returns from the place where the jump is set with the given value.</p>
</li>
<li><p>If you are jumping from a signal handler, you might need to used <strong>sigsetjmp</strong> and <strong>siglongjmp</strong> instead setjmp and longjmp due to signal mask issues. </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> jmp_buf env;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> i = setjmp(env);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"> <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> longjmp(env, <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;I will never be printed!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setjmp</code> 與 <code>longjmp</code> 函數可以讓程式往回跳到函數呼叫堆疊中的某個函數中，就像是一種跨函數的 <code>goto</code>。</p>
<p>首先使用 <code>setjmp</code> 在程式中標示一個目標位置（跳躍的目的地），然後在程式要進行跳躍的地方呼叫 <code>longjmp</code> 即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 儲存程式跳躍時所需之資訊</span></span><br><span class="line">jmp_buf jmpbuffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_a</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = v * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 跳躍至 main 函數</span></span><br><span class="line">    longjmp(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_b</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = fun_a(v) + <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">if</span> (r &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 跳躍至 main 函數</span></span><br><span class="line">    longjmp(jmpbuffer, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun_c</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = fun_b(v) * <span class="number">5</span> - <span class="number">21</span>;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 設定跳躍目標位置</span></span><br><span class="line">  <span class="keyword">int</span> jmpVal = setjmp(jmpbuffer);</span><br><span class="line">  <span class="keyword">if</span> ( jmpVal == <span class="number">1</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun_a errorn&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( jmpVal == <span class="number">2</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun_b errorn&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// jmpVal == 0</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">-5</span>;</span><br><span class="line">    <span class="keyword">int</span> result = fun_c(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result = %dn&quot;</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 <code>setjmp</code> 設定跳躍目標位置時，會需要指定一個特殊的 <code>jmp_buf</code> 變數，用來儲存程式跳躍時所需之資訊，而在直接呼叫 <code>setjmp</code> 函數時其傳回值為 <code>0</code>，若是透過 <code>longjmp</code> 跳回這裡時，其傳回值就會是呼叫 <code>longjmp</code> 時所指定的值.</p>
<ul>
<li><p>What if you want to handle a signal multiple times in your program?</p>
</li>
<li><p>Do not use setjmp() and longjmp().</p>
</li>
<li><p>setjmp() does not save the signal mask.</p>
</li>
<li><p>The first SIGSEGV is added to the process’ signal mask to prevent subsequent signals interrupting the handler</p>
</li>
<li><p>When setjmp() pseudo returns, that mask is still there.</p>
</li>
<li><p>use sigsetjmp() and siglongjmp()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savemask)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> val)</span></span></span><br></pre></td></tr></table></figure>
<p>If savemask is set to 1, it saves the signal mask and siglongjmp restores the saved signal mask.</p>
</li>
<li><p>What is saved in sigjmp_buf?</p>
<p><strong>Program Counter</strong></p>
<p>Location in the code</p>
<p><strong>Stack pointer</strong></p>
<p>Locations of local variables</p>
<p>Return address of called functions</p>
<p><strong>Signal Mask</strong> </p>
<p> If specified</p>
<p><strong>Rest of environment (CPU state)</strong></p>
<p>Calculations can continue from where they stopped</p>
</li>
<li><p>What is NOT saved in sigjmp_buf?</p>
<p>Global variables</p>
<p>Variables allocated dynamically</p>
<p>Values of local variables</p>
<p>Any other global resources</p>
</li>
<li><p>What does it mean by scanning the memory?</p>
<p>Simply, you can try to access memory locations in a loop, using pointer dereferencing</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="number">0xff13abc1</span>;</span><br><span class="line"><span class="keyword">char</span> a = *p;</span><br></pre></td></tr></table></figure></li>
<li><p>How do we know where the process’ address space starts and ends?</p>
<p>0x0 to 0xffffffff (2^32-1)</p>
<p>This is organized into pages of 4096 bytes (or other defined size in the assignment)</p>
</li>
<li><p>How do we check a page’s permissions?</p>
<p>Try reading/writing to it and see what’s the response from OS.</p>
<p>If two consecutive pages have the same permissions, they are part of the same “mem_region”</p>
<p>When you try to write to memory, write the same content to avoid modifying it</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 111</title>
    <url>/2021/01/09/AtCoderRegularContest111/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://atcoder.jp/contests/arc111/tasks">AtCoder Regular Contest 111</a></p>
<img src="/2021/01/09/AtCoderRegularContest111/new-year-5798330__340.png" class="">
<p>感觉BC写得有点复杂<br><a id="more"></a></p>
<h2 id="A-Simple-Math-2"><a href="#A-Simple-Math-2" class="headerlink" title="A - Simple Math 2"></a>A - Simple Math 2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;x);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans = (ans*a)%y;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a*a)%y;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line">    sc(N) sc(M)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;qp(N,M*M)/M &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Reversible-Cards"><a href="#B-Reversible-Cards" class="headerlink" title="B - Reversible Cards"></a>B - Reversible Cards</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;x);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; sx,sy;</span><br><span class="line">P A[<span class="number">200005</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">400005</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">400006</span>];</span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    sc(N)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        sc(x)sc(y)</span><br><span class="line">        A[i].fi = x;</span><br><span class="line">        A[i].se = y;</span><br><span class="line">        mp[x]+=<span class="number">1</span>;</span><br><span class="line">        mp[y] += <span class="number">1</span>;</span><br><span class="line">        G[x].push(i);</span><br><span class="line">        G[y].push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: mp)&#123;</span><br><span class="line">        pq.push(&#123;x.second,x.first&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        P a = pq.top();pq.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[a.second])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> g = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!G[a.second].empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> id = G[a.second].front();</span><br><span class="line">                G[a.second].pop();</span><br><span class="line">                <span class="keyword">if</span>(!f[id])&#123;</span><br><span class="line">                    f[id] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(A[id].se != a.second)&#123;</span><br><span class="line">                        mp[A[id].se] -= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(!vis[A[id].se])</span><br><span class="line">                        pq.push(&#123;mp[A[id].se],A[id].se&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        mp[A[id].fi] -= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(!vis[A[id].fi])</span><br><span class="line">                        pq.push(&#123;mp[A[id].fi],A[id].fi&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    g = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g)</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            vis[a.second] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Too-Heavy"><a href="#C-Too-Heavy" class="headerlink" title="C - Too Heavy"></a>C - Too Heavy</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;x);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[C[x]])<span class="keyword">return</span> x;</span><br><span class="line">    fa[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> min(x,dfs(C[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    <span class="keyword">if</span>(fa[C[x]] == y)<span class="keyword">return</span>;</span><br><span class="line">    dfs1(C[x],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sc(N)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)sc(A[i])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) sc(B[i])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)sc(C[i])</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= B[C[i]]&amp;&amp;C[i]!=i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[B[C[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(C[i] == i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(fa[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> y = dfs(i);</span><br><span class="line">        dfs1(i,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i])&#123;</span><br><span class="line">            G[fa[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; ans;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[i].size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq.empty())pq.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : G[i])&#123;</span><br><span class="line">                pq.push(&#123;B[x],x&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(pq.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                P a = pq.top();pq.pop();</span><br><span class="line">                <span class="keyword">int</span> w = mp[a.first]; <span class="comment">///在哪？</span></span><br><span class="line">                <span class="keyword">int</span> v = a.second;<span class="comment">///给谁</span></span><br><span class="line"> </span><br><span class="line">                C[w] = C[v];</span><br><span class="line">                mp[B[C[w]]] = w;</span><br><span class="line">                C[v] = v;</span><br><span class="line">                ans.push_back(&#123;w,v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : ans)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.fi &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; a.se &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>多终端操作</title>
    <url>/2020/12/19/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="将博客内容上传github"><a href="#将博客内容上传github" class="headerlink" title="将博客内容上传github"></a>将博客内容上传github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;blog source&quot;</span></span><br><span class="line">// 新建hexo分支</span><br><span class="line">git branch hexo</span><br><span class="line">// 切换分支</span><br><span class="line">git checkout hexo</span><br><span class="line">// 将本地与Github项目对接</span><br><span class="line">git remote add origin git@github.com:liulx20/liulx20.github.io.git</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>tips: theme/next似乎传不上去,直接拷到新终端==</li>
</ul>
<h2 id="新终端完成clone-更新"><a href="#新终端完成clone-更新" class="headerlink" title="新终端完成clone,更新"></a>新终端完成clone,更新</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo git@github.com:liulx20/liulx20.github.io.git  </span><br><span class="line">// 新建一个.md文件,并编辑完成自己的博客内容</span><br><span class="line">hexo new post <span class="string">&quot;new blog name&quot;</span></span><br><span class="line">// 经测试每次只要更新<span class="built_in">source</span>中的文件到Github中即可,因为只是新建了一篇新博客</span><br><span class="line">git add <span class="built_in">source</span></span><br><span class="line">git commit -m <span class="string">&quot;XX&quot;</span></span><br><span class="line">// 推送到远程仓库,更新hexo分支</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<ul>
<li>若出现fatal: in unpopulated submodule ‘deploy_git’<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf .deploy_git</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="不同终端更新"><a href="#不同终端更新" class="headerlink" title="不同终端更新"></a>不同终端更新</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 先pull完成本地与远端的融合</span><br><span class="line">git pull origin hexo</span><br><span class="line">hexo new post <span class="string">&quot; new blog name&quot;</span></span><br><span class="line">git add <span class="built_in">source</span></span><br><span class="line">git commit -m <span class="string">&quot;XX&quot;</span></span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>关于本站</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树&amp;&amp;随机森林</title>
    <url>/2020/12/19/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>机器学习小作业。</p>
<img src="/2020/12/19/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/forest-6240706.jpg" class="">
<a id="more"></a>
<p>本文实现了决策树和随机森林算法。</p>
<p>简单的、仅针对二分类问题实现。</p>
<h2 id="C4-5决策树"><a href="#C4-5决策树" class="headerlink" title="C4.5决策树"></a>C4.5决策树</h2><p>C++实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; train;</span><br><span class="line"><span class="comment">//std::vector&lt;int&gt; train_Y;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; test_X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            ans.push_back(a);</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a = a*<span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(a);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_train</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    in &gt;&gt; str;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; str)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = splitString(str);</span><br><span class="line">        <span class="comment">//train_Y.push_back(v[(size_t)(v.size()-1)]);</span></span><br><span class="line">        <span class="comment">//v.pop_back();</span></span><br><span class="line">        train.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    in &gt;&gt; str;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; str)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = splitString(str);</span><br><span class="line">        test_X.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> col;<span class="comment">/*按照第几列进行划分*/</span></span><br><span class="line">   <span class="keyword">int</span> pos;<span class="comment">/*该节点正样本个数*/</span></span><br><span class="line">   <span class="keyword">int</span> neg;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,struct Tree *&gt; &gt; subT;</span><br><span class="line">   <span class="comment">/*划分得到的子树*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> * <span class="title">root</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; split(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;vec,<span class="keyword">int</span> col,<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;  v : vec)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[col] == val)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(v)</span></span>;</span><br><span class="line">            t.erase(t.begin()+col);</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Gini</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> y = vec[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : vec)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[y] == <span class="number">1</span>)&#123;</span><br><span class="line">            a ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> s = vec.size();</span><br><span class="line">    <span class="keyword">double</span> ans = (a*a + (s-a)*(s-a))*<span class="number">1.</span>/(s*s);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">nlog</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*规定x == 0时,xlog2(x) 为0*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x) &lt; <span class="number">1e-9</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x*log2(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算信息增益比*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">G</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; vec, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> D = (<span class="keyword">int</span>)(vec.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : vec)&#123;</span><br><span class="line">        mp[v[col]] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(v[vec[<span class="number">0</span>].size()<span class="number">-1</span>])</span><br><span class="line">            p[v[col]] += <span class="number">1</span>,pos += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> x =  pos*<span class="number">1.</span>/D,ans,y = <span class="number">0</span>,z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> hd = -(nlog(x) + nlog(<span class="number">1</span>-x));</span><br><span class="line">    <span class="keyword">double</span> ha = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : mp)&#123;</span><br><span class="line">        x = p[a.first]*<span class="number">1.</span>/a.second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        z = a.second *<span class="number">1.</span>/D;</span><br><span class="line">        y -= z*(nlog(x) + nlog(<span class="number">1</span>-x));</span><br><span class="line">        ha -= nlog(z);</span><br><span class="line">    &#125;</span><br><span class="line">    hd -= y;</span><br><span class="line">    <span class="keyword">return</span> hd/ha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*建树*/</span></span><br><span class="line"><span class="function">struct Tree* <span class="title">build</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; train)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> * <span class="title">root</span> =</span> <span class="keyword">new</span> Tree();</span><br><span class="line"></span><br><span class="line">    root-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    root-&gt;neg = (<span class="keyword">int</span>)train.size();</span><br><span class="line">    root-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> y = train[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:train)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[y] == <span class="number">1</span>)&#123;</span><br><span class="line">            root-&gt;pos ++;</span><br><span class="line">            root-&gt;neg --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(train.size() == <span class="number">1</span>)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> mG = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*取信息增益比最大的特征对子树进行划分*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; train[<span class="number">0</span>].size() <span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> g = G(train,i);</span><br><span class="line">        <span class="keyword">if</span>(g &gt; mG)&#123;</span><br><span class="line">            mG = g;</span><br><span class="line">            col = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;col = col;</span><br><span class="line">    <span class="keyword">if</span>(mG &gt; <span class="number">0.0000001</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : train)&#123;</span><br><span class="line">           st.insert(v[col]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : st)&#123;</span><br><span class="line">          root-&gt;subT.push_back(&#123;a,build(split(train,col,a))&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(struct Tree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;struct Tree*,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123;root,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;struct Tree*,<span class="keyword">int</span>&gt; p = q.front();q.pop();</span><br><span class="line">        <span class="keyword">if</span>(l == p.second<span class="number">-1</span>)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;l+=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt; p.first-&gt;pos &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.first-&gt;neg  &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;  a : p.first-&gt;subT)&#123;</span><br><span class="line">            q.push(&#123;a.second,p.second+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">predict</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,struct Tree * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;subT.size() == <span class="number">0</span>)<span class="keyword">return</span> root-&gt;pos*<span class="number">1.</span>/(root-&gt;pos+root-&gt;neg);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(vec)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = root-&gt;subT.size();</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;subT[<span class="number">0</span>].first &gt;= v[root-&gt;col])&#123;</span><br><span class="line">        v.erase(v.begin()+root-&gt;col);</span><br><span class="line">        <span class="keyword">return</span> predict(v,root-&gt;subT[<span class="number">0</span>].second);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; len <span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;subT[i].first == v[root-&gt;col])&#123;</span><br><span class="line">               v.erase(v.begin()+root-&gt;col);</span><br><span class="line">                <span class="keyword">return</span> predict(v,root-&gt;subT[i].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v.erase(v.begin()+root-&gt;col);</span><br><span class="line">        <span class="keyword">return</span> predict(v,root-&gt;subT[len - <span class="number">1</span>].second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read_train(<span class="string">&quot;train.csv&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; train_,test_;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : train)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand()%<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">30</span>)&#123;</span><br><span class="line">            test_.push_back(v);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            train_.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = build(train);</span><br><span class="line">    bfs(root);</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; root-&gt;pos &lt;&lt;&quot; &quot;&lt;&lt; root-&gt;neg &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : test_)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predict(v,root)&gt;<span class="number">0.5</span> &amp;&amp; v[v.size()<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(predict(v,root)&lt;<span class="number">0.5</span> &amp;&amp; v[v.size()<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accuracy:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a*<span class="number">1.</span>/test_.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    read_test(<span class="string">&quot;test.csv&quot;</span>);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;submission.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; test_X.size();i++)&#123;</span><br><span class="line">        out &lt;&lt; predict(test_X[i],root) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>在上面实现的决策树基础上，根据bagging原理，实现了随机森林。</p>
<p>每次从容量为n的样本集中有放回抽取n个样本，从特征集合中抽取m个特征，建立决策树。</p>
<p>每个决策树预测的概率求和，取算术平均作为随机森林预测结果。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; train;</span><br><span class="line"><span class="comment">//std::vector&lt;int&gt; train_Y;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; test_X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            ans.push_back(a);</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = a * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(a);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_train</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;file)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    in &gt;&gt; str;</span><br><span class="line">    <span class="keyword">while</span> (in &gt;&gt; str) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = splitString(str);</span><br><span class="line">        <span class="comment">//train_Y.push_back(v[(size_t)(v.size()-1)]);</span></span><br><span class="line">        <span class="comment">//v.pop_back();</span></span><br><span class="line">        train.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_test</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;file)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    in &gt;&gt; str;</span><br><span class="line">    <span class="keyword">while</span> (in &gt;&gt; str) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = splitString(str);</span><br><span class="line">        test_X.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">int</span> neg;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, struct Tree *&gt; &gt; subT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; split(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;vec, <span class="keyword">int</span> col, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : vec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[col] == val) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(v)</span></span>;</span><br><span class="line">            t.erase(t.begin() + col);</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">nlog</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; <span class="number">1e-9</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x * log2(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">G</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;vec, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> D = (<span class="keyword">int</span>) (vec.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : vec) &#123;</span><br><span class="line">        mp[v[col]] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (v[vec[<span class="number">0</span>].size() - <span class="number">1</span>])</span><br><span class="line">            p[v[col]] += <span class="number">1</span>, pos += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> x = pos * <span class="number">1.</span> / D, y = <span class="number">0</span>, z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> hd = -(nlog(x) + nlog(<span class="number">1</span> - x));</span><br><span class="line">    <span class="keyword">double</span> ha = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : mp) &#123;</span><br><span class="line">        x = p[a.first] * <span class="number">1.</span> / a.second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        z = a.second * <span class="number">1.</span> / D;</span><br><span class="line">        y -= z * (nlog(x) + nlog(<span class="number">1</span> - x));</span><br><span class="line">        ha -= nlog(z);</span><br><span class="line">    &#125;</span><br><span class="line">    hd -= y;</span><br><span class="line">    <span class="keyword">return</span> hd / ha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Tree *<span class="title">build</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; train)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> *<span class="title">root</span> =</span> <span class="keyword">new</span> Tree();</span><br><span class="line"></span><br><span class="line">    root-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    root-&gt;neg = (<span class="keyword">int</span>) train.size();</span><br><span class="line">    root-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> y = train[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v:train) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[y] == <span class="number">1</span>) &#123;</span><br><span class="line">            root-&gt;pos++;</span><br><span class="line">            root-&gt;neg--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (train.size() == <span class="number">1</span>)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> mG = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; train[<span class="number">0</span>].size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> g = G(train, i);</span><br><span class="line">        <span class="keyword">if</span> (g &gt; mG) &#123;</span><br><span class="line">            mG = g;</span><br><span class="line">            col = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;col = col;</span><br><span class="line">    <span class="keyword">if</span> (mG &gt; <span class="number">0.000001</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : train) &#123;</span><br><span class="line">            st.insert(v[col]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : st) &#123;</span><br><span class="line">            root-&gt;subT.push_back(&#123;a, build(split(train, col, a))&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">predict</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, struct Tree *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;subT.size() == <span class="number">0</span>)<span class="keyword">return</span> root-&gt;pos * <span class="number">1.</span> / (root-&gt;pos + root-&gt;neg);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(vec)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = root-&gt;subT.size();</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;subT[<span class="number">0</span>].first &gt;= v[root-&gt;col]) &#123;</span><br><span class="line">        v.erase(v.begin() + root-&gt;col);</span><br><span class="line">        <span class="keyword">return</span> predict(v, root-&gt;subT[<span class="number">0</span>].second);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;subT[i].first == v[root-&gt;col]) &#123;</span><br><span class="line">                v.erase(v.begin() + root-&gt;col);</span><br><span class="line">                <span class="keyword">return</span> predict(v, root-&gt;subT[i].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v.erase(v.begin() + root-&gt;col);</span><br><span class="line">        <span class="keyword">return</span> predict(v, root-&gt;subT[len - <span class="number">1</span>].second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; resampling(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;train) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">size_t</span> n = train.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans.push_back(train[rand() % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; selectFeature(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;train) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; train[<span class="number">0</span>].size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        col.push_back(rand() % <span class="number">10000</span>);</span><br><span class="line">        idx.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(idx.begin(), idx.end(), [=](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> col[a] &lt; col[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (idx.size() &gt; <span class="number">28</span>)idx.pop_back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : train) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : idx) &#123;</span><br><span class="line">            vec.push_back(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.push_back(v[v.size() - <span class="number">1</span>]);</span><br><span class="line">        ans.push_back(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;ans, idx&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; select(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;test, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;col) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : test) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : col) &#123;</span><br><span class="line">            vec.push_back(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//33</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">33</span>;</span><br><span class="line">    read_train(<span class="string">&quot;train.csv&quot;</span>);</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt;train.size()&lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; train_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">    <span class="comment">/*for(auto &amp; v : train)&#123;</span></span><br><span class="line"><span class="comment">        int x = rand()%100;</span></span><br><span class="line"><span class="comment">        if(x &lt; 30)&#123;</span></span><br><span class="line"><span class="comment">            test_.push_back(v);</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            train_.push_back(v);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; col;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;struct Tree *&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        train_ = resampling(train);</span><br><span class="line"></span><br><span class="line">        p = selectFeature(train_);</span><br><span class="line">        train_ = p.first;</span><br><span class="line">        col.push_back(p.second);</span><br><span class="line">        root.push_back(build(train_));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;棵决策树生成完成&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    read_test(<span class="string">&quot;test.csv&quot;</span>);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;submission.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(test_X.size())</span></span>;</span><br><span class="line">    fill(ans.begin(), ans.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; test = select(test_X, col[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v :col[i]) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; test.size(); j++) &#123;</span><br><span class="line">            ans[j] += predict(test[j], root[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root[i]-&gt;pos &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; root[i]-&gt;neg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: ans) &#123;</span><br><span class="line">        out &lt;&lt; x * <span class="number">1.</span> / N &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-hw</title>
    <url>/2020/08/27/haskell-hw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>homework of CIS194</p>
<h2 id="hw1"><a href="#hw1" class="headerlink" title="hw1"></a><a href="https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf">hw1</a></h2><a id="more"></a>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Exercise 01</span></span><br><span class="line"><span class="title">toDigits</span> :: <span class="type">Integer</span> -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">toDigits</span> x</span><br><span class="line">   | x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span> = [x]</span><br><span class="line">   | x &gt; <span class="number">10</span> = toDigits (x `div` <span class="number">10</span>) ++ [x `mod` <span class="number">10</span>]</span><br><span class="line">   | otherwise = []</span><br><span class="line"></span><br><span class="line"><span class="title">toDigitsRev</span> :: <span class="type">Integer</span> -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">toDigitsRev</span> x</span><br><span class="line">   | x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span> = [x]</span><br><span class="line">   | x &gt; <span class="number">10</span> = (x `mod` <span class="number">10</span>):toDigitsRev(x `div` <span class="number">10</span>)</span><br><span class="line">   | otherwise = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 02</span></span><br><span class="line"><span class="title">len</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">len</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">len</span> (_:y) = <span class="number">1</span> + len(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">doubleEveryOther</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">doubleEveryOther</span> [] = []</span><br><span class="line"><span class="title">doubleEveryOther</span> (x:[])= [x]</span><br><span class="line"><span class="title">doubleEveryOther</span> (x:y:z)= <span class="keyword">if</span>(len(z) `mod` <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">then</span> (x*<span class="number">2</span> : y : doubleEveryOther(z)) <span class="keyword">else</span> (x:y*<span class="number">2</span>:doubleEveryOther(z))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 3</span></span><br><span class="line"><span class="title">sumDigit</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumDigit</span> x</span><br><span class="line">    | x &lt; <span class="number">10</span>  = x</span><br><span class="line">    | otherwise = (x `mod` <span class="number">10</span>) + sumDigit (x `div` <span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="title">sumDigits</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sumDigits</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sumDigits</span> (x:y) = sumDigit(x) + sumDigits(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 4</span></span><br><span class="line"><span class="title">validate</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">validate</span> num</span><br><span class="line">   | sumDigits(doubleEveryOther(toDigits(num))) `mod` <span class="number">10</span> == <span class="number">0</span> = <span class="type">True</span></span><br><span class="line">   | otherwise = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 5</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Peg</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Move</span> = (<span class="type">Peg</span>, <span class="type">Peg</span>)</span></span><br><span class="line"><span class="title">hanoi</span> :: <span class="type">Integer</span> -&gt; <span class="type">Peg</span> -&gt; <span class="type">Peg</span> -&gt; <span class="type">Peg</span> -&gt; [<span class="type">Move</span>]</span><br><span class="line"><span class="title">hanoi</span> n a b c</span><br><span class="line">     | n == <span class="number">1</span> = [(a,b)]</span><br><span class="line">     | otherwise = (hanoi (n<span class="number">-1</span>) a c b) ++ [(a,b)] ++ (hanoi (n<span class="number">-1</span>) c b a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 6</span></span><br><span class="line"></span><br><span class="line"><span class="title">len2</span> :: [<span class="type">Move</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">len2</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">len2</span> (_:y) = <span class="number">1</span> + len2 y</span><br><span class="line"></span><br><span class="line"><span class="title">hanoi2</span> :: <span class="type">Integer</span> -&gt; <span class="type">Peg</span> -&gt; <span class="type">Peg</span> -&gt; <span class="type">Peg</span> -&gt; <span class="type">Peg</span> -&gt; [<span class="type">Move</span>]</span><br><span class="line"><span class="title">hanoi2</span> n a b c d</span><br><span class="line">     | n == <span class="number">1</span> = [(a,b)]</span><br><span class="line">     | n == <span class="number">2</span> = [(a,d),(a,b),(d,b)]</span><br><span class="line">     | otherwise = (hanoi2 (n<span class="number">-2</span>) a c b d) ++[(a,d),(a,b),(d,b)] ++ (hanoi2 (n<span class="number">-2</span>) c b a d)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a><a href="https://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf">hw2</a></h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -Wall #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> LogAnalysis <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Log</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 1</span></span><br><span class="line"></span><br><span class="line"><span class="title">parseMessage</span> :: <span class="type">String</span> -&gt; <span class="type">LogMessage</span></span><br><span class="line"><span class="title">parseMessage</span> msg</span><br><span class="line">      |msg!!<span class="number">0</span> == &#x27;<span class="type">I&#x27;</span> = <span class="type">LogMessage</span> <span class="type">Info</span> (read ((words msg)!!<span class="number">1</span>)::<span class="type">Int</span>)  (unwords(drop <span class="number">2</span> (words msg)))</span><br><span class="line">      |msg!!<span class="number">0</span> == &#x27;<span class="type">W&#x27;</span> = <span class="type">LogMessage</span> <span class="type">Warning</span> (read ((words msg)!!<span class="number">1</span>)::<span class="type">Int</span>)  (unwords(drop <span class="number">2</span>(words msg)))</span><br><span class="line">      |msg!!<span class="number">0</span> == &#x27;<span class="type">E&#x27;</span> = <span class="type">LogMessage</span> (<span class="type">Error</span> (read ((words msg)!!<span class="number">1</span>)::<span class="type">Int</span>)) (read ((words msg)!!<span class="number">2</span>)::<span class="type">Int</span>)  (unwords(drop <span class="number">3</span> (words msg)))</span><br><span class="line">      |otherwise = <span class="type">Unknown</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">parse</span> :: <span class="type">String</span> -&gt; [<span class="type">LogMessage</span>]</span><br><span class="line"><span class="title">parse</span> msg</span><br><span class="line">     |msg == <span class="string">&quot;&quot;</span> = []</span><br><span class="line">     |otherwise = [parseMessage ((lines msg)!!<span class="number">0</span>)] ++ parse(unlines(tail(lines msg)))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 2</span></span><br><span class="line"></span><br><span class="line"><span class="title">insert</span> :: <span class="type">LogMessage</span> -&gt; <span class="type">MessageTree</span> -&gt; <span class="type">MessageTree</span></span><br><span class="line"><span class="title">insert</span> (<span class="type">Unknown</span> _) t = t</span><br><span class="line"><span class="title">insert</span> (<span class="type">LogMessage</span> a b c) (<span class="type">Node</span> x (<span class="type">LogMessage</span> w y v) z) = <span class="keyword">if</span> b &lt; y <span class="keyword">then</span> <span class="type">Node</span> (insert (<span class="type">LogMessage</span> a b c) x) (<span class="type">LogMessage</span> w y v) z</span><br><span class="line">                                                              <span class="keyword">else</span> <span class="type">Node</span> x (<span class="type">LogMessage</span> w y v) (insert (<span class="type">LogMessage</span> a b c) z)</span><br><span class="line"><span class="title">insert</span> (<span class="type">LogMessage</span> a b c) <span class="type">Leaf</span> = <span class="type">Node</span> <span class="type">Leaf</span> (<span class="type">LogMessage</span> a b c) <span class="type">Leaf</span></span><br><span class="line"><span class="title">insert</span> (<span class="type">LogMessage</span> a b c) _ = <span class="type">Node</span> <span class="type">Leaf</span> (<span class="type">LogMessage</span> a b c) <span class="type">Leaf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 3</span></span><br><span class="line"></span><br><span class="line"><span class="title">build</span> :: [<span class="type">LogMessage</span>] -&gt; <span class="type">MessageTree</span></span><br><span class="line"><span class="title">build</span> [] = <span class="type">Leaf</span></span><br><span class="line"><span class="title">build</span> (x:y) = insert x (build y)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 4</span></span><br><span class="line"></span><br><span class="line"><span class="title">inOrder</span> :: <span class="type">MessageTree</span> -&gt; [<span class="type">LogMessage</span>]</span><br><span class="line"><span class="title">inOrder</span> <span class="type">Leaf</span> = []</span><br><span class="line"><span class="title">inOrder</span> (<span class="type">Node</span> x y z) = inOrder x ++ [y] ++ inOrder z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 5</span></span><br><span class="line"><span class="title">select</span> :: [<span class="type">LogMessage</span>] -&gt; [<span class="type">LogMessage</span>]</span><br><span class="line"><span class="title">select</span> [] = []</span><br><span class="line"><span class="title">select</span> ((<span class="type">LogMessage</span> (<span class="type">Error</span> x) y z) : w) = <span class="keyword">if</span> x &gt; <span class="number">50</span> <span class="keyword">then</span> [(<span class="type">LogMessage</span> (<span class="type">Error</span> x) y z)] ++ (select w) <span class="keyword">else</span> (select w)</span><br><span class="line"><span class="title">select</span> (_:y) = select y</span><br><span class="line"></span><br><span class="line"><span class="title">getMsg</span>::[<span class="type">LogMessage</span>] -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="title">getMsg</span> [] = []</span><br><span class="line"><span class="title">getMsg</span> ((<span class="type">LogMessage</span> _ _ z):w) = [z] ++ (getMsg w)</span><br><span class="line"><span class="title">getMsg</span> _ = []</span><br><span class="line"></span><br><span class="line"><span class="title">whatWentWrong</span> :: [<span class="type">LogMessage</span>] -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="title">whatWentWrong</span> msg = (getMsg (inOrder(build(select msg))))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a><a href="https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf">hw3</a></h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Exercise 1 Hopscotch</span></span><br><span class="line"></span><br><span class="line"><span class="title">sk</span>::<span class="type">Int</span>-&gt;<span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">sk</span> n x ls</span><br><span class="line">    | n + x &gt; length(ls) = [ls !! (x<span class="number">-1</span>)]</span><br><span class="line">    | otherwise = [ls !! (x<span class="number">-1</span>)]  ++ (sk n (x+n) ls)</span><br><span class="line"></span><br><span class="line"><span class="title">skip</span>::<span class="type">Int</span>-&gt;[a] -&gt; [[a]]</span><br><span class="line"><span class="title">skip</span> n ls</span><br><span class="line">     | n == length(ls) = [(sk n n ls)]</span><br><span class="line">     | otherwise = [(sk n n ls)] ++ (skip (n+<span class="number">1</span>) ls)</span><br><span class="line"></span><br><span class="line"><span class="title">skips</span> :: [a] -&gt; [[a]]</span><br><span class="line"><span class="title">skips</span> [] = []</span><br><span class="line"><span class="title">skips</span> ls = (skip <span class="number">1</span> ls)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 2 Local maxima</span></span><br><span class="line"><span class="title">getMax</span> :: <span class="type">Integer</span> -&gt; [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">getMax</span> _ [] = []</span><br><span class="line"><span class="title">getMax</span> _ [x] = []</span><br><span class="line"><span class="title">getMax</span> a (x:y:z) =  <span class="keyword">if</span> (x &gt; a  &amp;&amp;  x &gt; y) <span class="keyword">then</span> [x] ++ (getMax x (y:z)) <span class="keyword">else</span> (getMax x (y:z))</span><br><span class="line"></span><br><span class="line"><span class="title">localMaxima</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">localMaxima</span> [] = []</span><br><span class="line"><span class="title">localMaxima</span> ls = getMax (ls !! <span class="number">0</span>) ls</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 3 Histogram</span></span><br><span class="line"><span class="title">count</span> :: <span class="type">Integer</span> -&gt; [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">count</span> <span class="number">10</span> _ = []</span><br><span class="line"><span class="title">count</span> n ls = [(toInteger(length(filter ( == n) ls)))] ++ (count (n+<span class="number">1</span>) ls)</span><br><span class="line"></span><br><span class="line"><span class="title">line</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">line</span> [] = <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="title">line</span> (x:y) = <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="string">&quot;*&quot;</span> ++ line(y) <span class="keyword">else</span> <span class="string">&quot; &quot;</span> ++ line(y)</span><br><span class="line"></span><br><span class="line"><span class="title">sub</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sub</span> x = x - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">toString</span>::[<span class="type">Integer</span>] -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">toString</span> ls</span><br><span class="line">     |(length(filter (&gt; <span class="number">0</span>) ls)) == <span class="number">0</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">     |otherwise = toString(map sub ls) ++ line(ls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">histogram</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">histogram</span> ls = (toString(count <span class="number">0</span> ls) ++ <span class="string">&quot;0123456789\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="hw4"><a href="#hw4" class="headerlink" title="hw4"></a><a href="https://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf">hw4</a></h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Exercise 1: Wholemeal programming</span></span><br><span class="line"><span class="title">fun1</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fun1</span> [] = <span class="number">1</span></span><br><span class="line"><span class="title">fun1</span> (x:xs)</span><br><span class="line">    |even x = (x - <span class="number">2</span>) * fun1 xs</span><br><span class="line">    |otherwise = fun1 xs</span><br><span class="line"></span><br><span class="line"><span class="title">fun1&#x27;</span> :: [<span class="type">Integer</span>]-&gt;<span class="type">Integer</span></span><br><span class="line"><span class="title">fun1&#x27;</span> = product.map (\x-&gt; x<span class="number">-2</span>).filter even</span><br><span class="line"></span><br><span class="line"><span class="title">fun2</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fun2</span> <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fun2</span> n | even n = n + fun2 (n `div` <span class="number">2</span>)</span><br><span class="line">       | otherwise = fun2 (<span class="number">3</span> * n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">fun2&#x27;</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fun2&#x27;</span>  = sum.filter even.takeWhile (&gt;<span class="number">1</span>).iterate(\x -&gt; <span class="keyword">if</span> even x <span class="keyword">then</span> (x `div` <span class="number">2</span>) <span class="keyword">else</span> (<span class="number">3</span>*x + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 2:Folding with trees</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Leaf</span></span></span><br><span class="line">            | <span class="type">Node</span> <span class="type">Integer</span> (<span class="type">Tree</span> a) a (<span class="type">Tree</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">foldTree</span> :: [a] -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">foldTree</span> = foldr insertNode <span class="type">Leaf</span></span><br><span class="line"></span><br><span class="line"><span class="title">insertNode</span> :: a -&gt; <span class="type">Tree</span> a -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">insertNode</span> x <span class="type">Leaf</span> = <span class="type">Node</span> <span class="number">0</span> <span class="type">Leaf</span> x <span class="type">Leaf</span></span><br><span class="line"><span class="title">insertNode</span> x (<span class="type">Node</span> h ln y rn)</span><br><span class="line">  | treeHeight ln &lt; treeHeight rn =</span><br><span class="line">    <span class="keyword">let</span> nn = insertNode x ln</span><br><span class="line">    <span class="keyword">in</span> <span class="type">Node</span> (treeHeight nn + <span class="number">1</span>) nn y rn</span><br><span class="line">  | otherwise =</span><br><span class="line">    <span class="keyword">let</span> nn = insertNode x rn</span><br><span class="line">    <span class="keyword">in</span> <span class="type">Node</span> (treeHeight nn + <span class="number">1</span>) ln y nn</span><br><span class="line"></span><br><span class="line"><span class="title">treeHeight</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">treeHeight</span> <span class="type">Leaf</span> = <span class="number">-1</span></span><br><span class="line"><span class="title">treeHeight</span> (<span class="type">Node</span> h _ _ _) = h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 3: More folds!</span></span><br><span class="line"><span class="title">xor</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">xor</span> = foldr (\x y -&gt; <span class="keyword">if</span> ((x == <span class="type">True</span> &amp;&amp; y == <span class="type">False</span>) || (x == <span class="type">False</span> &amp;&amp; y == <span class="type">True</span>)) <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> <span class="type">False</span>) <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map&#x27;</span> f = foldr (\x y -&gt; [f(x)] ++ y) []</span><br><span class="line"></span><br><span class="line"><span class="title">myFoldl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><br><span class="line"><span class="title">myFoldl</span> f base xs = foldr (flip f) base (reverse xs)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 4:Finding primes</span></span><br><span class="line"><span class="title">cartProd</span> :: [a] -&gt; [b] -&gt; [(a, b)]</span><br><span class="line"><span class="title">cartProd</span> xs ys = [(x,y) | x &lt;- xs, y &lt;- ys]</span><br><span class="line"></span><br><span class="line"><span class="title">sieveSundaram</span> :: <span class="type">Integer</span> -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">sieveSundaram</span> n = map (\x -&gt; x*<span class="number">2</span> + <span class="number">1</span>) (filter (\x -&gt; notElem x (map (\(i,j) -&gt; <span class="number">2</span>*i*j + i + j) (filter (\(i,j)-&gt;<span class="number">2</span>*i*j+i+j &lt;= n) (cartProd [<span class="number">1.</span>.n] [<span class="number">1.</span>.n]))))  [<span class="number">1.</span>.n])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a><a href="https://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf">hw5</a></h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeSynonymInstances #-&#125;</span></span><br><span class="line"><span class="keyword">import</span> ExprT</span><br><span class="line"><span class="keyword">import</span> Parser</span><br><span class="line"><span class="keyword">import</span> StackVM</span><br><span class="line"><span class="keyword">import</span> Data.Maybe</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> M</span><br><span class="line"><span class="comment">-- Exercise 1</span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">ExprT</span>-&gt;<span class="type">Integer</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">ExprT</span>.<span class="type">Lit</span> x) = x</span><br><span class="line"><span class="title">eval</span> (<span class="type">ExprT</span>.<span class="type">Add</span> x y) = eval x + eval y</span><br><span class="line"><span class="title">eval</span> (<span class="type">ExprT</span>.<span class="type">Mul</span> x y) = eval x * eval y</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 2</span></span><br><span class="line"><span class="title">evalStr</span> :: <span class="type">String</span> -&gt; <span class="type">Maybe</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">evalStr</span> str</span><br><span class="line">    |(parseExp <span class="type">ExprT</span>.<span class="type">Lit</span> <span class="type">ExprT</span>.<span class="type">Add</span> <span class="type">ExprT</span>.<span class="type">Mul</span> str == <span class="type">Nothing</span>) = <span class="type">Nothing</span></span><br><span class="line">    |otherwise = <span class="type">Just</span>(eval (fromJust(parseExp <span class="type">ExprT</span>.<span class="type">Lit</span> <span class="type">ExprT</span>.<span class="type">Add</span> <span class="type">ExprT</span>.<span class="type">Mul</span> str)))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Expr</span> a <span class="keyword">where</span></span></span><br><span class="line">   lit :: <span class="type">Integer</span> -&gt; a</span><br><span class="line">   add :: a -&gt; a -&gt; a</span><br><span class="line">   mul :: a -&gt; a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> <span class="type">ExprT</span> <span class="keyword">where</span></span></span><br><span class="line">   lit = <span class="type">ExprT</span>.<span class="type">Lit</span></span><br><span class="line">   add = <span class="type">ExprT</span>.<span class="type">Add</span></span><br><span class="line">   mul = <span class="type">ExprT</span>.<span class="type">Mul</span></span><br><span class="line"></span><br><span class="line"><span class="title">reify</span> :: <span class="type">ExprT</span> -&gt; <span class="type">ExprT</span></span><br><span class="line"><span class="title">reify</span> = id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Exercise 4</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> <span class="type">Integer</span> <span class="keyword">where</span></span></span><br><span class="line">    lit  a =  a</span><br><span class="line">    add a b = a + b</span><br><span class="line">    mul a b = a*b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">     lit a = (<span class="keyword">if</span> a &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> <span class="type">False</span>)</span><br><span class="line">     add a b = a || b</span><br><span class="line">     mul a b = a &amp;&amp; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">MinMax</span> = <span class="type">MinMax</span> <span class="type">Integer</span> <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> <span class="type">MinMax</span> <span class="keyword">where</span></span></span><br><span class="line">      lit x = <span class="type">MinMax</span> x</span><br><span class="line">      add (<span class="type">MinMax</span> a) (<span class="type">MinMax</span> b) = <span class="type">MinMax</span>(max a b)</span><br><span class="line">      mul (<span class="type">MinMax</span> a) (<span class="type">MinMax</span> b) = <span class="type">MinMax</span>(min a b)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Mod7</span> = <span class="type">Mod7</span> <span class="type">Integer</span> <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> <span class="type">Mod7</span> <span class="keyword">where</span></span></span><br><span class="line">     lit  x = <span class="type">Mod7</span>(x `mod` <span class="number">7</span>)</span><br><span class="line">     add (<span class="type">Mod7</span> a) (<span class="type">Mod7</span> b) = <span class="type">Mod7</span>((a + b) `mod` <span class="number">7</span>)</span><br><span class="line">     mul (<span class="type">Mod7</span> a) (<span class="type">Mod7</span> b) = <span class="type">Mod7</span>((a*b) `mod` <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">testExp</span> :: <span class="type">Expr</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">testExp</span> = parseExp lit add mul <span class="string">&quot;(3 * -4) + 5&quot;</span></span><br><span class="line"><span class="title">testInteger</span> = testExp :: <span class="type">Maybe</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">testBool</span> = testExp :: <span class="type">Maybe</span> <span class="type">Bool</span></span><br><span class="line"><span class="title">testMM</span> = testExp :: <span class="type">Maybe</span> <span class="type">MinMax</span></span><br><span class="line"><span class="title">testSat</span> = testExp :: <span class="type">Maybe</span> <span class="type">Mod7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- exercise 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> <span class="type">Program</span> <span class="keyword">where</span></span></span><br><span class="line">    lit x = [<span class="type">PushI</span> x]</span><br><span class="line">    add a b = a ++ b ++ [<span class="type">StackVM</span>.<span class="type">Add</span>]</span><br><span class="line">    mul a b = a ++ b ++ [<span class="type">StackVM</span>.<span class="type">Mul</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">compile</span>:: <span class="type">String</span> -&gt; <span class="type">Maybe</span> <span class="type">Program</span></span><br><span class="line"><span class="title">compile</span> str = parseExp lit add mul str :: <span class="type">Maybe</span> <span class="type">Program</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- exercise 6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">HasVars</span> a <span class="keyword">where</span></span></span><br><span class="line">        var :: <span class="type">String</span> -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">VarExprT</span> = <span class="type">Lit</span> <span class="type">Integer</span></span></span><br><span class="line">                | <span class="type">Var</span> <span class="type">String</span></span><br><span class="line">                | <span class="type">Add</span> <span class="type">VarExprT</span> <span class="type">VarExprT</span></span><br><span class="line">                | <span class="type">Mul</span> <span class="type">VarExprT</span> <span class="type">VarExprT</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">HasVars</span> (<span class="type">M</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Integer</span> -&gt; <span class="type">Maybe</span> <span class="type">Integer</span>) <span class="keyword">where</span></span></span><br><span class="line">        var = <span class="type">M</span>.lookup</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expr</span> (<span class="type">M</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Integer</span> -&gt; <span class="type">Maybe</span> <span class="type">Integer</span>) <span class="keyword">where</span></span></span><br><span class="line">        lit int0 _ = <span class="type">Just</span> int0</span><br><span class="line">        add var0 var1 map0 = <span class="keyword">do</span> int0 &lt;- var0 map0</span><br><span class="line">                                int1 &lt;- var1 map0</span><br><span class="line">                                return (int0 + int1)</span><br><span class="line">        mul var0 var1 map0 = <span class="keyword">do</span> int0 &lt;- var0 map0</span><br><span class="line">                                int1 &lt;- var1 map0</span><br><span class="line">                                return (int0 * int1)</span><br><span class="line"></span><br><span class="line"><span class="title">withVars</span> :: [(<span class="type">String</span>, <span class="type">Integer</span>)]</span><br><span class="line">            -&gt; (<span class="type">M</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Integer</span> -&gt; <span class="type">Maybe</span> <span class="type">Integer</span>)</span><br><span class="line">            -&gt; <span class="type">Maybe</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">withVars</span> vs ex = ex $ <span class="type">M</span>.fromList vs</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">          print $ withVars [(<span class="string">&quot;x&quot;</span>, <span class="number">6</span>)] $ add (lit <span class="number">3</span>) (var <span class="string">&quot;x&quot;</span>)</span><br><span class="line">          print $ withVars [(<span class="string">&quot;x&quot;</span>, <span class="number">6</span>)] $ add (lit <span class="number">3</span>) (var <span class="string">&quot;y&quot;</span>)</span><br><span class="line">          print $ withVars  [(<span class="string">&quot;x&quot;</span>, <span class="number">6</span>), (<span class="string">&quot;y&quot;</span>, <span class="number">3</span>)] $ mul (var <span class="string">&quot;x&quot;</span>) (add (var <span class="string">&quot;y&quot;</span>) (var <span class="string">&quot;x&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell</title>
    <url>/2020/08/27/haskell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Introduction-to-Haskell"><a href="#Introduction-to-Haskell" class="headerlink" title="Introduction to Haskell"></a>Introduction to Haskell</h2><ul>
<li><p>Functions are first-class, that is, functions are values which can be used in exactly the same ways as any other sort of value.</p>
</li>
<li><p>The meaning of Haskell programs is centered around evaluating expressions rather than executing instructions.</p>
<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install haskell-<span class="built_in">platform</span></span><br></pre></td></tr></table></figure>
<p>开启交互模式</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ghci</span></span><br></pre></td></tr></table></figure>
<p><code>Ctrl + z</code> 退出交互模式</p>
</li>
</ul>
<p>导入<code>test.hs</code>文件<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:l</span> <span class="selector-tag">test</span><span class="selector-class">.hs</span></span><br></pre></td></tr></table></figure></p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>GHCi is an interactive Haskell REPL (Read-Eval-Print-Loop) that comes with GHC. At the GHCi prompt, you can evaluate expressions, load Haskell files with :load (:l) (and reload them with :reload (:r)), ask for the type of an expression with :type (:t), and many other things (try :? for a list of commands).<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ex01</span> = <span class="number">3</span> + <span class="number">2</span></span><br><span class="line"><span class="attribute">ex02</span> = <span class="number">8</span> / <span class="number">2</span> --(<span class="number">4</span>.<span class="number">0</span>)</span><br><span class="line"><span class="attribute">ex03</span> = mod <span class="number">19</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">ex04</span> = <span class="number">19</span> `mod` <span class="number">3</span></span><br><span class="line"><span class="attribute">ex05</span> = <span class="number">7</span> ^ <span class="number">222</span></span><br><span class="line"><span class="attribute">ex06</span> = (-<span class="number">3</span>) * (-<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>backticks</code> make a function name into an infix operator.</li>
<li>negative numbers must often be surrounded by parentheses, to avoid having the negation sign parsed as subtraction.</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- badArith1 = i + n</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Addition is only between values of the same numeric type, Haskell does not do implicit conversion,you must explicitly convert with:</p>
<p>fromIntegral: converts from any integral type (Int or Integer) to any other numeric type.</p>
<p>round, floor, ceiling: convert floating-point numbers to Int or Integer.</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- badArith2 = i / i</span></span><br></pre></td></tr></table></figure></li>
<li>This is an error since / performs floating-point division only. For integer division we can use div.<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">ex07 = i `div` i</span><br></pre></td></tr></table></figure>
<h3 id="Boolean-logic"><a href="#Boolean-logic" class="headerlink" title="Boolean logic"></a>Boolean logic</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ex08</span> = <span class="literal">True</span> &amp;&amp; <span class="literal">False</span></span><br><span class="line"><span class="attr">ex09</span> = not (<span class="literal">False</span> || <span class="literal">True</span>)</span><br><span class="line"><span class="attr">ex10</span> = <span class="number">2</span> /= <span class="number">3</span> (/= 不等于)</span><br></pre></td></tr></table></figure></li>
<li><code>if-expressions</code>: if b then t else f</li>
</ul>
<p>the else part is required for an if-expression, since the if-expression must result in some value. </p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul>
<li>function application has higher precedence than any infix operators</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">hello1 :: [Char]</span><br><span class="line">hello1 = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"></span><br><span class="line">hello2 :: String</span><br><span class="line">hello2 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">helloSame = hello1 == hello2</span><br></pre></td></tr></table></figure>
<h2 id="Algebraic-Data-Types"><a href="#Algebraic-Data-Types" class="headerlink" title="Algebraic Data Types"></a>Algebraic Data Types</h2><h3 id="Enumeration-types"><a href="#Enumeration-types" class="headerlink" title="Enumeration types"></a>Enumeration types</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">data Thing = Shoe </span><br><span class="line">           | <span class="type">Ship</span> </span><br><span class="line">           | <span class="type">SealingWax</span> </span><br><span class="line">           | <span class="type">Cabbage</span> </span><br><span class="line">           | <span class="type">King</span></span><br><span class="line">  deriving <span class="keyword">Show</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The deriving Show is a magical incantation which tells GHC to automatically generate default code for converting Things to Strings.<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shoe </span>:: Thing</span><br><span class="line"><span class="keyword">shoe </span>= <span class="keyword">Shoe</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">listO&#x27;Things </span>:: [Thing]</span><br><span class="line">listO<span class="string">&#x27;Things = [Shoe, SealingWax, King, Cabbage, King]</span></span><br></pre></td></tr></table></figure></li>
<li>We can write functions on Things by pattern-matching.<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">isSmall ::</span> <span class="string">Thing</span> <span class="string">-&gt;</span> <span class="string">Bool</span></span><br><span class="line"><span class="string">isSmall</span> <span class="string">Shoe</span>       <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">isSmall</span> <span class="string">Ship</span>       <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"><span class="string">isSmall</span> <span class="string">SealingWax</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">isSmall</span> <span class="string">Cabbage</span>    <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="string">isSmall</span> <span class="string">King</span>       <span class="string">=</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
or<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">isSmall2 ::</span> <span class="string">Thing</span> <span class="string">-&gt;</span> <span class="string">Bool</span></span><br><span class="line"><span class="string">isSmall2</span> <span class="string">Ship</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"><span class="string">isSmall2</span> <span class="string">King</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"><span class="string">isSmall2</span> <span class="string">_</span>    <span class="string">=</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="Beyond-enumerations"><a href="#Beyond-enumerations" class="headerlink" title="Beyond enumerations"></a>Beyond enumerations</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FailableDouble</span> = <span class="type">Failure</span></span></span><br><span class="line">                    | <span class="type">OK</span> <span class="type">Double</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ex01</span> = Failure</span><br><span class="line"><span class="attr">ex02</span> = OK <span class="number">3.4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">safeDiv :: Double -&gt; Double -&gt; FailableDouble</span><br><span class="line">safeDiv _ <span class="number">0</span> = Failure</span><br><span class="line">safeDiv <span class="symbol">x</span> <span class="symbol">y</span> = OK (<span class="symbol">x</span> / <span class="symbol">y</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">failureToZero :: FailableDouble -&gt; Double</span><br><span class="line">failureToZero Failure = 0</span><br><span class="line">failureToZero (OK d)  = d</span><br></pre></td></tr></table></figure></li>
<li>Data constructors can have more than one argument.<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">-- Store a <span class="keyword">person</span>&#x27;s name, age, and favourite <span class="keyword">Thing</span>.</span><br><span class="line">data <span class="keyword">Person</span> = <span class="keyword">Person</span> String Int <span class="keyword">Thing</span></span><br><span class="line">  deriving Show</span><br><span class="line"></span><br><span class="line">brent :: <span class="keyword">Person</span></span><br><span class="line">brent = <span class="keyword">Person</span> <span class="string">&quot;Brent&quot;</span> 31 SealingWax</span><br><span class="line"></span><br><span class="line">stan :: <span class="keyword">Person</span></span><br><span class="line">stan  = <span class="keyword">Person</span> <span class="string">&quot;Stan&quot;</span> 94 Cabbage</span><br><span class="line"></span><br><span class="line">getAge :: <span class="keyword">Person</span> -&gt; Int</span><br><span class="line">getAge (<span class="keyword">Person</span> _ a _) = a</span><br></pre></td></tr></table></figure></li>
<li>the type constructor and data constructor are both named Person.</li>
</ul>
<h3 id="Algebraic-data-types-in-general"><a href="#Algebraic-data-types-in-general" class="headerlink" title="Algebraic data types in general"></a>Algebraic data types in general</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">data AlgDataType = Co<span class="symbol">nstr1</span> Type<span class="number">11</span> Type<span class="number">12</span></span><br><span class="line">                 | Co<span class="symbol">nstr2</span> Type<span class="number">21</span></span><br><span class="line">                 | Co<span class="symbol">nstr3</span> Type<span class="number">31</span> Type<span class="number">32</span> Type<span class="number">33</span></span><br><span class="line">                 | Co<span class="symbol">nstr4</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>This specifies that a value of type AlgDataType can be constructed in one of four ways.</p>
</li>
<li><p>type and data constructor names must always start with a capital letter; variables (including names of functions) must always start with a lowercase letter.</p>
</li>
</ul>
<h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern-matching"></a>Pattern-matching</h3><p>We could write something like<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">foo <span class="comment">(Constr1 a b)</span>   = ...</span><br><span class="line">foo <span class="comment">(Constr2 a)</span>     = ...</span><br><span class="line">foo <span class="comment">(Constr3 a b c)</span> = ...</span><br><span class="line">foo Co<span class="symbol">nstr4</span>         = ...</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>parentheses are required around patterns consisting of more than just a single constructor.</p>
</li>
<li><p>An underscore _ can be used as a “wildcard pattern” which matches anything.</p>
</li>
<li><p>A pattern of the form x@pat can be used to match a value against the pattern pat, but also give the name x to the entire value being matched. For example:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">baz </span>:: Person -&gt; String</span><br><span class="line"><span class="keyword">baz </span>p@(Person n _ _) = <span class="string">&quot;The name field of (&quot;</span> ++ <span class="keyword">show </span>p ++ <span class="string">&quot;) is &quot;</span> ++ n</span><br><span class="line"></span><br><span class="line">*Main&gt; <span class="keyword">baz </span><span class="keyword">brent</span></span><br><span class="line"><span class="keyword">&quot;The </span>name field of (Person \<span class="string">&quot;Brent\&quot; 31 SealingWax) is Brent&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串用++连接</p>
</li>
<li><p>Patterns can be nested. For example:</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">checkFav <span class="symbol">:</span><span class="symbol">:</span> Person -&gt; String</span><br><span class="line">checkFav (Person <span class="built_in">n</span> _ SealingWax) = <span class="built_in">n</span> ++ <span class="string">&quot;, you&#x27;re my kind of person!&quot;</span></span><br><span class="line">checkFav (Person <span class="built_in">n</span> _ _)          = <span class="built_in">n</span> ++ <span class="string">&quot;, your favorite thing is lame.&quot;</span></span><br><span class="line"></span><br><span class="line">*Main&gt; checkFav brent</span><br><span class="line"><span class="string">&quot;Brent, you&#x27;re my kind of person!&quot;</span></span><br><span class="line">*Main&gt; checkFav stan</span><br><span class="line"><span class="string">&quot;Stan, your favorite thing is lame.&quot;</span></span><br></pre></td></tr></table></figure>
<p>In general, the following grammar defines what can be used as a pattern:</p>
</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">pat ::= _</span><br><span class="line">     |  <span class="keyword">var</span></span><br><span class="line">     |  <span class="keyword">var</span> @ ( pat )</span><br><span class="line">     |  ( <span class="function"><span class="keyword">Constructor</span> <span class="title">pat1</span> <span class="title">pat2</span> ... <span class="title">patn</span> )</span></span><br></pre></td></tr></table></figure>
<h3 id="Case-expressions"><a href="#Case-expressions" class="headerlink" title="Case expressions"></a>Case expressions</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">case <span class="built_in">exp</span> of</span><br><span class="line">  <span class="function"><span class="title">pat1</span> -&gt;</span> exp1</span><br><span class="line">  <span class="function"><span class="title">pat2</span> -&gt;</span> exp2</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>like this:<br><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">ex03 = <span class="keyword">case</span> <span class="string">&quot;Hello&quot;</span> <span class="keyword">of</span></span><br><span class="line">           []      -&gt; <span class="number">3</span></span><br><span class="line">           <span class="function"><span class="params">(<span class="string">&#x27;H&#x27;</span>:s)</span> -&gt;</span> length s</span><br><span class="line">           _       -&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Recursive-data-types"><a href="#Recursive-data-types" class="headerlink" title="Recursive data types"></a>Recursive data types</h3><ul>
<li>A list is either empty, or a single element followed by a remaining list.</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> IntList = Empty | Cons <span class="built_in">Int</span> IntList</span><br></pre></td></tr></table></figure>
<ul>
<li>Use recursive functions to process recursive data types.<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>ListProd :: IntList -&gt; Int</span><br><span class="line"><span class="built_in">int</span>ListProd Empty      = <span class="number">1</span></span><br><span class="line"><span class="built_in">int</span>ListProd (Cons x l) = x * <span class="built_in">int</span>ListProd l</span><br></pre></td></tr></table></figure></li>
<li>we can define a type of binary trees with an Int value stored at each internal node, and a Char stored at each leaf:<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">data Tree = Leaf Char</span><br><span class="line">          | <span class="keyword">Node</span> <span class="title">Tree</span> Int Tree</span><br><span class="line">  deriving Show</span><br></pre></td></tr></table></figure>
<h2 id="Haskell-Prelude-function"><a href="#Haskell-Prelude-function" class="headerlink" title="Haskell Prelude function"></a>Haskell Prelude function</h2></li>
</ul>
<h3 id="乘方函数"><a href="#乘方函数" class="headerlink" title="乘方函数"></a>乘方函数</h3><ul>
<li>^ 的底数可为小数，也可为整数，指数是正整数；</li>
<li>^^ 的底数是小数，指数是任意整数；</li>
<li>** 的底数和指数都是小数)</li>
</ul>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><ul>
<li>signum 取符号 <code>signum (-3) == -1</code></li>
<li>negate 相反数 <code>negate (-1) == 1</code></li>
<li>abs 绝对值 </li>
<li>recip 倒数</li>
<li>floor 向下取整</li>
<li>ceiling 向上取整</li>
<li>round 四舍五入</li>
<li>truncate 取整</li>
<li>exp e的次幂</li>
<li>subtract 减去 <code>subtract 3 5 == 2</code></li>
<li>gcd lcm</li>
<li>sqrt</li>
<li>max min</li>
<li>compare 比较 <code>compare 3 5 == LT</code> <code>compare 5 3 == GT</code> <code>compare 5 5 == EQ</code></li>
</ul>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><ul>
<li>pi</li>
<li>sin cos</li>
<li>tan </li>
<li>asin acos</li>
<li>atan atan2</li>
<li>sinh cosh tanh asinh acosh atanh</li>
</ul>
<h3 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h3><ul>
<li>log     exp为底</li>
<li>logBase <code>logBase 10 10 == 1.0</code></li>
</ul>
<h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><ul>
<li>odd even</li>
</ul>
<h3 id="pair函数"><a href="#pair函数" class="headerlink" title="pair函数"></a>pair函数</h3><ul>
<li>fst snd</li>
</ul>
<h3 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h3><ul>
<li>(!!) 获取列表第几个元素 <code>[0,1,2,3] !! 1 == 1</code></li>
<li>lookup <code>lookup 2 [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]== &#39;b&#39;</code> 获取列表中第一个元素为2的元组中第二个元素</li>
<li>elem notElem 判断元素是否在列表中 <code>elem 2 [1,2,3] == True</code></li>
<li>null 判断列表是否为空 <code>null [] == True</code></li>
<li>and or 用于Bool列表 <code>and [False,True,True] == False</code></li>
<li>all any 判断列表是否所有(存在)元素满足条件 <code>all even [2,3,4] == False</code></li>
<li>(++) 列表连接</li>
<li>length 求列表长度</li>
<li>head 列表第一个元素</li>
<li>tail 取列表除了第一个元素的所有元素</li>
<li>last 取列表最后一个元素</li>
<li>init 取列表除最后一个元素</li>
<li>reverse 列表反转</li>
<li>cycle 反复出现列表</li>
<li>repeat 反复出现某一值</li>
<li>replicate 重复出现某一值一定次数 <code>replicate 3 1 == [1,1,1]</code></li>
<li>take <code>take 2 [1, 2, 3, 4] == [1,2]</code> 取列表前两个元素</li>
<li>drop <code>drop 2 [1, 2, 3, 4] == [3,4]</code> 去除列表前两个元素</li>
<li>splitAt <code>splitAt 1 [1,2,3,4] == ([1],[2,3,4])</code>分割列表</li>
<li>takeWhile <code>takeWhile even [2, 4, 5] == [2,4]</code> <code>takeWhile odd [2, 4, 5] == []</code> 获取满足某一条件的前几个元素</li>
<li>dropWhile <code>dropWhile odd [2, 4, 5] == [5]</code> <code>dropWhile odd [2, 4, 5] == [2,4,5]</code>丢弃满足某一条件的前几个元素</li>
<li>span <code>span even [2, 4, 5] == ([2,4],[5])</code> 分割列表，规则同 takeWhile</li>
<li>break <code>break odd [2, 4, 5] == ([2,4],[5])</code>分割列表，规则同 dropWhile</li>
<li>maximum 列表最大元素</li>
<li>minimum</li>
<li>sum</li>
<li>product 列表元素乘积</li>
<li>enumFrom <code>enumFrom 2 == [2,3,4,...]</code></li>
<li>enumFromThen <code>enumFromThen 5 3 == [5,3,1,-1,...]</code></li>
<li>enumFromThenTo <code>enumFromThenTo 5 3 1 == [5,3,1]</code></li>
<li>enumFromTo <code>enumFromTo 3 5 == [3,4,5]</code> <code>enumFromTo 3 1 == []</code></li>
<li>show <code>show [2,3] == &quot;[2,3]&quot;</code> <code>show &quot;2&quot; == &quot;\&quot;2\&quot;&quot;</code></li>
<li>read <code>read &quot;233&quot;::Int == 233</code> <code>read &quot;12&quot;::Double == 12.0</code></li>
<li>iterate creates an infinite list where the first item is calculated by applying the function on the second argument, the second item by applying the function on the previous result and so on.<br><code>take 4 (iterate (2*) 1) == [1,2,4,8]</code> <code>take 4 (iterate (\x -&gt; (x+3)*2) 1) == [1,8,22,50]</code></li>
<li>until applies a function which is passed as the second argument to the third argument and it comapares the result with the condition, if the condition evaluates to True, it prints the result, if not, it passes the result to the finction and repeats the cycle as long as the condition is matched<br><code>until (&gt; 100) (*2) 1 == 128</code> <code>until odd (</code>div<code>2) 400 == 25</code></li>
<li>zip <code>zip [1, 2] [4, 5] = [(1,4),(2,5)]</code></li>
<li>zip3 <code>zip3 [1, 2] [4, 5] [7, 8] = [(1,4,7),(2,5,8)]</code></li>
<li>zipWith <code>zipWith (+) [1, 2, 3] [4, 5, 6] = [5,7,9]</code></li>
<li>zipWith3 <code>zipWith3 (\x y z -&gt; x + y + z) [1, 2, 3] [4, 5, 6] [7, 8, 9] == [12,15,18]</code></li>
<li>unzip <code>unzip [(1, 4), (2, 5), (3, 6)] == ([1,2,3],[4,5,6])</code></li>
<li>unzip3 <code>unzip3 [(1, 4, 7), (2, 5, 8), (3, 6, 9)] == ([1,2,3],[4,5,6],[7,8,9])</code></li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>lines 分割行 <code>lines &quot;abc\n123\ndef\n&quot; == [&quot;abc&quot;,&quot;123&quot;,&quot;def&quot;]</code></li>
<li>words 分割单词 <code>words &quot;abc\n123 def\t&quot; == [&quot;abc&quot;,&quot;123&quot;,&quot;def&quot;]</code></li>
<li>unlines 合并行 <code>unlines [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] == &quot;a\nb\nc\n&quot;</code></li>
<li>unwords 合并单词 <code>unwords [&quot;a&quot;,&quot;b&quot;] == &quot;a b&quot;</code></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>(.) 函数复合 (f.g) x == f(g x)</li>
<li>($) apply 函数，通常是为了省写括号<br><code>(map Char.toUpper . filter Char.isLower) &quot;ABCdef&quot; == &quot;DEF&quot;</code><br><code>map Char.toUpper . filter Char.isLower $ &quot;ABCdef&quot; == &quot;DEF&quot;</code></li>
</ul>
<h2 id="Recursion-patterns-polymorphism-and-the-Prelude"><a href="#Recursion-patterns-polymorphism-and-the-Prelude" class="headerlink" title="Recursion patterns, polymorphism, and the Prelude"></a>Recursion patterns, polymorphism, and the Prelude</h2><h3 id="Recursion-patterns"><a href="#Recursion-patterns" class="headerlink" title="Recursion patterns"></a>Recursion patterns</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">ls</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">addOne <span class="attr">x</span> = x+<span class="number">1</span></span><br><span class="line"><span class="built_in">map</span> addOne ls</span><br></pre></td></tr></table></figure>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>When we want to keep only some elements of a list, and throw others away, based on a test.</p>
<h4 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h4><p>“summarize” the elements of the list</p>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><h4 id="Polymorphic-data-types"><a href="#Polymorphic-data-types" class="headerlink" title="Polymorphic data types"></a>Polymorphic data types</h4><p>First, let’s see how to declare a polymorphic data type.<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> t = <span class="type">E</span> | <span class="type">C</span> t (<span class="type">List</span> <span class="title">t</span>)</span></span><br></pre></td></tr></table></figure><br>非泛型<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntList</span> = <span class="type">Empty</span> | <span class="type">Cons</span> <span class="type">Int</span> <span class="type">IntList</span></span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>We have data List t = … The t is a type variable which can stand for any type. </li>
<li>data List t = … means that the List type is parameterized by a type, in much the same way that a function can be parameterized by some input.<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">lst1</span> <span class="operator">::</span> <span class="built_in">List</span> <span class="variable">Int</span></span><br><span class="line"><span class="variable">lst1</span> <span class="operator">=</span> <span class="built_in">C</span> <span class="number">3</span> <span class="punctuation">(</span><span class="built_in">C</span> <span class="number">5</span> <span class="punctuation">(</span><span class="built_in">C</span> <span class="number">2</span> <span class="built_in">E</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">lst2</span> <span class="operator">::</span> <span class="built_in">List</span> <span class="variable">Char</span></span><br><span class="line"><span class="variable">lst2</span> <span class="operator">=</span> <span class="built_in">C</span> <span class="operator">&#x27;</span><span class="variable">x</span><span class="operator">&#x27;</span> <span class="punctuation">(</span><span class="built_in">C</span> <span class="operator">&#x27;</span><span class="variable">y</span><span class="operator">&#x27;</span> <span class="punctuation">(</span><span class="built_in">C</span> <span class="operator">&#x27;</span><span class="variable">z</span><span class="operator">&#x27;</span> <span class="built_in">E</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">lst3</span> <span class="operator">::</span> <span class="built_in">List</span> <span class="variable">Bool</span></span><br><span class="line"><span class="variable">lst3</span> <span class="operator">=</span> <span class="built_in">C</span> <span class="built_in">True</span> <span class="punctuation">(</span><span class="built_in">C</span> <span class="built_in">False</span> <span class="built_in">E</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h4 id="Polymorphic-functions"><a href="#Polymorphic-functions" class="headerlink" title="Polymorphic functions"></a>Polymorphic functions</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">filterList</span> :: (t -&gt; <span class="type">Bool</span>) -&gt; <span class="type">List</span> t -&gt; <span class="type">List</span> t    </span><br><span class="line"><span class="title">filterList</span> _ <span class="type">E</span> = <span class="type">E</span></span><br><span class="line"><span class="title">filterList</span> p (<span class="type">C</span> x xs)</span><br><span class="line">  | p x       = <span class="type">C</span> x (filterList p xs)</span><br><span class="line">  | otherwise = filterList p xs</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">mapList</span> :: (a -&gt; b) -&gt; <span class="type">List</span> a -&gt; <span class="type">List</span> b</span><br><span class="line"><span class="title">mapList</span> _ <span class="type">E</span>        = <span class="type">E</span></span><br><span class="line"><span class="title">mapList</span> f (<span class="type">C</span> x xs) = <span class="type">C</span> (f x) (mapList f xs)</span><br></pre></td></tr></table></figure>
<h3 id="The-Prelude"><a href="#The-Prelude" class="headerlink" title="The Prelude"></a>The Prelude</h3></li>
</ul>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br></pre></td></tr></table></figure>
<ul>
<li>A value of type Maybe a either contains a value of type a (wrapped in the Just constructor), or it is Nothing (representing some sort of failure or error). The Data.Maybe module has functions for working with Maybe values.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">maybe</span> <span class="literal">False</span> <span class="string">odd</span> <span class="string">(Just</span> <span class="number">3</span><span class="string">)</span> <span class="string">==</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="Total-and-partial-functions"><a href="#Total-and-partial-functions" class="headerlink" title="Total and partial functions"></a>Total and partial functions</h4><ul>
<li>Functions which have certain inputs that will make them recurse infinitely are also called partial.</li>
<li>Functions which are well-defined on all possible inputs are known as total functions.</li>
<li>head is what is known as a partial function: there are certain inputs for which head will crash.</li>
<li>tail, init, last, and (!!) are partial functions<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">head</span>(<span class="selector-attr">[]</span>)</span><br><span class="line">*** <span class="selector-tag">Exception</span>: <span class="selector-tag">Prelude</span><span class="selector-class">.head</span>: <span class="selector-tag">empty</span> <span class="selector-tag">list</span></span><br></pre></td></tr></table></figure>
<h4 id="Replacing-partial-functions"><a href="#Replacing-partial-functions" class="headerlink" title="Replacing partial functions"></a>Replacing partial functions</h4>Replace<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">doStuff1 :: [<span class="built_in">Int</span>] -&gt; <span class="built_in">Int</span></span><br><span class="line">doStuff1 []  = <span class="number">0</span></span><br><span class="line">doStuff1 [_] = <span class="number">0</span></span><br><span class="line">doStuff1 xs  = head xs + (head (tail xs)) </span><br></pre></td></tr></table></figure>
as<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">doStuff2 :<span class="type"></span>: [<span class="keyword">Int</span>] -&gt; <span class="keyword">Int</span></span><br><span class="line">doStuff2 []        = <span class="number">0</span></span><br><span class="line">doStuff2 [<span class="literal">_</span>]       = <span class="number">0</span></span><br><span class="line">doStuff2 (x1:<span class="type">x2</span>:<span class="literal">_</span>) = x1 + x2</span><br></pre></td></tr></table></figure>
<h3 id="Writing-partial-functions"><a href="#Writing-partial-functions" class="headerlink" title="Writing partial functions"></a>Writing partial functions</h3></li>
</ul>
<p>What if you find yourself writing a partial functions?</p>
<h4 id="Change-the-output-type-of-the-function-to-indicate-the-possible-failure"><a href="#Change-the-output-type-of-the-function-to-indicate-the-possible-failure" class="headerlink" title="Change the output type of the function to indicate the possible failure."></a>Change the output type of the function to indicate the possible failure.</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br></pre></td></tr></table></figure>
<p>We could rewrite <code>head</code> safely like this<br><figure class="highlight mizar"><table><tr><td class="code"><pre><span class="line">safeHead <span class="comment">:: [a] -&gt; Maybe a</span></span><br><span class="line">safeHead []    = Nothing</span><br><span class="line">safeHead (x:_) = Just x</span><br></pre></td></tr></table></figure></p>
<h4 id="if-some-condition-is-really-guaranteed-then-the-types-ought-to-reflect-the-guarantee-Then-the-compiler-can-enforce-your-guarantees-for-you"><a href="#if-some-condition-is-really-guaranteed-then-the-types-ought-to-reflect-the-guarantee-Then-the-compiler-can-enforce-your-guarantees-for-you" class="headerlink" title="if some condition is really guaranteed, then the types ought to reflect the guarantee! Then the compiler can enforce your guarantees for you."></a>if some condition is really guaranteed, then the types ought to reflect the guarantee! Then the compiler can enforce your guarantees for you.</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">data NonEmptyList <span class="keyword">a</span> = NEL <span class="keyword">a</span> [<span class="keyword">a</span>]</span><br><span class="line"></span><br><span class="line">nelToList :: NonEmptyList <span class="keyword">a</span> -&gt; [<span class="keyword">a</span>]</span><br><span class="line">nelToList (NEL x xs) = x:xs</span><br><span class="line"></span><br><span class="line">listToNel :: [<span class="keyword">a</span>] -&gt; Maybe (NonEmptyList <span class="keyword">a</span>)</span><br><span class="line">listToNel []     = Nothing</span><br><span class="line">listToNel (x:xs) = Just $ NEL x xs</span><br><span class="line"></span><br><span class="line">headNEL :: NonEmptyList <span class="keyword">a</span> -&gt; <span class="keyword">a</span></span><br><span class="line">headNEL (NEL <span class="keyword">a</span> _) = <span class="keyword">a</span></span><br><span class="line"></span><br><span class="line">tailNEL :: NonEmptyList <span class="keyword">a</span> -&gt; [<span class="keyword">a</span>]</span><br><span class="line">tailNEL (NEL _ <span class="keyword">as</span>) = <span class="keyword">as</span></span><br></pre></td></tr></table></figure>
<h2 id="Higher-order-programming-and-type-inference"><a href="#Higher-order-programming-and-type-inference" class="headerlink" title="Higher-order programming and type inference"></a>Higher-order programming and type inference</h2><h3 id="Anonymous-functions"><a href="#Anonymous-functions" class="headerlink" title="Anonymous functions"></a>Anonymous functions</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">gt100</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">gt100</span> x = x &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="title">greaterThan100</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100</span> xs = filter gt100 xs</span><br></pre></td></tr></table></figure>
<p>anonymous function:<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">greaterThan100_2</span> :: [<span class="type">Integer</span>] -&gt; [<span class="type">Integer</span>]</span><br><span class="line"><span class="title">greaterThan100_2</span> xs = filter (\x -&gt; x &gt; <span class="number">100</span>) xs</span><br></pre></td></tr></table></figure></p>
<ul>
<li>\x -&gt; x &gt; 100 (the backslash is supposed to look kind of like a lambda with the short leg missing) is the function which takes a single argument x and outputs whether x is greater than 100.</li>
<li>lambda abstractions can also have multiple arguments.<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">(\<span class="symbol">x</span> <span class="symbol">y</span> z -&gt; [<span class="symbol">x</span>,<span class="number">2</span>*<span class="symbol">y</span>,<span class="number">3</span>*z]) <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> == [<span class="number">5</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure></li>
<li>if ? is an operator, then (?y) is equivalent to the function \x -&gt; x ? y, and (y?) is equivalent to \x -&gt; y ? x.<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">(&gt;100)</span> <span class="number">102</span> <span class="string">==</span> <span class="literal">True</span></span><br><span class="line"><span class="string">(100&gt;)</span> <span class="number">102</span> <span class="string">==</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<code>(- 1) 2</code>不可行？ </li>
</ul>
<h3 id="Function-composition"><a href="#Function-composition" class="headerlink" title="Function composition"></a>Function composition</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">foo</span> :: (b -&gt;</span> <span class="function"><span class="title">c</span>) -&gt;</span> (<span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">b</span>) -&gt;</span> (<span class="function"><span class="title">a</span> -&gt;</span> c)</span><br><span class="line"><span class="function"><span class="title">foo</span> f g = \x -&gt;</span> f (g x)</span><br></pre></td></tr></table></figure>
<ul>
<li>foo is really called (.), and represents function composition. That is, if f and g are functions, then f . g is the function which does first g and then f.</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">myTest :: [<span class="type">Integer</span>] -&gt; <span class="type">Bool</span></span><br><span class="line">myTest xs = even (length (greaterThan100 xs))</span><br></pre></td></tr></table></figure>
<p>We can rewrite this as:<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">myTest :: [Integer] -&gt; <span class="built_in">Bool</span></span><br><span class="line">myTest xs = even.length.greaterThan100 xs</span><br></pre></td></tr></table></figure><br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">Prelude&gt; :t (.)</span><br><span class="line">(.) :: (<span class="function"><span class="title">b</span> -&gt;</span> <span class="function"><span class="title">c</span>) -&gt;</span> (<span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">b</span>) -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> c</span><br></pre></td></tr></table></figure></p>
<h3 id="Currying-and-partial-application"><a href="#Currying-and-partial-application" class="headerlink" title="Currying and partial application"></a>Currying and partial application</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">f :: <span class="built_in">Int</span> -&gt; <span class="built_in">Int</span> -&gt; <span class="built_in">Int</span></span><br><span class="line">f x y = <span class="number">2</span>*x + y</span><br></pre></td></tr></table></figure>
<p>equivalently write f’s type like this:<br><figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">f&#x27; :: <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line">f&#x27; x y = <span class="number">2</span>*x + y</span><br></pre></td></tr></table></figure></p>
<ul>
<li>representing multi-argument functions as one-argument functions returning functions</li>
<li>If we want to actually represent a function of two arguments we can use a single argument which is a tuple.<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">f<span class="string">&#x27;&#x27;</span> :: (<span class="built_in">Int</span>,<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span></span><br><span class="line">f<span class="string">&#x27;&#x27;</span> (x,y) = <span class="number">2</span>*x + y</span><br></pre></td></tr></table></figure></li>
<li>In order to convert between the two representations of a two-argument function, the standard library defines functions called curry and uncurry, defined like this<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">sch</span>önfinkel :: ((a,b) -&gt;</span> <span class="function"><span class="title">c</span>) -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">b</span> -&gt;</span> c</span><br><span class="line">schönfinkel f x y = f (x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">unsch</span>önfinkel :: (a -&gt;</span> <span class="function"><span class="title">b</span> -&gt;</span> <span class="function"><span class="title">c</span>) -&gt;</span> (<span class="function"><span class="title">a</span>,b) -&gt;</span> c</span><br><span class="line">unschönfinkel f (x,y) = f x y</span><br></pre></td></tr></table></figure></li>
<li><p>uncurry in particular can be useful when you have a pair and want to apply a function to it. For example:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Prelude</span>&gt; uncurry (+) (<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="attribute">5</span></span><br></pre></td></tr></table></figure>
<h4 id="Partial-application"><a href="#Partial-application" class="headerlink" title="Partial application"></a>Partial application</h4></li>
<li><p>In Haskell there are no functions of multiple arguments! </p>
</li>
<li>Every function can be “partially applied” to its first (and only) argument, resulting in a function of the remaining arguments.</li>
<li>Haskell doesn’t make it easy to partially apply to an argument other than the first. </li>
<li>he one exception is infix operators, which as we’ve seen, can be partially applied to either of their two arguments using an operator section. </li>
</ul>
<h4 id="Wholemeal-programming"><a href="#Wholemeal-programming" class="headerlink" title="Wholemeal programming"></a>Wholemeal programming</h4><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">foobar :: [Integer] -&gt; Integer</span><br><span class="line">foobar []     = <span class="number">0</span></span><br><span class="line">foobar (x:xs)</span><br><span class="line">  | <span class="type">x</span> &gt; <span class="number">3</span>     = (<span class="number">7</span>*x + <span class="number">2</span>) + foobar xs</span><br><span class="line">  | <span class="type">otherwise</span> = foobar xs</span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">fooba<span class="string">r&#x27; :: [Integer] -&gt; Integer</span></span><br><span class="line"><span class="string">foobar&#x27;</span> = sum . map (\x -&gt; <span class="number">7</span>*x + <span class="number">2</span>) . filter (&gt;<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Folds"><a href="#Folds" class="headerlink" title="Folds"></a>Folds</h3><p>We have one more recursion pattern on lists to talk about: folds.<br>all of them somehow “combine” the elements of the list into a final answer.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">sum&#x27;</span> []     = <span class="number">0</span></span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs</span><br><span class="line"></span><br><span class="line"><span class="title">product&#x27;</span> :: [<span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">product&#x27;</span> [] = <span class="number">1</span></span><br><span class="line"><span class="title">product&#x27;</span> (x:xs) = x * product&#x27; xs</span><br><span class="line"></span><br><span class="line"><span class="title">length&#x27;</span> :: [a] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">length&#x27;</span> []     = <span class="number">0</span></span><br><span class="line"><span class="title">length&#x27;</span> (_:xs) = <span class="number">1</span> + length&#x27; xs</span><br></pre></td></tr></table></figure>
<p>define higher-order functions:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fold</span> :: b -&gt; (a -&gt; b -&gt; b) -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">fold</span> z f []     = z</span><br><span class="line"><span class="title">fold</span> z f (x:xs) = f x (fold z f xs)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fold</span> f z [a,b,c] == a `f` (b `f` (c `f` z))</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum&#x27;&#x27;</span>     = fold <span class="number">0</span> (+)</span><br><span class="line"><span class="title">product&#x27;&#x27;</span> = fold <span class="number">1</span> (*)</span><br><span class="line"><span class="title">length&#x27;&#x27;</span>  = fold <span class="number">0</span> (\_ s -&gt; <span class="number">1</span> + s)</span><br><span class="line"></span><br><span class="line">(<span class="type">Instead</span> <span class="keyword">of</span> (\_ s -&gt; <span class="number">1</span> + s) we could also write (\_ -&gt; (<span class="number">1</span>+)) or even (const (<span class="number">1</span>+)).)</span><br></pre></td></tr></table></figure>
<ul>
<li>fold is already provided in the standard Prelude, under the name foldr<br>Here are some Prelude functions which are defined in terms of foldr:</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">length</span> :: [a] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sum</span> :: <span class="type">Num</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">product</span> :: <span class="type">Num</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">and</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">or</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">any</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">all</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<ul>
<li>There is also foldl, which folds “from the left”. </li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> f z [a,b,c] == a `f` (b `f` (c `f` z))</span><br><span class="line"><span class="title">foldl</span> f z [a,b,c] == ((z `f` a) `f` b) `f` c</span><br></pre></td></tr></table></figure>
<ul>
<li>you should use foldl’ from Data.List instead, which does the same thing as foldl but is more efficient.</li>
</ul>
<h2 id="More-polymorphism-and-type-classes"><a href="#More-polymorphism-and-type-classes" class="headerlink" title="More polymorphism and type classes"></a>More polymorphism and type classes</h2><h3 id="Parametricity"><a href="#Parametricity" class="headerlink" title="Parametricity"></a>Parametricity</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">f :: a -&gt; a -&gt; a</span><br><span class="line">f <span class="symbol">x</span> <span class="symbol">y</span> = <span class="symbol">x</span> &amp;&amp; <span class="symbol">y</span></span><br></pre></td></tr></table></figure>
<p>The reason this doesn’t work is that the caller of a polymorphic function gets to choose the type. Here we, the implementors, have tried to choose a specific type (namely, Bool), but we may be given String, or Int, or even some type defined by someone using f, which we can’t possibly know about in advance. In other words, you can read the type<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> a</span><br></pre></td></tr></table></figure><br>as a promise that a function with this type will work no matter what type the caller chooses.</p>
<h3 id="Two-views-on-parametricity"><a href="#Two-views-on-parametricity" class="headerlink" title="Two views on parametricity"></a>Two views on parametricity</h3><figure class="highlight mizar"><table><tr><td class="code"><pre><span class="line">(==) <span class="comment">:: Eq a   =&gt; a -&gt; a -&gt; Bool</span></span><br><span class="line">(&lt;)  <span class="comment">:: Ord a  =&gt; a -&gt; a -&gt; Bool</span></span><br><span class="line">show <span class="comment">:: Show a =&gt; a -&gt; String</span></span><br></pre></td></tr></table></figure>
<h3 id="Type-classes"><a href="#Type-classes" class="headerlink" title="Type classes"></a>Type classes</h3><ul>
<li>Num, Eq, Ord, and Show are type classes, and we say that (==), (&lt;), and (+) are “type-class polymorphic”.</li>
<li>Intuitively, type classes correspond to sets of types which have certain operations defined for them, and type class polymorphic functions work only for types which are instances of the type class(es) in question.<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">class Eq a <span class="keyword">where</span></span><br><span class="line">  (==) :: <span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> Bool</span><br><span class="line">  (/=) :: <span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> Bool</span><br></pre></td></tr></table></figure></li>
<li>Eq is declared to be a type class with a single parameter, a.</li>
<li>Any type a which wants to be an instance of Eq must define two functions, (==) and (/=), with the indicated type signatures.</li>
</ul>
<figure class="highlight mizar"><table><tr><td class="code"><pre><span class="line">(==) <span class="comment">:: Eq a =&gt; a -&gt; a -&gt; Bool</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The Eq a that comes before the =&gt; is a type class constraint.</li>
<li>We can read this as saying that for any type a, as long as a is an instance of Eq, (==) can take two values of type a and return a Bool.</li>
<li>Let’s make our own type and declare an instance of Eq for it. <figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">data Foo = F Int | G Char</span><br><span class="line"></span><br><span class="line">instance Eq Foo where</span><br><span class="line">  (F i1) == (F i2) = i1 == i2</span><br><span class="line">  (G c1) == (G c2) = c1 == c2</span><br><span class="line">  _ == _ = False</span><br><span class="line"></span><br><span class="line">  foo1 /= foo2 =<span class="built_in"> not </span>(foo1 == foo2)</span><br></pre></td></tr></table></figure></li>
<li><p>the Eq class is actually declared like this:</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">class Eq a where</span><br><span class="line">  (==), (/=) :: a -&gt; a -&gt; Bool</span><br><span class="line">  <span class="symbol">x</span> == <span class="symbol">y</span> = <span class="keyword">not</span> (<span class="symbol">x</span> /= <span class="symbol">y</span>)</span><br><span class="line">  <span class="symbol">x</span> /= <span class="symbol">y</span> = <span class="keyword">not</span> (<span class="symbol">x</span> == <span class="symbol">y</span>)</span><br></pre></td></tr></table></figure>
<p>This means that when we make an instance of Eq, we can define either (==) or (/=), whichever is more convenient; </p>
</li>
<li><p>As it turns out, Eq (along with a few other standard type classes) is special: GHC is able to automatically generate instances of Eq for us. Like so:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo&#x27;</span> = <span class="type">F&#x27;</span> <span class="type">Int</span> | <span class="type">G&#x27;</span> <span class="type">Char</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>)</span><br></pre></td></tr></table></figure>
<p>This tells GHC to automatically derive instances of the Eq, Ord, and Show type classes for our data type Foo.</p>
</li>
</ul>
<h4 id="Type-classes-and-Java-interfaces"><a href="#Type-classes-and-Java-interfaces" class="headerlink" title="Type classes and Java interfaces"></a>Type classes and Java interfaces</h4><ul>
<li>Both define a set of types/classes which implement a specified list of operations.</li>
</ul>
<ol>
<li>When a Java class is defined, any interfaces it implements must be declared. Type class instances, on the other hand, are declared separately from the declaration of the corresponding types, and can even be put in a separate module.</li>
<li>The types that can be specified for type class methods are more general and flexible than the signatures that can be given for Java interface methods, especially when multi-parameter type classes enter the picture. For example, consider a hypothetical type class<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Blerg a b <span class="keyword">where</span></span><br><span class="line">  blerg :: a -&gt; b -&gt; <span class="built_in">Bool</span></span><br></pre></td></tr></table></figure>
Using blerg amounts to doing multiple dispatch: which implementation of blerg the compiler should choose depends on both the types a and b. There is no easy way to do this in Java.<br>Haskell type classes can also easily handle binary (or ternary, or …) methods, as in<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Num</span> a <span class="keyword">where</span></span></span><br><span class="line">  (+) :: a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
There is no nice way to do this in Java: for one thing, one of the two arguments would have to be the “privileged” one which is actually getting the (+) method invoked on it, and this asymmetry is awkward. Furthermore, because of Java’s subtyping, getting two arguments of a certain interface type does not guarantee that they are actually the same type, which makes implementing binary operators such as (+) awkward (usually requiring some runtime type checks).</li>
</ol>
<h4 id="Standard-type-classes"><a href="#Standard-type-classes" class="headerlink" title="Standard type classes"></a>Standard type classes</h4><ul>
<li>Ord is for types whose elements can be totally ordered, that is, where any two elements can be compared to see which is less than the other. It provides comparison operations like (&lt;) and (&lt;=), and also the compare function.</li>
<li>Num is for “numeric” types, which support things like addition, subtraction, and multipication. One very important thing to note is that integer literals are actually type class polymorphic:<figure class="highlight mizar"><table><tr><td class="code"><pre><span class="line">Prelude&gt; :t 5</span><br><span class="line">5 <span class="comment">:: Num a =&gt; a</span></span><br></pre></td></tr></table></figure>
This means that literals like 5 can be used as Ints, Integers, Doubles, or any other type which is an instance of Num (Rational, Complex Double, or even a type you define…)</li>
<li>Show defines the method show, which is used to convert values into Strings.</li>
<li>Read is the dual of Show.</li>
<li>Integral represents whole number types such as Int and Integer.</li>
</ul>
<h4 id="A-type-class-example"><a href="#A-type-class-example" class="headerlink" title="A type class example"></a>A type class example</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Listable a <span class="keyword">where</span></span><br><span class="line">  toList :: a -&gt; [<span class="built_in">Int</span>]</span><br></pre></td></tr></table></figure>
<p>We can think of Listable as the class of things which can be converted to a list of Ints. Look at the type of toList:<br><figure class="highlight mizar"><table><tr><td class="code"><pre><span class="line">toList <span class="comment">:: Listable a =&gt; a -&gt; [Int]</span></span><br></pre></td></tr></table></figure><br>First, an Int can be converted to an [Int] just by creating a singleton list, and Bool can be converted similarly, say, by translating True to 1 and False to 0:<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="comment">-- toList :: Int -&gt; [Int]</span></span><br><span class="line">  toList x = [x]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">  toList <span class="type">True</span>  = [<span class="number">1</span>]</span><br><span class="line">  toList <span class="type">False</span> = [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>We don’t need to do any work to convert a list of Int to a list of Int:<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> [<span class="type">Int</span>] <span class="keyword">where</span></span></span><br><span class="line">    toList = id</span><br></pre></td></tr></table></figure><br>Finally, here’s a binary tree type which we can convert to a list by flattening:<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Listable</span> (<span class="type">Tree</span> <span class="type">Int</span>) <span class="keyword">where</span></span></span><br><span class="line">    toList <span class="type">Node</span>(x,l,r) = toList l ++ [x] ++ toList r</span><br></pre></td></tr></table></figure><br>If we implement other functions in terms of toList, they also get a Listable constraint.<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sumL</span> x = sum (toList x)</span><br></pre></td></tr></table></figure><br>ghci informs us that type type of sumL is<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sumL</span> :: <span class="type">Listable</span> a =&gt; a -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foo</span> x y = sum (toList x) == sum (toList y) || x &lt; y</span><br></pre></td></tr></table></figure><br>type foo:<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foo</span> :: (<span class="type">Listable</span> a,<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Listable</span> <span class="title">a</span>, <span class="type">Listable</span> <span class="title">b</span>) =&gt; <span class="type">Listable</span> (<span class="title">a</span>,<span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  toList (x,y) = toList x ++ toList y</span><br></pre></td></tr></table></figure><br>Notice how we can put type class constraints on an instance as well as on a function type. This says that a pair type (a,b) is an instance of Listable as long as a and b both are. Then we get to use toList on values of types a and b in our definition of toList for a pair. Note that this definition is not recursive! The version of toList that we are defining is calling other versions of toList, not itself.</p>
<h2 id="Lazy-evaluation"><a href="#Lazy-evaluation" class="headerlink" title="Lazy evaluation"></a>Lazy evaluation</h2><h3 id="Strict-evaluation"><a href="#Strict-evaluation" class="headerlink" title="Strict evaluation"></a>Strict evaluation</h3><ul>
<li>Under a strict evaluation strategy, function arguments are completely evaluated before passing them to the function.</li>
<li>The benefit of strict evaluation is that it is easy to predict when and in what order things will happen. </li>
</ul>
<h3 id="Side-effects-and-purity"><a href="#Side-effects-and-purity" class="headerlink" title="Side effects and purity"></a>Side effects and purity</h3><h3 id="Lazy-evaluation-1"><a href="#Lazy-evaluation-1" class="headerlink" title="Lazy evaluation"></a>Lazy evaluation</h3><ul>
<li>Under a lazy evaluation strategy, evaluation of function arguments is delayed as long as possible: they are not evaluated until it actually becomes necessary to do so. </li>
<li>When some expression is given as an argument to a function, it is simply packaged up as an unevaluated expression (called a “thunk”, don’t ask me why) without doing any actual work.<h3 id="Pattern-matching-drives-evaluation"><a href="#Pattern-matching-drives-evaluation" class="headerlink" title="Pattern matching drives evaluation"></a>Pattern matching drives evaluation</h3></li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f1</span> :: <span class="type">Maybe</span> a -&gt; [<span class="type">Maybe</span> a]</span><br><span class="line"><span class="title">f1</span> m = [m,m]</span><br><span class="line"></span><br><span class="line"><span class="title">f2</span> :: <span class="type">Maybe</span> a -&gt; [a]</span><br><span class="line"><span class="title">f2</span> <span class="type">Nothing</span>  = []</span><br><span class="line"><span class="title">f2</span> (<span class="type">Just</span> x) = [x]</span><br></pre></td></tr></table></figure>
<ul>
<li>f1 uses its argument m, it does not need to know anything about it. m can remain completely unevaluated, and the unevaluated expression is simply put in a list. </li>
<li>f2, on the other hand, needs to know something about its argument in order to proceed: was it constructed with Nothing or Just.</li>
<li>The other important thing to note is that thunks are evaluated only enough to allow a pattern match to proceed, and no further!</li>
<li>suppose we wanted to evaluate f2 (safeHead [3^500, 49]). f2 would force evaluation of the call to safeHead [3^500, 49], which would evaluate to Just (3^500)—note that the 3^500 is not evaluated</li>
</ul>
<p><code>Expressions are only evaluated when pattern-matched</code></p>
<p><code>…only as far as necessary for the match to proceed, and no farther!</code></p>
<h3 id="Consequences"><a href="#Consequences" class="headerlink" title="Consequences"></a>Consequences</h3><h4 id="Purity"><a href="#Purity" class="headerlink" title="Purity"></a>Purity</h4><h4 id="Understanding-space-usage"><a href="#Understanding-space-usage" class="headerlink" title="Understanding space usage"></a>Understanding space usage</h4><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">-- Standard library function foldl, provided <span class="keyword">for</span> reference</span><br><span class="line"><span class="function"><span class="title">foldl</span> :: (b -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">b</span>) -&gt;</span> <span class="function"><span class="title">b</span> -&gt;</span> [<span class="function"><span class="title">a</span>] -&gt;</span> b</span><br><span class="line">foldl _ z []     = z</span><br><span class="line">foldl f z (x:xs) = foldl f (f z x) xs</span><br></pre></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">  foldl (+) 0 [1,2,3]</span></span><br><span class="line"><span class="section">= foldl (+) (0+1) [2,3]</span></span><br><span class="line"><span class="section">= foldl (+) ((0+1)+2) [3]</span></span><br><span class="line"><span class="section">= foldl (+) (((0+1)+2)+3) []</span></span><br><span class="line"><span class="section">= (((0+1)+2)+3)</span></span><br><span class="line"><span class="section">= ((1+2)+3)</span></span><br><span class="line"><span class="section">= (3+3)</span></span><br><span class="line"><span class="section">= 6</span></span><br></pre></td></tr></table></figure>
<p>Since the value of the accumulator is not demanded until recursing through the entire list, the accumulator simply builds up a big unevaluated expression (((0+1)+2)+3), which finally gets reduced to a value at the end.</p>
<ul>
<li>One is that it’s simply inefficient: there’s no point in transferring all the numbers from the list into a different list-like thing (the accumulator thunk) before actually adding them up. </li>
<li>The second problem is more subtle, and more insidious: evaluating the expression (((0+1)+2)+3) actually requires pushing the 3 and 2 onto a stack before being able to compute 0+1 and then unwinding the stack, adding along the way.<br>for very long lists it’s a big problem: there is usually not as much space available for the stack, so this can lead to a stack overflow.</li>
<li>The solution in this case is to use the foldl’ function instead of foldl, which adds a bit of strictness<h4 id="Short-circuiting-operators"><a href="#Short-circuiting-operators" class="headerlink" title="Short-circuiting operators"></a>Short-circuiting operators</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">(&amp;&amp;) :: <span class="built_in">Bool</span> -&gt; <span class="built_in">Bool</span> -&gt; <span class="built_in">Bool</span></span><br><span class="line"><span class="literal">True</span>  &amp;&amp; x = x</span><br><span class="line"><span class="literal">False</span> &amp;&amp; _ = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="User-defined-control-structures"><a href="#User-defined-control-structures" class="headerlink" title="User-defined control structures"></a>User-defined control structures</h4>In Haskell, however, we can define if as a library function!<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">if&#x27; :: <span class="type">Bool</span> -&gt; a -&gt; a -&gt; a</span><br><span class="line">if&#x27; <span class="type">True</span>  x _ = x</span><br><span class="line">if&#x27; <span class="type">False</span> _ y = y</span><br></pre></td></tr></table></figure>
<h4 id="Infinite-data-structures"><a href="#Infinite-data-structures" class="headerlink" title="Infinite data structures"></a>Infinite data structures</h4><h4 id="Pipelining-wholemeal-programming"><a href="#Pipelining-wholemeal-programming" class="headerlink" title="Pipelining/wholemeal programming"></a>Pipelining/wholemeal programming</h4></li>
</ul>
<h4 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h4><p>Using lazy evaluation we can get the Haskell runtime to work out the proper order of evaluation for us! For example, here is some Haskell code to solve the 0-1 knapsack problem.<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Array</span><br><span class="line"></span><br><span class="line"><span class="title">knapsack01</span> :: [<span class="type">Double</span>]   <span class="comment">-- values </span></span><br><span class="line">           -&gt; [<span class="type">Integer</span>]  <span class="comment">-- nonnegative weights</span></span><br><span class="line">           -&gt; <span class="type">Integer</span>    <span class="comment">-- knapsack size</span></span><br><span class="line">           -&gt; <span class="type">Double</span>     <span class="comment">-- max possible value</span></span><br><span class="line"><span class="title">knapsack01</span> vs ws maxW = m!(numItems<span class="number">-1</span>, maxW)</span><br><span class="line">  <span class="keyword">where</span> numItems = length vs</span><br><span class="line">        m = array ((<span class="number">-1</span>,<span class="number">0</span>), (numItems<span class="number">-1</span>, maxW)) $</span><br><span class="line">              [((<span class="number">-1</span>,w), <span class="number">0</span>) | w &lt;- [<span class="number">0</span> .. maxW]] ++</span><br><span class="line">              [((i,<span class="number">0</span>), <span class="number">0</span>) | i &lt;- [<span class="number">0</span> .. numItems<span class="number">-1</span>]] ++</span><br><span class="line">              [((i,w), best) </span><br><span class="line">                  | i &lt;- [<span class="number">0</span> .. numItems<span class="number">-1</span>]</span><br><span class="line">                  , w &lt;- [<span class="number">1</span> .. maxW]</span><br><span class="line">                  , <span class="keyword">let</span> best</span><br><span class="line">                          | ws!!i &gt; w  = m!(i<span class="number">-1</span>, w)</span><br><span class="line">                          | otherwise = max (m!(i<span class="number">-1</span>, w)) </span><br><span class="line">                                            (m!(i<span class="number">-1</span>, w - ws!!i) + vs!!i)</span><br><span class="line">              ]</span><br><span class="line"></span><br><span class="line"><span class="title">example</span> = knapsack01 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>] [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>] <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的一些记录</title>
    <url>/2020/08/21/C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul>
<li>指针类型大小都为8</li>
<li>文件指针不关闭会导致内存泄漏<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *f = fopen(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --leak-check=full --show-reachable=yes --trace-children=yes   ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">==333== Memcheck, a memory error detector</span><br><span class="line">==333== Copyright (C) 2002-2017, and GNU GPL<span class="string">&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==333== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==333== Command: ./test</span></span><br><span class="line"><span class="string">==333==</span></span><br><span class="line"><span class="string">==333== error calling PR_SET_PTRACER, vgdb might block</span></span><br><span class="line"><span class="string">==333==</span></span><br><span class="line"><span class="string">==333== HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==333==     in use at exit: 472 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==333==   total heap usage: 1 allocs, 0 frees, 472 bytes allocated</span></span><br><span class="line"><span class="string">==333==</span></span><br><span class="line"><span class="string">==333== 472 bytes in 1 blocks are still reachable in loss record 1 of 1</span></span><br><span class="line"><span class="string">==333==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)</span></span><br><span class="line"><span class="string">==333==    by 0x48E0AAD: __fopen_internal (iofopen.c:65)</span></span><br><span class="line"><span class="string">==333==    by 0x48E0AAD: fopen@@GLIBC_2.2.5 (iofopen.c:86)</span></span><br><span class="line"><span class="string">==333==</span></span><br><span class="line"><span class="string">==333== LEAK SUMMARY:</span></span><br><span class="line"><span class="string">==333==    definitely lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==333==    indirectly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==333==      possibly lost: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==333==    still reachable: 472 bytes in 1 blocks</span></span><br><span class="line"><span class="string">==333==         suppressed: 0 bytes in 0 blocks</span></span><br><span class="line"><span class="string">==333==</span></span><br><span class="line"><span class="string">==333== For lists of detected and suppressed errors, rerun with: -s</span></span><br><span class="line"><span class="string">==333== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span></span><br></pre></td></tr></table></figure>
<h3 id="C语言判断文件是否存在"><a href="#C语言判断文件是否存在" class="headerlink" title="C语言判断文件是否存在"></a>C语言判断文件是否存在</h3>access函数判断文件夹或者文件是否存在<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">filename：可以填写文件夹路径或者文件路径</span><br><span class="line"></span><br><span class="line">mode：<span class="number">0</span> （F_OK） 只判断是否存在</span><br><span class="line">      <span class="number">2</span> （R_OK） 判断写入权限</span><br><span class="line">      <span class="number">4</span> （W_OK） 判断读取权限</span><br><span class="line">      <span class="number">6</span> （X_OK） 判断执行权限</span><br></pre></td></tr></table></figure>
用于判断文件夹是否存在的时候，mode取0，判断文件是否存在的时候，mode可以取0、2、4、6。 若存在或者具有权限，返回值为0；<br>不存在或者无权限，返回值为-1。<br>fopen函数判断文件是否存在</li>
</ul>
<p>函数原型：FILE <em>fopen (char </em>filename, char *type);</p>
<p>filename：文件路径</p>
<p>type：打开文件的方式（有r、w、r+、w+、a、rb、wb等等）</p>
<p>用于判断文件是否存在可以使用 r 或者 rb ，因为使用其它方式的话，可能会自动建立文件。 返回值为NULL（打不开）和正数（能打开）。</p>
<h3 id="unlink函数"><a href="#unlink函数" class="headerlink" title="unlink函数"></a>unlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(unlink(<span class="string">&quot;test.txt&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unlink errpr!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结构体定义在<code>xx.c</code>文件，其他文件通过<code>#include &quot;xx.h&quot;</code>使用该结构体会报错：不允许使用不完整类型<br>只能把结构体定义在.h文件里面</p>
</li>
<li><p>把数据内容type a存入char数组s<br>memcpy(s,&amp;a,sizeof(type))</p>
</li>
<li><p>不能对宏定义的常量进行取地址操作</p>
</li>
</ul>
<h3 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h3><ul>
<li>gcc 生成文件跟在-o后面就行</li>
<li>编译含math库函数时，要加-lm</li>
</ul>
<h3 id="多进程相关"><a href="#多进程相关" class="headerlink" title="多进程相关"></a>多进程相关</h3><ul>
<li>创建n个进程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">   pid = fork();</span><br><span class="line">   <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子进程会拷贝fork语句之前的内容</li>
<li>共享内存<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;  // for using shared memory</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size_bytes = length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, size_bytes, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line"><span class="keyword">int</span> * arr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li>信号<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向进程pid发送信号</span></span><br><span class="line">kill(pid,SIGCONT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收信号并处理,handler 为处理函数，只带一个int参数，返回值为void</span></span><br><span class="line">signal(SIGCONT,handler);</span><br></pre></td></tr></table></figure></li>
<li>访问临界数据必须加互斥锁</li>
<li>指针 + 1产生的偏移量取决于指针类型</li>
<li>sizeof(size_t) == 8</li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>Q:使用#ifndef在头文件中定义全局变量，然后两个.c文件分别访问(#include)，编译时就会出现multiple definition的提示，但是已经使用了条件编译，理论上第二次应该跳过定义过程，这是为什么呢？</p>
<p>A:这类条件编译是为了防止同一个.c文件包含同一个头文件多次。<br>每一个.c文件最后都会编译生成对应的.obj文件的。所以你的两个.c文件对应的两个.obj文件都会有你说的那个全局变量的，链接的时候，链接器就会发现有定义了两个同名变量，于是就报multiple definition错误。<br>正确的做法是：是其中一个.c文件定义这个变量，在另外一个.c文件用extern声明,确保只定义一次，而声明则可以多次<br>因为头文件很容易被不同的.c文件include，生成多个.obj目标文件，因此正确的做法就是不要在头文件中定义全局变量，而应该在.c/.cpp文件中定义</p>
<p>安装libreadline-dev</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libreadline-dev</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;readline/readline.h&gt;</span></span><br><span class="line">cc -g -Wall -fPIC -DLOGGER=1  history.o shell.o ui.o -o crash -lm -lreadline</span><br></pre></td></tr></table></figure>
<ul>
<li>没懂为什么-lreadline要放最后面？</li>
</ul>
<p>一些函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取用户名</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取hostname</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gethostname</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sethostname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char *name = malloc(sizeof(char)*20);</span></span><br><span class="line"><span class="comment">gethostname(name,15);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取当前工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于cd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="comment">//get pwd 相关信息</span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *pw_name; <span class="comment">/*user name */</span></span><br><span class="line"><span class="keyword">char</span> *pw_passwd; <span class="comment">/*user password */</span></span><br><span class="line"><span class="keyword">uid_t</span> pw_uid; <span class="comment">/*user id */</span></span><br><span class="line"><span class="keyword">gid_t</span> pw_gid; <span class="comment">/*group id */</span></span><br><span class="line"><span class="keyword">char</span> *pw_gecos; <span class="comment">/*user real name */</span></span><br><span class="line"><span class="keyword">char</span> *pw_dir; <span class="comment">/*home directory */</span></span><br><span class="line"><span class="keyword">char</span> *pw_shell; <span class="comment">/*shell program */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct passwd *pwd =  getpwuid(getuid());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//此时a的地址与x地址一致，数组名相较于指针减少一次访存</span></span><br><span class="line"><span class="comment">//sizeof(a) == 0</span></span><br></pre></td></tr></table></figure>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p><img src="C:\Users\liule\AppData\Roaming\Typora\typora-user-images\image-20210927132642445.png" alt="image-20210927132642445"></p>
<p>修改传入参数arg内容，让它覆盖返回地址，导致栈溢出</p>
<h3 id="在main函数之前、之后执行代码"><a href="#在main函数之前、之后执行代码" class="headerlink" title="在main函数之前、之后执行代码"></a>在main函数之前、之后执行代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">before_main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;before main\n&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">after_main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;after main\n&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;in main\n&quot;</span>); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GNU C 的一大特色就是<strong>attribute</strong> 机制。<strong>attribute</strong> 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。</p>
<p><strong>attribute</strong> 书写特征是：<strong>attribute</strong> 前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的<strong>attribute</strong> 参数。</p>
<p><strong>attribute</strong> 语法格式为：<strong>attribute</strong> ((attribute-list))</p>
<p>关键字<strong>attribute</strong> 也可以对结构体（struct ）或共用体（union ）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias 。</p>
<p>在使用<strong>attribute</strong> 参数时，你也可以在参数的前后都加上“<strong>” （两个下划线），例如，使用</strong>aligned__而不是aligned ，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</p>
<p><strong>1、aligned</strong> </p>
<p>指定对象的对齐格式（以字节为单位），如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">short</span> b[<span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line">&#125; __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">int32_t</span> __attribute__ ((aligned (<span class="number">8</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该声明将强制编译器确保（尽它所能）变量类 型为struct S 或者int32_t 的变量在分配空间时采用8字节对齐方式。</p>
<p><strong>2、packed</strong></p>
<p>​    使用该属性对struct 或者union 类型进行定义，设定其类型的每一个变量的内存约束。就是告诉编译器取消结构在编译过程中的优化对齐（使用1字节对齐）,按照实际占用字节数进行对齐，是GCC特有的语法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">my</span>&#123;</span> <span class="keyword">char</span> ch; <span class="keyword">int</span> a;&#125;     <span class="keyword">sizeof</span>(<span class="keyword">int</span>)=<span class="number">4</span>;<span class="keyword">sizeof</span>(my)=<span class="number">8</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my</span>&#123;</span> <span class="keyword">char</span> ch; <span class="keyword">int</span> a;&#125;__attrubte__ ((packed))        <span class="keyword">sizeof</span>(<span class="keyword">int</span>)=<span class="number">4</span>;<span class="keyword">sizeof</span>(my)=<span class="number">5</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>无关紧要</title>
    <url>/2020/08/16/%E6%9B%B2%E7%8E%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="58e3321f1d78afd9ee099f0e06d0ce3d15e09f8d1f028defc5f7ef557bfea515">666645beeeea5721aee53536f3794d0e1a8c34d021b46e3a6f759609fa473fee23d473092b4f639a8899ef2d9ce3a33a1a058d223205e6868160fa8a877e06325e41021cf321501d3ae3df667d4b9e245d93fa520feace262e468078e21c2e5895a43d227dd91b34ffc2b346c546c3dc285c263e0efb51540b85b141ae77324542d790217c7dd0d711e9cd281942a9592b77ae72ec9f0d672502eb7c5ee1e402bed686db033a310a1045c812f22e9cd5604fda80616c1ac9e27851389a494df492f51e588de565534b418db25e059b96bf1dd762430754c4130d8436851eb1e76b73f24248f6cf0c475b1f4e0e25367dbeee49d89ffbe409fffde26196479e9741b7e73c3464e1297ce883e9ea56f19bf23c8d634fcb9b36123fc425153c3dbf7f96fc0d036725c2a2703afd80e39c30783a7a40ebe1db68e4ed25cb68ce4754c6f1b96e17e2a7b7e627eb52592070029c3d1f58e3452568747012aedfdce1f29cfca1e590bb55624404e6442f0f79901762c1ea62309aff8b303e6ae0c81b8b5b29046ff884ec05163b3fbe78cc6ca3405eecd4fca072234cb1e47b1ae8d69094648f5100a3a6a242834daded0a82c113f768426cda499e99f90c0eb7495d9090bc27526a84cb9ec913d27414d4f266c4f25e81d4c5593b867df2250e25f5d716af56d6639651f0cbec9522bba0bd3709cbd861565894c32834e3c9b8fa4b0e7a6c05119246fca9f6ca1f85ba54a3aaac34d015487e6113776e6396f7942bcc6570f36ddba734d211d2e10f79404582838cf4af370e11da3d01508dfa28e6d942801d62ae102e744d5da3c693ec6a836d004ea01c5d6255d3d4cc439418fcd40cceaa212f2bbcca0b3b0b2e2f26c9e3b33f1d1bb30fe690963f147c4801b7dfc9340196b997dda61ed8bc0a1a01e4aa23370e8257d8d610dc1e6a63af588641b740d71acf6f320210bbdbf772145ad380a1840e775445bfe766eeea0952dd4736ac9d53b07a22037e3106a69fe44f4b164b957a2e989d61d6c37c3985714c723c0c0c02cd626e36161ba0af3e6ea80638216d3a145df59c95437006ca8df44815759ecd1ee28c1ad53ccffb06404ed8ed5a107cde2a41ef7c27d4e72bafb03f667b03d30a4bbc977d54dfd3281c77463ff82a981e91f65fc1d6cb9461ae398d20c06252a6a6570e6960dbf5ad7a3fdb0a0d31ab0d2ae77a8bef516f6c35cf5c0bc1e66e365d22701709fcf69b07f5a302e13610e45bdc30129f65dd011207e9ad1d3a3b224c8f0cf5f61b6e87b805d92b7e91f66306a78752510439c3702c2fe7a5e5255becd407c027a057cbdbd9c1d994be7ab117771565404a98696297f7f306a3050fabad5673182d242c3e79de6427f77f59d89daf0ba61e32ebfe6ac7c8ea7f130a6aafc4c39a460f64fe831a7391705f0d6b9c2db92d5a26f06fabea6474f5a9607a5e7a94f2f1f6432d7fe5250661a9220c1b0badeff9a9910ff314fe0b6c25ca6ddcf38850ca555cf49d824dc324e9ad0c11f69336840b20aa3882f204d69b21cbaef8c9d43b873cc4a279fe4baa3f0ff19688099c1a991b7637cc33511a0ff9da35dd808200daf34849ef9809f247256b88df09eadcfde67c555388491c03f229e4d3bdaac6e74f36f7313ded1f5338973bd38666e633f742475ee0dfcf509e24835662261b869306f3b3714340479ca86d50eb8177a94983557a66a6534b8bca890dd6a4616ba90819558a85236bba65a758b2b8c09fa92a8fb28ef03516fa657842c45c0c12689b8a1a42c8c78db75930be07a5340d254f424335fb059f7a765b2e89093faed26e9ff31c5a418e9b98b81dbbff6bf7c9fc642e65cc5ec6447ea12f4bfe3466245a2461be3b46905002655477c8da568a3b7a5f96defb0b7bc19114d9ee87a6af0f866a7535e6db948d89c75f656caf337963eb3d7571f0aee72b696f80c79f91015d2d8a03d0e78fadbbf2b336b9bf6e3bbd55f0998412a0886928ccdd9de7e4cb31c53db1fb21812df20e00ba24f447ac0fb715f292cd25c95148399d1f22ee8d5a70f81970af4fec99f9bbc6a2282cf9cf05fae62ac8282ff672a0b129210b3bc32c1ef2d5cd4db3e44948d59f88202b58826c8f4972903f3b31cdd0d9b805acc0641bad1c2fd4c6d95a2e4ae768115f5275cc2692db02cf8d3bdd1b9be78ced7c5a348ca2e307792079145c4cd961ec2b315d9e3f372d907dc6762c40b5ecac8cfd7b6a19a63ed145658339b5cd00901b1106ab6649228cf74cc15fc3072f6a92a7d76ac39fa3250f70d3053999cc8dfa6f7655f163325fb15b94203a4d6a46d61f259b9466dc6b34ed9fedbb07ec5711ba823f292b3d9e0c1385dfed00e978391f208e8b1cae1462d49784a91f851bc49059bf2616ff420875a0a245fe78869263ae5a5997c56a0bd9bae42389dff7725ccd054dc7a5c4cbed84a07be9a79918780eab21225cfdc8a519453b05875f7e770913188e08e2f6fa2d60ff8f9118139f202b8865e98103b69292a7d7ebd4f3cc6dba114f8f7a97abe7c76b97cac814fc0f9feb6c17d1f00cff91e36f7245090925bd50e844cce490c73a90dc13bcc8b4e931a1fe63c119d655abbb3fdfa89d30fbfe6429c240e84b9e058130e358c619838ac5bba59e470ab800e5046bd095f3667d4b2906e0a94666da55803f8608cb2d44ce9b30b541cf1bf9ad4414fd8cafc4ac613953cbbf1822370dd9b242e0c5d5ed349d32ccafb6f7aed51c2f78ba57948f334e839cd92be949f9919c1542207b0c3210b975b950d5a17cb3db985e1cfc7e86dd02c2443d185bef0bda4e9c209950fd8f54d53b6c03f68341b29e3c8b20c04c0e3bc7a8b0b71fc7de5355c1d895b87cbf7c644efa8bf5a3fcd67289414800f81eb87caca68b3f879add1d753a9ac4d9ac0a0e1c0b85373abbd2e04c9f2af2b3f958aa3c7a7b82236d3802da1c9eaf3df89828a58373a30d8441b971ca164337332b17410fd18c922f385d3a6f4435be234c71a9e07f82b48eff892ef00e3c4ed6037c4903cd432b47000b3718df3a2324f8bff241f49097f8ff66446eac26e41003f76313606851d89562f9666fbf0e157fdb6ecd8b3126737ae2923e</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Ubuntu</title>
    <url>/2020/08/11/%E5%85%B3%E4%BA%8EUbuntu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于Ubuntu使用的一些备忘。</p>
<a id="more"></a>
<h2 id="VM虚拟机与win10主机互相复制粘贴文件"><a href="#VM虚拟机与win10主机互相复制粘贴文件" class="headerlink" title="VM虚拟机与win10主机互相复制粘贴文件"></a>VM虚拟机与win10主机互相复制粘贴文件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> <span class="keyword">open</span>-vm-tools</span><br><span class="line">sudo apt <span class="keyword">install</span> <span class="keyword">open</span>-vm-tools-desktop</span><br></pre></td></tr></table></figure>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>linux <a href="https://github.com/qingshuisiyuan/electron-ssr-backup">ssr</a></p>
<h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><p>压缩<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zip</span> -r graphs.<span class="built_in">zip</span> graphs</span><br><span class="line"><span class="built_in">zip</span> -r <span class="number">123.</span><span class="built_in">zip</span> abc.cpp <span class="keyword">def</span>.txt</span><br></pre></td></tr></table></figure><br>解压<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">unzip</span> <span class="selector-tag">graphs</span><span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure><br>tar命令</p>
<p>压缩<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -cvf <span class="number">123</span>.tar file<span class="number">1</span> file<span class="number">2</span> dir<span class="number">1</span></span><br></pre></td></tr></table></figure><br>解压</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xvf file.tar</span><br><span class="line"><span class="attribute">tar</span> -zxvf apache-tomcat-<span class="number">7</span>.<span class="number">0</span>.<span class="number">75</span>.tar.gz </span><br></pre></td></tr></table></figure>
<h2 id="WSL-报错cannot-execute-binary-file-Exec-format"><a href="#WSL-报错cannot-execute-binary-file-Exec-format" class="headerlink" title="WSL 报错cannot execute binary file: Exec format"></a>WSL 报错cannot execute binary file: Exec format</h2><p>Bash On Windows(WSL)无法运行32Bit程序，报错cannot execute binary file: Exec format</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-user-static</span><br><span class="line">sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic &#x27;<span class="symbol">\x</span>7fELF<span class="symbol">\x</span>01<span class="symbol">\x</span>01<span class="symbol">\x</span>01<span class="symbol">\x</span>03<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>03<span class="symbol">\x</span>00<span class="symbol">\x</span>03<span class="symbol">\x</span>00<span class="symbol">\x</span>01<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>00&#x27; --mask &#x27;<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>fc<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>f8<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h1><p>子系统可以直接访问windows下的任何文件，这也是比虚拟机好用的关键点之一。在 /mnt 目录下就可以访问c、d、e、f等盘符，并且可以直接访问任何一个文件位置。</p>
<p>因为windows的盘符挂载到linux中的时候全部都用了 777 的权限，在一些软件开发上可能会出现一些问题。</p>
<ul>
<li>使用wsl的自动挂载功能，修改 /etc/wsl.conf 文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[automount]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">root = /mnt/</span><br><span class="line">options = <span class="string">&quot;metadata,dmask=022,fmask=133&quot;</span></span><br><span class="line">mountFsTab = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
就可以将/mnt下的所有盘都挂载为linux下默认的权限。</li>
<li>windows wsl创建文件权限</li>
</ul>
<p>挂载问题是解决了,但是使用wsl命令打开的终端创建新的文件还是 777。</p>
<p>在/etc/profile或~/.profile或~/.bashrc最后添加一些逻辑。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">if [[ &quot;$(umask)&quot; == &#x27;000&#x27; ]]; then</span><br><span class="line">    umask <span class="number">022</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><br>这样在每次启动终端的时候就会重新设置umask, 之后创建文件就正常了。</p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>百度之星2020</title>
    <url>/2020/08/09/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2020/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2020+%C4%EA%B0%D9%B6%C8%D6%AE%D0%C7%A1%A4%B3%CC%D0%F2%C9%E8%BC%C6%B4%F3%C8%FC+-+%B8%B4%C8%FC&amp;source=1&amp;searchmode=source">百度之星2020复赛</a><br><a id="more"></a></p>
<h2 id="Binary-Addition"><a href="#Binary-Addition" class="headerlink" title="Binary Addition"></a>Binary Addition</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>你有两个无限长0101串$S$, $T$，分别记作$S<em>{0}S</em>{1}\cdots$…和$T<em>{0}T</em>{1}\cdots$<br>.其中$S$和$T$从$n$位之后都是0，也就是当$i \geq n$，有$S<em>{i}=T</em>{i}=0$<br>你可以对$S$串进行操作：<br>修改$S$串的某一位，从0变成1或者从1变成0。<br>将$S$当成二进制数加1，也就是记$s=\sum<em>{i\geq 0} S</em>{i}2^{i}$，将$S$变成$s+1$二进制表示的形式，其中低位在最前面。<br>问最少的步数将$S$变成$T$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>答案必定是先将某一前缀修改为全1，然后再加上1，变成$0\cdots01$的形式，然后按位修改。<br><strong><em>注意最高位1的位置如果在原来$S$串中也是1，可以先将1变为0再变回1</em></strong>，找了一晚上bug==</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>],t[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    b[n]=<span class="number">0</span>;</span><br><span class="line">    b[n+<span class="number">1</span>] =<span class="number">0</span>;</span><br><span class="line">    s[n] = t[n] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        b[i] = b[i+<span class="number">1</span>]+(s[i]!=t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>  d = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>)&#123; d++;&#125;</span><br><span class="line">        <span class="keyword">if</span>(t[i] == <span class="string">&#x27;1&#x27;</span>)&#123; c++;&#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, d + c + b[i + <span class="number">2</span>] + (t[i + <span class="number">1</span>] != <span class="string">&#x27;1&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,d+c+<span class="number">1</span>+b[i+<span class="number">2</span>]+(t[i+<span class="number">1</span>]!=<span class="string">&#x27;1&#x27;</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d+c&gt;ans)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">signed</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)&#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1110111</span></span><br><span class="line"><span class="comment">0000001</span></span><br><span class="line"><span class="comment">3?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Battle-for-Wosneth"><a href="#Battle-for-Wosneth" class="headerlink" title="Battle for Wosneth"></a>Battle for Wosneth</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>你在打游戏的时候碰到了如下问题：<br>​有两个人记作Alice和Bob，Bob的生命值为$m$，Alice的生命值很高，所以可以认为是无限的。两个人的攻击命中率分别为$p\%,q\%$。两个人轮流攻击对方。从Alice开始攻击，每次攻击的时候，如果Alice命中，那么能让对方的生命值减低1，同时自己的生命值能恢复1，如果Bob命中，那么能让对方的生命值减低1，注意Bob不会自己回血。<br>直到Bob的血量变为0，游戏结束。Alice想知道，游戏结束的时候，自己期望生命值变化是多少，对998244353取模。<br>注意这里的变化量不是绝对值，也就是如果50%的概率加一，50%的概率减一，那么期望的变化量就是0。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>Alice在杀掉Bob之前，即成功击中Bob$m$次之前，失败次数服从帕斯卡分布，期望值$m \times (1-p)/p$。所以留给Bob进攻的次数期望值为$m\times (1-p)/p+m-1$，击中次数期望<br>$(m\times (1-p)/p+m-1)\times q$，因而Alice生命值期望变化量<br>$m - (m\times (1-p)/p+m-1)\times q$。</p>
<h3 id="关于帕斯卡分布"><a href="#关于帕斯卡分布" class="headerlink" title="关于帕斯卡分布"></a>关于帕斯卡分布</h3><p>$X \sim NB(k;p)$，则$P(X=r) = C<em>{k+r-1}^{k-1}p^{k}(1-p)^{r}$,$r$为失败次数。<br>期望：<br>$EX = \sum</em>{r}rP(X=r) $<br>$= \sum<em>{r}r\frac{(r+k-1)!}{(k-1)!r!}p^{k}(1-p)^{r} $<br>$= k\frac{1-p}{p} \sum</em>{r-1} \frac{((r-1)+(k+1)-1)!}{(k-1)!r!}p^{k+1}(1-p)^{r-1}$<br>$= k\frac{1-p}{p}$.<br><strong><em>最后一步是由$\sum_{r-1} \frac{((r-1)+(k+1)-1)!}{(k-1)!r!}p^{k+1}(1-p)^{r-1}$是帕斯卡分布概率求和，故为1得到</em></strong></p>
<img src="/2020/08/09/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2020/%E5%85%AC%E5%BC%8F1.png" class="">
<img src="/2020/08/09/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2020/%E5%85%AC%E5%BC%8F2.png" class="">
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si signed</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc(x) scanf(<span class="meta-string">&quot;%lld&quot;</span>,&amp;x);</span></span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans = (ans*x)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        x = (x*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,p,q;</span><br><span class="line">    sc(m)sc(p)sc(q)</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> in = qp(<span class="number">100</span>,mod<span class="number">-2</span>);</span><br><span class="line">    p = (p*in)%mod;</span><br><span class="line">    q = (q*in)%mod;</span><br><span class="line"></span><br><span class="line">    ans = (m-((m*(<span class="number">1</span>-p+mod)%mod*(qp(p,mod<span class="number">-2</span>))%mod)+m<span class="number">-1</span>)%mod*q%mod+mod)%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    si _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)&#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>百度之星2018复赛</title>
    <url>/2020/08/08/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2018%E5%A4%8D%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>只会两道QAQ,第二题不会。<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2018%A1%B0%B0%D9%B6%C8%D6%AE%D0%C7%A1%B1%B3%CC%D0%F2%C9%E8%BC%C6%B4%F3%C8%FC+-+%B8%B4%C8%FC&amp;source=1&amp;searchmode=source">2018百度之星复赛</a></p>
<a id="more"></a>
<h2 id="没有兄弟的舞会"><a href="#没有兄弟的舞会" class="headerlink" title="没有兄弟的舞会"></a>没有兄弟的舞会</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>度度熊、光羽、带劲三个人是好朋友。</p>
<p>度度熊有一棵$n$个点的有根树，其中1号点为树根。除根节点之外，每个点都有父节点，记i号点的父节点为$fa[i]$。</p>
<p>度度熊称点$i$和点$j$是<strong>兄弟</strong>（其中$i≠j$）当且仅当$fa[i]=fa[j]$。</p>
<p>第$i$个点的权值为$Ai$。现要求选出一个点集，该点集合法当且仅当<strong>点集中至多只有一对兄弟</strong>。</p>
<p>度度熊想知道，在所有可行的点集中，权值和<strong>最大</strong>以及<strong>最小</strong>的点集权值和分别是多少？</p>
<p>第一行一个数，表示数据组数$T$。</p>
<p>每组数据第一行一个整数$n$；第二行$n−1$个数，表示$fa[2],fa[3],..,fa[n]$；第三行$n$个数，表示$Ai$。</p>
<p>数据组数$T=100$，满足：</p>
<ul>
<li>$1 \leq n \leq 1e5$</li>
<li>$−1e9\leq Ai \leq 1e9$</li>
<li>$1 \leq fa[i]&lt;i$</li>
</ul>
<p>其中90%的数据满足$n \leq 1000$。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护每个父节点直接子节点权值的正最大值，正次大值，负最小值，负次小值。最大点集权值为所有正的最大值与最大的正次大值之和，最小点集权值为所有负最小值与最小的负次小值之和。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// <span class="symbol">Created</span> by liulex on <span class="number">2020</span>/<span class="number">7</span>/<span class="number">27.</span></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int fa[<span class="number">100005</span>];</span><br><span class="line">int <span class="symbol">A</span>[<span class="number">100005</span>];</span><br><span class="line">int <span class="symbol">B</span>[<span class="number">100005</span>];</span><br><span class="line">int <span class="symbol">C</span>[<span class="number">100005</span>];</span><br><span class="line">int <span class="symbol">D</span>[<span class="number">100005</span>];</span><br><span class="line">int v[<span class="number">100005</span>]; </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="symbol">T</span>,n;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;<span class="symbol">T</span>);</span><br><span class="line">    while(<span class="symbol">T</span>--)&#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="symbol">A</span>[<span class="number">0</span>] = <span class="symbol">B</span>[<span class="number">0</span>] = <span class="symbol">C</span>[<span class="number">0</span>] = <span class="symbol">D</span>[<span class="number">0</span>] = <span class="symbol">A</span>[<span class="number">1</span>] = <span class="symbol">B</span>[<span class="number">1</span>] = <span class="symbol">C</span>[<span class="number">1</span>] = <span class="symbol">D</span>[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        for(int i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]);</span><br><span class="line">            <span class="symbol">A</span>[i] = <span class="symbol">B</span>[i] = <span class="symbol">C</span>[i] = <span class="symbol">D</span>[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            scanf(<span class="string">&quot;%d&quot;</span>,&amp;v[i]);</span><br><span class="line">            if(v[i] &gt; <span class="symbol">A</span>[fa[i]] &amp;&amp; v[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="symbol">B</span>[fa[i]] = <span class="symbol">A</span>[fa[i]],<span class="symbol">A</span>[fa[i]] = v[i];</span><br><span class="line">            &#125;else if(v[i] &gt; <span class="symbol">B</span>[fa[i]] &amp;&amp; v[i] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="symbol">B</span>[fa[i]] = v[i];</span><br><span class="line">            &#125;else if(v[i] &lt; <span class="symbol">C</span>[fa[i]] &amp;&amp;v[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="symbol">D</span>[fa[i]] = <span class="symbol">C</span>[fa[i]];</span><br><span class="line">                <span class="symbol">C</span>[fa[i]] = v[i];</span><br><span class="line">            &#125;else if(v[i] &lt; <span class="symbol">D</span>[fa[i]] &amp;&amp; v[i]  &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="symbol">D</span>[fa[i]] = v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long long  ma = <span class="number">0</span>,mi = <span class="number">0</span>;</span><br><span class="line">        int c = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">        for(int i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            ma += <span class="symbol">A</span>[i];</span><br><span class="line">            mi += <span class="symbol">C</span>[i];</span><br><span class="line">            c = max(c,<span class="symbol">B</span>[i]);</span><br><span class="line">            d = min(d,<span class="symbol">D</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ma+c&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;mi+d&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带劲的and和"><a href="#带劲的and和" class="headerlink" title="带劲的and和"></a>带劲的and和</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>度度熊专门研究过“动态传递闭包问题”，他有一万种让大家爆蛋的方法；但此刻，他只想出一道简简单单的题——至繁，归于至简。</p>
<p>度度熊有一张$n$个点$m$条边的<strong>无向图</strong>，第$i$个点的点权为$vi$。</p>
<p>如果图上存在一条<strong>路径</strong>使得点$i$可以走到点$j$，则称$i$,$j$是<strong>带劲</strong>的，记$f(i,j)=1$；否则$f(i,j)=0$。显然有$f(i,j)=f(j,i)$。</p>
<p>度度熊想知道求出：<br>$\sum<em>{i=1}^{n-1}\sum</em>{j=i+1}^{n}f(i,j)×max(vi,vj)×(vi\&amp;vj)$</p>
<p>其中&amp;是C++中的and位运算符，如$1\&amp;3=1, 2\&amp;3=2$。</p>
<p>请将答案对$1e9+7$取模后输出。</p>
<p>第一行一个数，表示数据组数$T$。</p>
<p>每组数据第一行两个整数$n,m$；第二行$n$个数表示$vi$；接下来$m$行，每行两个数u,v，表示点u和点v之间有一条无向边。<strong>可能有重边或自环。</strong></p>
<p>数据组数$T=50$，满足：</p>
<ul>
<li>$1\leq n,m\leq 100000$</li>
<li>$1\leq vi\leq 1e9$。</li>
</ul>
<p>其中90%的数据满足$n,m\leq 1000$。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们可以通过并查集维护任意两点连通关系。当$i,j$属于同一连通分支时，$f(i,j)=1$，我们把这一连通分支里所有顶点权值排序，从前往后遍历，不难发现对于每一个权值$vi$,<br>对答案都有$v<em>{i}\sum</em>{j=1}^{i-1}v<em>{i}\&amp;v</em>{j}$贡献。问题转换成了对这个求和$\sum<em>{j=1}^{i-1}v</em>{i}\&amp;v<em>{j}$的处理，直接考虑与运算对求和没有前缀性质。<br>需要用到二进制思想，维护权值的二进制每一位出现次数的前缀和，(第$k$位记为$A</em>{k}$)，对于当前权值$v<em>{i}$，如果它的二进制第$k$位为1,那么将对求和产生$A</em>{k}*(1&lt;&lt;k)$的贡献。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by liulex on 2020/7/27.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si signed</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100005</span>];</span><br><span class="line">si fa[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">33</span>];</span><br><span class="line"><span class="function">si <span class="title">find</span><span class="params">(si x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = (fa[x] == x?x:<span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">si <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si T,n,m,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++)A[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;v[i]);</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x) != <span class="built_in">find</span>(y))&#123;</span><br><span class="line">                fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            G[<span class="built_in">find</span>(i)].push_back(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>,t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++)A[j] = <span class="number">0</span>;</span><br><span class="line">                sort(G[i].<span class="built_in">begin</span>(),G[i].<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        t = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">30</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((G[i][j] &gt;&gt; k) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                                t += (A[k] * (<span class="number">1l</span>l &lt;&lt; k)) % mod;</span><br><span class="line">                                t %= mod;</span><br><span class="line">                                A[k]++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ans += (G[i][j]*t)%mod;</span><br><span class="line">                        ans %= mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(G[i].<span class="built_in">size</span>())</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>SVD</title>
    <url>/2020/08/06/SVD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><hr>
<p>$rank(A) = rank(A^{T}A)$</p>
<p>只需说明$AX = 0$ 与 $A^{T}AX =0$同解.</p>
<p>若$X$满足$AX = 0$,显然有$A^{T}AX = 0$成立.</p>
<p>反之，若$A^{T}AX = 0$,左乘$X^{T}$,有$X^{T}A^{T}AX = 0$. </p>
<p>即$(AX)^{T}AX = 0$,令$Y=AX$,有$Y^{T}Y = 0$,$Y = AX = 0$.<br><a id="more"></a></p>
<hr>
<p>实矩阵$A_{m\times n}$, $A^{T}A$的特征值都为非负实数。</p>
<p>设$\lambda$ 为$A^{T}A$的复特征值，有$AX=\lambda X$</p>
<p>记$\overline{\lambda}$为$\lambda$的共轭，有</p>
<p>$A\overline{X} = \overline{A}\overline{X} = \overline{AX} = \overline{\lambda X} = \overline{\lambda} \overline{X} $.</p>
<p>从而</p>
<p>$\overline{X}^{T}AX = \overline{X}^{T} \lambda X = \lambda \overline{X}^{T} X$.</p>
<p>和</p>
<p>$\overline{X}^{T}AX = \overline{X}^{T}\overline{A}^{T}X = \overline{AX}^{T}X = (\overline{\lambda} \overline{X})^{T}X = \overline{\lambda} \overline{X}^{T}X $.</p>
<p>进而有$(\lambda - \overline{\lambda})\overline{X}^{T}X = 0$,</p>
<p>所以$\lambda - \overline{\lambda} = 0$，即$\lambda$为实数.</p>
<p>设$\lambda$为$A^{T}A$的特征值，有</p>
<p>$\left | AX \right |^{2} = X^{T}A^{T}AX = \lambda X^{T}X = \lambda \left \| X\right \|^{2}$.</p>
<p>所以$\lambda = \frac{\left | AX\right |^{2}}{\left | X\right|^{2}} \geq 0$.</p>
<hr>
<p>$A \in \mathbb{R}^{m\times n}$ 则$A$存在奇异值分解：</p>
<p>$A = U\Sigma V^{T}$,其中$U$是$m$阶正交矩阵,$V$是$n$阶正交矩阵,$\Sigma$是$m\times n$矩形对角矩阵,其对角线元素非负,且按降序排列.</p>
<p>证明: $A^{T}A$的特征值都为实数，因而存在有正交矩阵$V$，使得$V^{T}(A^{T}A)V = \Lambda$ 成立.</p>
<p>其中$\Lambda$为对角矩阵，对角线元素为$A^{T}A$的特征值,调整特征值的顺序，使其按降序排列，满足</p>
<p>$\lambda<em>{1} \geq \lambda</em>{2} \geq \lambda<em>{3}\cdots \geq \lambda</em>{n} \geq 0$.</p>
<p>令 $V<em>{1} = \begin{bmatrix} \nu </em>{1} &amp; \nu<em>{2}  &amp; \cdots  &amp; \nu</em>{r} \end{bmatrix}$,</p>
<p>$V<em>{2} = \begin{bmatrix} \nu </em>{r+1}  &amp; \cdots  &amp; \nu_{n} \end{bmatrix}$</p>
<p>其中$\nu<em>{1} \cdots \nu</em>{r}$为$A^{T}A$正特征值对应的特征向量，$\nu<em>{r+1} \cdots \nu</em>{n}$为$A^{T}A$零特征值的对应的特征向量.</p>
<p>$V = \begin{bmatrix} V<em>{1} &amp; V</em>{2} \end{bmatrix}$即为奇异值分解中的$V$.</p>
<p>记$\sigma<em>{i} = \sqrt\lambda</em>{i}$,令</p>
<p>$\Sigma <em>{1} = \begin{bmatrix} \sigma</em>{1} &amp;  &amp;  &amp;<br>\\ &amp;\sigma<em>{2}  &amp;  &amp;<br>\\  &amp;  &amp;\ddots   &amp;<br>\\  &amp;  &amp;  &amp; \sigma</em>{r} \end{bmatrix}$</p>
<p>于是$m\times n$对角矩阵可以表示为$\Sigma = \begin{bmatrix}\Sigma_{1} &amp; 0<br>\\ 0 &amp; 0 \end{bmatrix}$.</p>
<p>构造$U$,令$u<em>{j} = \frac{1}{\sigma</em>{j}}A\nu_{j}$,</p>
<p>$U<em>{1} = \begin{bmatrix} u</em>{1} &amp; u<em>{2} &amp; \cdots &amp; u</em>{r} \end{bmatrix}$,有$AV<em>{1} = U</em>{1}\Sigma_{1}$</p>
<p>$u<em>{i}^{T}u</em>{j} = (\frac{1}{\sigma<em>{i}}\nu</em>{i}^{T}A^{T})(\frac{1}{\sigma<em>{j}}A\nu</em>{j}) = \frac{1}{\sigma<em>{i}\sigma</em>{j}}\nu<em>{i}^{T}(A^{T}A\nu</em>{j}) = \frac{\sigma<em>{j}}{\sigma</em>{i}}\nu<em>{i}\nu</em>{j}$<br>所以$u<em>{1},u</em>{2},\cdots,u_{r}$构成一组标准正交基.</p>
<p>令$U<em>{2} = u</em>{r+1},\cdots,u<em>{n}$为$R(A)^{\perp }$的一组标准正交基,记$U = \begin{bmatrix} U</em>{1} &amp; U_{2} \end{bmatrix}$</p>
<p>$U\Sigma V^{T} = \begin{bmatrix}U<em>{1} &amp; U</em>{2} \end{bmatrix}\begin{bmatrix}\Sigma<em>{1} &amp; 0\\ 0 &amp; 0 \end{bmatrix}\begin{bmatrix}V</em>{1}^{T}\\<br>                 V<em>{2}^{T}\end{bmatrix}=U</em>{1}\Sigma<em>{1}V</em>{1}^{T} = AV<em>{1}V</em>{1}^{T} = A$.</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM笔记</title>
    <url>/2020/08/05/jvm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><img src="/2020/08/05/jvm/jvmdata.png" class="">
<p>JVM 是 Java 的核心和基础，在 Java 编译器和 os 平台之间的虚拟处理器。它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象的计算机，可以在上面执行 Java 的字节码程序。<br><a id="more"></a></p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li>当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。</li>
<li>线程私有，各线程之间程序计数器互不影响，每个线程都有一个独立的程序计数器。</li>
<li>当线程在执行的是 Native 方法（调用本地操作系统方法）时，该计数器的值为空。</li>
<li>该内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM（内存溢出：OutOfMemoryError）情况的区域。</li>
</ol>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ol>
<li>线程私有的，它的生命周期也与线程相同。</li>
<li>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。</li>
<li>对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</li>
<li>栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。</li>
<li>在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的 Code 属性之中。</li>
</ol>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。<br>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。<br>在单线程的操作中,虚拟机抛出的都是 StackOverflowError 异常，在多线程环境下，则会抛出 OutOfMemoryError 异常。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ol>
<li>一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配。</li>
<li>局部变量表的容量以变量槽（Slot）为最小单位。一个 Slot 可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference 和 returnAddresss。double,long虚拟机会以高位在前的方式为其分配两个连续的 Slot 空间。<br>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始到局部变量表最大的 Slot 数量。</li>
<li>在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），则局部变量表中的第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，从一开始，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。</li>
<li>局部变量表中的 Slot 是可重用的，方法体中定义的变量，作用域并不一定会覆盖整个方法体，当前字节码PC计数器的值超过某个变量的作用域时，该变量对应的 Slot 就可以交给其他变量使用。节省空间，在某些情况下 Slot 的复用会直接影响到系统的而垃圾收集行为。</li>
</ol>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><ol>
<li>操作数栈又称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32 位数据类型所占的栈容量为 1,64 位为 2。</li>
<li>当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）入栈和出栈。</li>
<li>Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</li>
</ol>
<p>基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；<br>而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><ol>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</li>
<li>Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。</li>
<li>这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</li>
</ol>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><ol>
<li>方法退出：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。</li>
<li>在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</li>
<li>方法正常退出时，调用者的 PC 计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li>
<li>方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈所发挥的作用类似，本地方法栈则为使用到的本地操作系统（Native）方法服务。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><ol>
<li>Java Heap 是 Java 虚拟机所管理的内存中最大的一块，所有线程共享的一块内存区域。</li>
<li>对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</li>
<li>Java 堆可以处在物理不连续，逻辑连续的内存空间。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol>
<li>所有线程共享，存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等信息。方法区域被称为永久代。</li>
<li>不需要物理连续内存，可选择固定大小或可扩展，可以不实现垃圾回收，回收针对废弃常量、无用类。</li>
<li>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），运行时常量池用于存放编译器生成的各种字面量和符号引用。Java 语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中，如String 类的 intern（）方法。</li>
<li>方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</li>
</ol>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ol>
<li>在多线程情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。<br>操作系统为每个进程分配的内存是有限制的，虚拟机提供了参数来控制 Java 堆和方法区这两部分内存的最大值，忽略掉程序计数器消耗的内存（很小），以及进程本身消耗的内存，剩下的内存便给了虚拟机栈和本地方法栈，每个线程分配到的栈容量越大，可以建立的线程数量自然就越少。因此，如果是建立过多的线程导致的内存溢出，在不能减少线程数的情况下，就只能通过减少最大堆和每个线程的栈容量来换取更多的线程。</li>
<li>内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java 中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们 new 了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露，<br>内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。</li>
</ol>
<h3 id="引用定位方式"><a href="#引用定位方式" class="headerlink" title="引用定位方式"></a>引用定位方式</h3><h4 id="使用句柄池"><a href="#使用句柄池" class="headerlink" title="使用句柄池"></a>使用句柄池</h4><img src="/2020/08/05/jvm/javastack.png" class="">
<p>reference 中存放的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改.</p>
<h4 id="直接使用指针"><a href="#直接使用指针" class="headerlink" title="直接使用指针"></a>直接使用指针</h4><img src="/2020/08/05/jvm/javastack1.png" class="">
<p>速度快，它节省了一次指针定位的时间开销。</p>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的 Java 程序代码。</p>
<h3 id="执行类初始化情形"><a href="#执行类初始化情形" class="headerlink" title="执行类初始化情形"></a>执行类初始化情形</h3><ol>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。<br>生成这四条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时<br>（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。</li>
<li>使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。</li>
</ol>
<p>虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。</p>
<p>通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;父类被初始化&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extends</span> <span class="title">Father</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;子类被初始化&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span>&#123;</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;  </span><br><span class="line">        System.out.<span class="built_in">println</span>(Child.m);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">父类被初始化</span></span><br><span class="line"><span class="comment">    33</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> NAME = <span class="string">&quot;我是常量&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;初始化Const类&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span>&#123;</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;  </span><br><span class="line">        System.out.<span class="built_in">println</span>(Const.NAME);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">我是常量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>通过数组定义来引用类，不会触发类的初始化：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;初始化Const类&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span>&#123;</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;  </span><br><span class="line">        Const[] con = <span class="keyword">new</span> Const[<span class="number">5</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br>段代码里触发了另一个名为“LLConst”的类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object 的子类，创建动作由字节码指令 newarray 触发，很明显，这是一个对数组引用类型的初始化。</p>
<h3 id="接口的初始化过程与类初始化过程的不同"><a href="#接口的初始化过程与类初始化过程的不同" class="headerlink" title="接口的初始化过程与类初始化过程的不同"></a>接口的初始化过程与类初始化过程的不同</h3><p>接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成类构造器，用于初始化接口中定义的成员变量（实际上是 static final 修饰的全局常量）。</p>
<p>当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。</p>
<p>调用类中的 static final 常量时并不会 触发该类的初始化，但是调用接口中的 static final 常量时便会触发该接口的初始化。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>前端杂项</title>
    <url>/2020/08/03/%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><img src="/2020/08/03/%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9/htm.jpg" class="">
<p>一些杂乱的东西。</p>
<a id="more"></a>
<h2 id="html-标签"><a href="#html-标签" class="headerlink" title="html 标签"></a>html 标签</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 1级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h6</span>&gt;</span> <span class="comment">&lt;!-- 2级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>...<span class="tag">&lt;/<span class="name">i</span>&gt;</span>  <span class="comment">&lt;!-- 文字斜体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 段落标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>...<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="comment">&lt;!-- 文字加粗 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 换行标记 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> <span class="comment">&lt;!-- 水平线 --&gt;</span></span><br><span class="line"><span class="symbol">&amp;nbsp;</span> <span class="comment">&lt;!-- 空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;images/1.png&quot;</span> <span class="attr">width</span> = <span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;images/1.png&quot;</span> <span class="attr">height</span> = <span class="string">&quot;100px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;https://www.baidu.com/s?cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;wd=%E9%92%9F%E5%8D%97%E5%B1%B1%E6%88%90%E4%B8%BA%E5%85%B1%E5%92%8C%E5%9B%BD%E5%8B%8B%E7%AB%A0%E5%BB%BA%E8%AE%AE%E4%BA%BA%E9%80%89&amp;rsv_idx=2&amp;rsv_dl=fyb_n_homepage&amp;hisfilter=1&quot;</span>&gt;</span></span><br><span class="line">                钟南山成为共和国勋章建议人选</span><br><span class="line">             <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;https://www.baidu.com/s?cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;wd=%E9%92%9F%E5%8D%97%E5%B1%B1%E6%88%90%E4%B8%BA%E5%85%B1%E5%92%8C%E5%9B%BD%E5%8B%8B%E7%AB%A0%E5%BB%BA%E8%AE%AE%E4%BA%BA%E9%80%89&amp;rsv_idx=2&amp;rsv_dl=fyb_n_homepage&amp;hisfilter=1&quot;</span>&gt;</span></span><br><span class="line">                钟南山成为共和国勋章建议人选</span><br><span class="line">             <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;&quot;</span> <span class="attr">target</span> = <span class="string">&quot;_blank&quot;</span>&gt;</span>在新窗口打开链接 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span> = <span class="string">&quot;disc&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span> = <span class="string">&quot;circle&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span> = <span class="string">&quot;square&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span> = <span class="string">&quot;1&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span> = <span class="string">&quot;a&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span> = <span class="string">&quot;A&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span> = <span class="string">&quot;i&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span> = <span class="string">&quot;I&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;&quot;</span> <span class="attr">title</span> = <span class="string">&quot;鼠标划上去时的提示&quot;</span> <span class="attr">alt</span> = <span class="string">&quot;图片加载失败时的提示文字&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>给文字增加删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>把文字变成上标</span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>...<span class="tag">&lt;/<span class="name">u</span>&gt;</span>给文字加下划线</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>文字居中<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">表格</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">&quot;1px&quot;</span> <span class="attr">cellspacing</span> = <span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span> = <span class="string">&quot;200px&quot;</span> <span class="attr">align</span> = <span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span> = <span class="string">&quot;1px&quot;</span> <span class="attr">cellspacing</span> = <span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span> = <span class="string">&quot;200px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span> = <span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">行列合并</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span> = <span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span> = <span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>...<span class="tag">&lt;/<span class="name">th</span>&gt;</span> 表头</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">colgroup</span> <span class="attr">span</span> = <span class="string">&quot;6&quot;</span> <span class="attr">width</span> = <span class="string">&quot;100px&quot;</span>&gt;</span>前六列设为一组，宽均为100px</span><br><span class="line"></span><br><span class="line">表单</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;&quot;</span>&gt;</span> <span class="comment">&lt;!-- action 表单信息提交地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span>&gt;</span> <span class="comment">&lt;!-- password,button,radio,checkbox,submit,reset,file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">name</span> = <span class="string">&quot;loginname&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;password&quot;</span> <span class="attr">name</span> = <span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span> <span class="attr">value</span> = <span class="string">&quot;提交&quot;</span>&gt;</span> <span class="comment">&lt;!-- value 按钮文字--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="post-get"><a href="#post-get" class="headerlink" title="post get"></a>post get</h2><p>提交数据:post<br>获取数据:get<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">&lt;form <span class="function"><span class="keyword">method</span> = &quot;<span class="title">post</span>&quot;/&quot;<span class="title">get</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure><br>get请求发送的数据都会写在地址栏上，用户可见<br>post请求发送的数据用户不可见<br>post请求能发送大量数据，而get不能</p>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: center; 文字居中方式</span><br><span class="line"><span class="attribute">background-color</span>:gray;</span><br><span class="line">&lt;span&gt;容器标签，包裹文本，不具有特殊功能&lt;/span&gt;</span><br><span class="line">&lt;div&gt;容器标签，可以包裹任何内容，也可以容器直接相互包裹&lt;/div&gt;</span><br><span class="line"><span class="attribute">color</span>: white;文字颜色</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">24px</span>;字体大小</span><br><span class="line"><span class="attribute">margin</span>:auto; 让容器本身水平居中</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">&quot;banner&quot;</span>&gt;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">80px</span>;行高</span><br><span class="line"><span class="attribute">height</span>:<span class="number">80px</span>; 高</span><br><span class="line"><span class="attribute">text-decoration</span>:none;去除超链接下划线</span><br><span class="line"><span class="attribute">border</span>:solid <span class="number">1px</span> <span class="number">#808080</span>;设置边框</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span> <span class="number">15px</span>;变宽拉长</span><br><span class="line"><span class="attribute">border-right</span>:solid <span class="number">1px</span> <span class="number">#808080</span>;只保留右边框</span><br><span class="line"><span class="attribute">border-bottom</span>: dash <span class="number">1px</span> grey;虚下边框</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">div</span>,img标签名 根据标签名称选择对应的所有标签</span><br><span class="line">    <span class="selector-id">#id</span> id选择器，同一个页面元素id不允许重复，因此id选择器只能选择单个元素</span><br><span class="line">    .class名 类别选择器 选择拥有该类别的多个元素</span><br><span class="line">    *通用选择器，选择所有标签</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="attribute">float</span>:left;容器浮动</span><br><span class="line"><span class="attribute">clear</span>:left/right/both表示该元素不受左右元素浮动影响</span><br><span class="line"><span class="attribute">overflow</span>:auto;让父元素自动适应子浮动元素大小</span><br><span class="line"><span class="attribute">margin-top</span>,margin-right,margin-bottom,margin-left</span><br><span class="line"><span class="attribute">padding</span>:内边距</span><br></pre></td></tr></table></figure>
<h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><p>行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器</p>
<h2 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;<span class="comment">/*文字颜色*/</span></span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">&quot;华文中宋&quot;</span>;<span class="comment">/*字体类型*/</span></span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">26px</span>;<span class="comment">/*字体大小*/</span></span><br><span class="line"><span class="attribute">font-weight</span>:bold;<span class="comment">/*文字加粗*/</span></span><br><span class="line"><span class="attribute">font-style</span>:italic;<span class="comment">/*文字倾斜*/</span></span><br><span class="line"><span class="attribute">text-indent</span>:<span class="number">60px</span>;<span class="comment">/*首行缩进*/</span></span><br><span class="line"><span class="attribute">text-align</span>:center;<span class="comment">/*水平对齐方式*/</span></span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">100px</span>;<span class="comment">/*行高*/</span></span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">background-color</span>:gray;<span class="attribute">line-height</span>:<span class="number">100px</span>;<span class="comment">/*垂直居中*/</span></span><br><span class="line"><span class="attribute">text-decoration</span>:underline;<span class="comment">/*文本修饰*/</span></span><br></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>：url();</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">//不让背景图平铺</span></span><br><span class="line"><span class="attribute">background-position</span><span class="selector-pseudo">:right</span> <span class="attribute">bottom</span>;<span class="comment">//背景图位置</span></span><br></pre></td></tr></table></figure>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h3><p>变量必须以字母开头</p>
<p>变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）</p>
<p>变量名称对大小写敏感（y 和 Y 是不同的变量）</p>
<p>可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">var <span class="attribute">lastname</span>=<span class="string">&quot;Doe&quot;</span>, <span class="attribute">age</span>=30, <span class="attribute">job</span>=<span class="string">&quot;carpenter&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>重新声明 JavaScript 变量</p>
<p>如果重新声明 JavaScript 变量，该变量的值不会丢失：</p>
<p>在以下两条语句执行后，变量 carname 的值依然是 “Volvo”：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var carname=<span class="string">&quot;Volvo&quot;</span><span class="comment">;</span></span><br><span class="line">var carname<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型：<br><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="symbol">x</span>;               <span class="comment">// x 为 undefined</span></span><br><span class="line"><span class="keyword">var</span> <span class="symbol">x</span> = <span class="number">5</span>;           <span class="comment">// 现在 x 为数字</span></span><br><span class="line"><span class="keyword">var</span> <span class="symbol">x</span> = <span class="string">&quot;John&quot;</span>;      <span class="comment">// 现在 x 为字符串</span></span><br></pre></td></tr></table></figure><br>JavaScript字符串可以使用单引号或双引号。</p>
<p>可以在字符串中使用引号，只要不匹配包围字符串的引号即可：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var answer</span>=<span class="string">&quot;It&#x27;s alright&quot;</span>;</span><br><span class="line"><span class="attribute">var answer</span>=<span class="string">&quot;He is called &#x27;Johnny&#x27;&quot;</span>;</span><br><span class="line"><span class="attribute">var answer</span>=<span class="string">&#x27;He is called &quot;Johnny&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript 只有一种数字类型。极大或极小的数字可以通过科学（指数）计数法来书写。<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> y=<span class="number">123</span>e<span class="number">5</span>;      // <span class="number">12300000</span></span><br><span class="line"><span class="attribute">var</span> z=<span class="number">123</span>e-<span class="number">5</span>;     // <span class="number">0</span>.<span class="number">00123</span></span><br></pre></td></tr></table></figure><br>JavaScript 数组<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var cars=new Array()<span class="comment">;</span></span><br><span class="line">cars[<span class="number">0</span>]=<span class="string">&quot;Saab&quot;</span><span class="comment">;</span></span><br><span class="line">cars[<span class="number">1</span>]=<span class="string">&quot;Volvo&quot;</span><span class="comment">;</span></span><br><span class="line">cars[<span class="number">2</span>]=<span class="string">&quot;BMW&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var cars</span>=new Array(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line"><span class="attribute">var cars</span>=[<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>];</span><br></pre></td></tr></table></figure><br>JavaScript 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var person=&#123;<span class="attr">firstname:</span><span class="string">&quot;John&quot;</span>, <span class="attr">lastname:</span><span class="string">&quot;Doe&quot;</span>, <span class="attr">id:</span><span class="number">5566</span>&#125;;</span><br></pre></td></tr></table></figure><br>对象属性有两种寻址方式:<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=person.lastname<span class="comment">;</span></span><br><span class="line"><span class="attr">name</span>=person[<span class="string">&quot;lastname&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>Undefined 这个值表示变量不含有值。</p>
<p>可以通过将变量的值设置为 null 来清空变量。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">cars</span>=null<span class="comment">;</span></span><br><span class="line"><span class="attr">person</span>=null<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本站</title>
    <url>/2020/08/02/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><img src="/2020/08/02/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/test.jpg" class="">
<p>本站诞生史。</p>
<a id="more"></a>
<h2 id="hexo-初始化"><a href="#hexo-初始化" class="headerlink" title="hexo 初始化"></a>hexo 初始化</h2>
    <div id="aplayer-XAvXYtyT" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="2909007895" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line">hexo s -d</span><br></pre></td></tr></table></figure>
<h2 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h2><p>最新next仓库<br><a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/next-theme/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<h2 id="文本添加音乐"><a href="#文本添加音乐" class="headerlink" title="文本添加音乐"></a>文本添加音乐</h2><h3 id="安装hexo-tag-aplayer"><a href="#安装hexo-tag-aplayer" class="headerlink" title="安装hexo-tag-aplayer"></a>安装hexo-tag-aplayer</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-tag-aplayer</span></span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p>title : 曲目标题</p>
<p>author: 曲目作者</p>
<p>url: 音乐文件 URL 地址</p>
<p>picture_url: (可选) 音乐对应的图片地址</p>
<p>narrow: （可选）播放器袖珍风格</p>
<p>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</p>
<p>width:xxx: (可选) 播放器宽度 (默认: 100%)</p>
<p>lrc:xxx: （可选）歌词文件 URL 地址</p>
<p>当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&#123;<span class="meta">%</span> aplayer <span class="string">&quot;Caffeine&quot;</span> <span class="string">&quot;Jeff Williams&quot;</span> <span class="string">&quot;caffeine.mp3&quot;</span> <span class="string">&quot;picture.jpg&quot;</span> <span class="string">&quot;lrc:caffeine.txt&quot;</span> <span class="meta">%</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;narrow&quot;</span>: false,                          <span class="regexp">//</span> （可选）播放器袖珍风格</span><br><span class="line">    <span class="string">&quot;autoplay&quot;</span>: true,                         <span class="regexp">//</span> （可选) 自动播放，移动端浏览器暂时不支持此功能</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;random&quot;</span>,                         <span class="regexp">//</span> （可选）曲目循环类型，有 <span class="string">&#x27;random&#x27;</span>（随机播放）, <span class="string">&#x27;single&#x27;</span> (单曲播放), <span class="string">&#x27;circulation&#x27;</span> (循环播放), <span class="string">&#x27;order&#x27;</span> (列表播放)， 默认：<span class="string">&#x27;circulation&#x27;</span> </span><br><span class="line">    <span class="string">&quot;showlrc&quot;</span>: <span class="number">3</span>,                             <span class="regexp">//</span> （可选）歌词显示配置项，可选项有：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">    <span class="string">&quot;mutex&quot;</span>: true,                            <span class="regexp">//</span> （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</span><br><span class="line">    <span class="string">&quot;theme&quot;</span>: <span class="string">&quot;#e6d0b2&quot;</span>,	                      <span class="regexp">//</span> （可选）播放器风格色彩设置，默认：<span class="comment">#b7daff</span></span><br><span class="line">    <span class="string">&quot;preload&quot;</span>: <span class="string">&quot;metadata&quot;</span>,                    <span class="regexp">//</span> （可选）音乐文件预载入模式，可选项： <span class="string">&#x27;none&#x27;</span> <span class="string">&#x27;metadata&#x27;</span> <span class="string">&#x27;auto&#x27;</span>, 默认: <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">    <span class="string">&quot;listmaxheight&quot;</span>: <span class="string">&quot;513px&quot;</span>,                 <span class="regexp">//</span> (可选) 该播放列表的最大长度</span><br><span class="line">    <span class="string">&quot;music&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;CoCo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Jeff Williams&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;caffeine.mp3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pic&quot;</span>: <span class="string">&quot;caffeine.jpeg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;lrc&quot;</span>: <span class="string">&quot;caffeine.txt&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;アイロニ&quot;</span>,</span><br><span class="line">            <span class="string">&quot;author&quot;</span>: <span class="string">&quot;鹿乃&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;irony.mp3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pic&quot;</span>: <span class="string">&quot;irony.jpg&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MetingJS支持"><a href="#MetingJS支持" class="headerlink" title="MetingJS支持"></a>MetingJS支持</h4><p>如果想在本插件中使用 MetingJS，请在 Hexo 配置文件 _config.yml 中设置：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>接着就可以通过<br><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">meting</span> ...%&#125;</span></span><br></pre></td></tr></table></figure><br> 在文章中使用 MetingJS 播放器了：<br><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 简单示例 (id, server, type)  --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">meting</span> &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 进阶示例 --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">meting</span> &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;</span></span><br></pre></td></tr></table></figure><br>id    必须值    歌曲 id / 播放列表 id / 相册 id / 搜索关键字</p>
<p>server    必须值    音乐平台: netease, tencent, kugou, xiami, baidu</p>
<p>type    必须值    song, playlist, album, search, artist</p>
<p>fixed    false    开启固定模式</p>
<p>mini    false    开启迷你模式</p>
<p>loop    all    列表循环模式：all, one,none</p>
<p>order    list    列表播放模式： list, random</p>
<p>volume    0.7    播放器音量</p>
<p>lrctype    0    歌词格式类型</p>
<p>listfolded    false    指定音乐播放列表是否折叠</p>
<p>storagename    metingjs    LocalStorage 中存储播放器设定的键名</p>
<p>autoplay    true    自动播放，移动端浏览器暂时不支持此功能</p>
<p>mutex    true    该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</p>
<p>listmaxheight    340px    播放列表的最大长度</p>
<p>preload    auto    音乐文件预载入模式，可选项： none, metadata, auto</p>
<p>theme    #ad7a86    播放器风格色彩设置</p>
<h2 id="全局音乐自动播放"><a href="#全局音乐自动播放" class="headerlink" title="全局音乐自动播放"></a>全局音乐自动播放</h2><p>修改<font color=red>\theme\next\layout_layout.swig</font>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 我使用的APlayer本体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aplayer&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-id</span>=<span class="string">&quot;2465890057&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-server</span>=<span class="string">&quot;netease&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-type</span>=<span class="string">&quot;playlist&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-fixed</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-autoplay</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-order</span>=<span class="string">&quot;random&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-volume</span>=<span class="string">&quot;0.55&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-theme</span>=<span class="string">&quot;#cc543a&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-preload</span>=<span class="string">&quot;auto&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面--&gt;</span></span><br></pre></td></tr></table></figure>
<p>Aplayer<a href="https://github.com/metowolf/MetingJS">参数设置</a><br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>-server: netease, tencent, kugou, xiami, baidu</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>-<span class="keyword">type</span>: song, playlist, album, search, artist</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>-id: song id / playlist id / album id / search keyword</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>-order: &#x27;list&#x27;, &#x27;random&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><font color=red>pjax</font>，页面跳转时不重新播放</p>
<p>pjax安装</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ cd themes/<span class="keyword">next</span></span><br><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-pjax source/<span class="class"><span class="keyword">lib</span>/<span class="title">pjax</span></span></span><br></pre></td></tr></table></figure>
<p>设置theme的_config.yml<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># Easily enable fast Ajax navigation <span class="keyword">on</span> your website.</span><br><span class="line"># Dependencie<span class="variable">s:</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-pjax</span><br><span class="line"># For moreinformation: http<span class="variable">s:</span>//github.<span class="keyword">com</span>/MoOx/pjax</span><br><span class="line">pjax: true</span><br></pre></td></tr></table></figure></p>
<h2 id="设置背景图片"><a href="#设置背景图片" class="headerlink" title="设置背景图片"></a>设置背景图片</h2><p>修改theme _config.yml<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: <span class="keyword">source</span><span class="regexp">/_data/</span>styles.styl</span><br></pre></td></tr></table></figure><br>在<font color=red>blog根目录下</font>新建_data文件夹</p>
<p>新建styles.styl</p>
<p>内容：<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加背景图片</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: url(https://source.unsplash.com/random/<span class="number">1600</span>x900?wallpapers);<span class="comment">//自己喜欢的图片地址</span></span><br><span class="line">      <span class="attribute">background-size</span>: cover;</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">      <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">   <span class="comment">// margin-top: 60px;</span></span><br><span class="line">   <span class="comment">// padding: 60px 60px 60px 60px;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p>安装相应插件<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb  <span class="comment">--save</span></span><br></pre></td></tr></table></figure><br>设置根目录配置文件<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure><br>设置主题目录配置文件<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="安装-hexo-renderer-kramed"><a href="#安装-hexo-renderer-kramed" class="headerlink" title="安装 hexo-renderer-kramed"></a>安装 hexo-renderer-kramed</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-kramed <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h3 id="修改-node-modules-kramed-lib-rules-inline-js"><a href="#修改-node-modules-kramed-lib-rules-inline-js" class="headerlink" title="修改/node_modules/kramed/lib/rules/inline.js"></a>修改/node_modules/kramed/lib/rules/inline.js</h3><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">escape: /^<span class="symbol">\\</span>([<span class="symbol">\\</span>`*&#123;&#125;<span class="symbol">\[</span><span class="symbol">\]</span>()#$+<span class="symbol">\-</span>.!_&gt;])/,</span><br><span class="line">改为</span><br><span class="line">escape: /^<span class="symbol">\\</span>([`*<span class="symbol">\[</span><span class="symbol">\]</span>()# +<span class="symbol">\-</span>.!_&gt;])/,</span><br><span class="line"></span><br><span class="line">em: /^<span class="symbol">\b</span>_((?:__|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br><span class="line">改为</span><br><span class="line">em: /^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure>
<h3 id="修改主题-config-yml"><a href="#修改主题-config-yml" class="headerlink" title="修改主题_config.yml"></a>修改主题_config.yml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>开启per_page保证只要显示加了mathjax: true的页面才进行渲染。</p>
<h3 id="在md文件开启mathjax"><a href="#在md文件开启mathjax" class="headerlink" title="在md文件开启mathjax"></a>在md文件开启mathjax</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-MathJax-给公式编号并引用公式"><a href="#使用-MathJax-给公式编号并引用公式" class="headerlink" title="使用 MathJax 给公式编号并引用公式"></a>使用 MathJax 给公式编号并引用公式</h3><p>在新版本的 NexT 主题中，我们加入了公式自动编号和引用功能。下面简要介绍一下如何使用这项功能。</p>
<p>为了使用这项功能，一般来说，你必须把所使用的 LaTeX 公式放在 equation 环境里面，采用旧的方法<br>（也就是说，仅仅把公式的每一边用两个 $ 符号包含起来）是无效的。如何引用公式？<br>你只需要在书写公式的时候给公式一个 \label{} 标记（tag），然后在正文中，可以使用 \ref{} 或者 \eqref{} 命令来引用对应的公式。<br>使用 \eqref{} 是推荐的方式，因为如果你使用 \ref{}，公式在文中的引用编号将没有圆括号包围。下面介绍几种常见的公式编号例子。</p>
<p>对于简单的公式，使用下面的方式给公式一个标记，</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span>\<span class="keyword">begin</span>&#123;equation&#125;\label&#123;eq1&#125;</span><br><span class="line">e=mc^<span class="number">2</span></span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;<span class="variable">$$</span></span><br></pre></td></tr></table></figure>
<p>然后，在正文中，你可以轻松引用上述公式，一个简单的例子如下：<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">著名的质能方程 <span class="variable">$\</span>eqref&#123;eq1&#125;<span class="variable">$ </span>由爱因斯坦提出 ...</span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">\begin{equation}\label{eq1}
e=mc^2
\end{equation}</script><p>著名的质能方程 $\eqref{eq1}$ 由爱因斯坦提出 …</p>
<p>对于多行公式，在 equation 环境中，你可以使用 aligned 环境把公式分成多行，<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\begin&#123;<span class="keyword">equation</span>&#125;\label&#123;eq2&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a <span class="comment">&amp;= b + c \\</span></span><br><span class="line">  &amp;= d <span class="comment">+ e + f + g \\</span></span><br><span class="line">  &amp;= h <span class="comment">+ i</span></span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;<span class="keyword">equation</span>&#125;$$</span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">\begin{equation}\label{eq2}
\begin{aligned}
a &= b + c \\
  &= d + e + f + g \\
  &= h + i
\end{aligned}
\end{equation}</script><p>要对齐多个公式，我们需要使用 align 环境。align 环境中的每个公式都有自己的编号：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$$\<span class="keyword">begin</span>&#123;<span class="keyword">align</span>&#125;</span><br><span class="line">a &amp;<span class="operator">=</span> b + <span class="keyword">c</span> \label&#123;<span class="keyword">eq</span><span class="number">3</span>&#125; \\</span><br><span class="line"><span class="keyword">x</span> &amp;<span class="operator">=</span> yz \label&#123;<span class="keyword">eq</span><span class="number">4</span>&#125;\\</span><br><span class="line">l &amp;<span class="operator">=</span> m - n \label&#123;<span class="keyword">eq</span><span class="number">5</span>&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;<span class="keyword">align</span>&#125;$$</span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">\begin{align}
a &= b + c \label{eq3} \\
x &= yz \label{eq4}\\
l &= m - n \label{eq5}
\end{align}</script><p>在 align 环境中，如果你不想给某个或某几个公式编号，那么在这些公式后面使用 \nonumber 命令即可。例如：<br><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$<span class="string">\begin&#123;align&#125;</span></span><br><span class="line">-<span class="number">4</span> + <span class="number">5x</span> &amp;= <span class="number">2</span>+y <span class="string">\nonumber</span>  <span class="string">\\</span></span><br><span class="line"> w+<span class="number">2</span> &amp;= -<span class="number">1</span>+w <span class="string">\\</span></span><br><span class="line"> ab &amp;= cb</span><br><span class="line"><span class="string">\end&#123;align&#125;$$</span></span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">\begin{align}
-4 + 5x &= 2+y \nonumber  \\
 w+2 &= -1+w \\
 ab &= cb
\end{align}</script><p>有时，你可能会希望采用更加奇特的方式来标记和引用你的公式，你可以通过使用 \tag{} 命令来实现，例如：<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>x+<span class="number">1</span>\over\<span class="built_in">sqrt</span>&#123;<span class="number">1</span>-x^<span class="number">2</span>&#125; \tag&#123;i&#125;\label&#123;eq_tag&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">x+1\over\sqrt{1-x^2} \tag{i}\label{eq_tag}</script><h2 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h2><p>安装插件<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-blog-encrypt</span></span><br></pre></td></tr></table></figure><br>格式<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">encryptAsDiary</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">mikemessi</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">Here&#x27;s</span> <span class="string">something</span> <span class="string">encrypted,</span> <span class="string">password</span> <span class="string">is</span> <span class="string">required</span> <span class="string">to</span> <span class="string">continue</span> <span class="string">reading.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">Hey,</span> <span class="string">password</span> <span class="string">is</span> <span class="string">required</span> <span class="string">here.</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">Oh,</span> <span class="string">this</span> <span class="string">is</span> <span class="string">an</span> <span class="string">invalid</span> <span class="string">password.</span> <span class="string">Check</span> <span class="string">and</span> <span class="string">try</span> <span class="string">again,</span> <span class="string">please.</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">Oh,</span> <span class="string">these</span> <span class="string">decrypted</span> <span class="string">content</span> <span class="string">cannot</span> <span class="string">be</span> <span class="string">verified,</span> <span class="string">but</span> <span class="string">you</span> <span class="string">can</span> <span class="string">still</span> <span class="string">have</span> <span class="string">a</span> <span class="string">look.</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-helper-live2d</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/xiazeyu/live2d-widget-models">https://github.com/xiazeyu/live2d-widget-models</a></p>
<h3 id="禁用评论"><a href="#禁用评论" class="headerlink" title="禁用评论"></a>禁用评论</h3><p>md文件加<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span>-pin-top <span class="comment">--save</span></span><br><span class="line">文章内设置：</span><br><span class="line">top: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>修改/themes/next/layout/_macro/post.swig,在</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;post-meta&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>标签下，插入如下代码：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> post.top %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;green&quot;</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="首页不显示全文"><a href="#首页不显示全文" class="headerlink" title="首页不显示全文"></a>首页不显示全文</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="替换标签前缀-字符"><a href="#替换标签前缀-字符" class="headerlink" title="替换标签前缀 # 字符"></a>替换标签前缀 # 字符</h3><p>主题_config.yml<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="markdown改变字体颜色"><a href="#markdown改变字体颜色" class="headerlink" title="markdown改变字体颜色"></a>markdown改变字体颜色</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">改变颜色 <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span>text<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">改变字体 <span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span>微软雅黑<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">改变大小 <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span> <span class="attr">size</span>=<span class="string">12</span>&gt;</span>字号12<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">改变背景色 <span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">orange</span>&gt;</span>背景色是：orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="markdown插入超链接"><a href="#markdown插入超链接" class="headerlink" title="markdown插入超链接"></a>markdown插入超链接</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">[提示文字](<span class="name">url</span>)</span><br></pre></td></tr></table></figure>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&#123;<span class="meta">%</span> asset_img test.jpg <span class="meta">%</span>&#125;</span><br><span class="line"><span class="comment">//test.jpg在对应资源文件夹</span></span><br></pre></td></tr></table></figure>
<p>一些图片网站</p>
<p><a href="https://pixabay.com/images/search/">https://pixabay.com/images/search/</a></p>
<p><a href="https://unsplash.com/">https://unsplash.com/</a></p>
<p><a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p>
<h3 id="鼠标特效"><a href="#鼠标特效" class="headerlink" title="鼠标特效"></a>鼠标特效</h3><p>在themes\next\source\js目录下新建fire.js,内容如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; origin, speed, color, angle, context &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.origin = origin</span><br><span class="line">    <span class="keyword">this</span>.position = &#123; ...<span class="keyword">this</span>.origin &#125;</span><br><span class="line">    <span class="keyword">this</span>.color = color</span><br><span class="line">    <span class="keyword">this</span>.speed = speed</span><br><span class="line">    <span class="keyword">this</span>.angle = angle</span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.fillStyle = <span class="keyword">this</span>.color</span><br><span class="line">    <span class="keyword">this</span>.context.beginPath()</span><br><span class="line">    <span class="keyword">this</span>.context.arc(<span class="keyword">this</span>.position.x, <span class="keyword">this</span>.position.y, <span class="number">2</span>, <span class="number">0</span>, Math.PI * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">this</span>.context.fill()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">this</span>.position.x = (Math.sin(<span class="keyword">this</span>.angle) * <span class="keyword">this</span>.speed) + <span class="keyword">this</span>.position.x</span><br><span class="line">    <span class="keyword">this</span>.position.y = (Math.cos(<span class="keyword">this</span>.angle) * <span class="keyword">this</span>.speed) + <span class="keyword">this</span>.position.y + (<span class="keyword">this</span>.renderCount * <span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">this</span>.renderCount++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boom</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (&#123; origin, context, circleCount = <span class="number">16</span>, area &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.origin = origin</span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.circleCount = circleCount</span><br><span class="line">    <span class="keyword">this</span>.area = area</span><br><span class="line">    <span class="keyword">this</span>.stop = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.circles = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  randomArray(range) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = range.length</span><br><span class="line">    <span class="keyword">const</span> randomIndex = Math.floor(length * Math.random())</span><br><span class="line">    <span class="keyword">return</span> range[randomIndex]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  randomColor() &#123;</span><br><span class="line">    <span class="keyword">const</span> range = [<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  randomRange(start, end) &#123;</span><br><span class="line">    <span class="keyword">return</span> (end - start) * Math.random() + start</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.circleCount; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> circle = new Circle(&#123;</span><br><span class="line">        context: <span class="keyword">this</span>.context,</span><br><span class="line">        origin: <span class="keyword">this</span>.origin,</span><br><span class="line">        color: <span class="keyword">this</span>.randomColor(),</span><br><span class="line">        angle: <span class="keyword">this</span>.randomRange(Math.PI - <span class="number">1</span>, Math.PI + <span class="number">1</span>),</span><br><span class="line">        speed: <span class="keyword">this</span>.randomRange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.circles.push(circle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">this</span>.circles.forEach((circle, index) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (circle.position.x &gt; <span class="keyword">this</span>.area.width || circle.position.y &gt; <span class="keyword">this</span>.area.height) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.circles.splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      circle.move()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.circles.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stop = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="keyword">this</span>.circles.forEach(circle =&gt; circle.draw())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CursorSpecialEffects</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.computerCanvas = document.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">    <span class="keyword">this</span>.renderCanvas = document.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.computerContext = <span class="keyword">this</span>.computerCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">    <span class="keyword">this</span>.renderContext = <span class="keyword">this</span>.renderCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.globalWidth = window.innerWidth</span><br><span class="line">    <span class="keyword">this</span>.globalHeight = window.innerHeight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.booms = []</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseDown(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> boom = new Boom(&#123;</span><br><span class="line">      origin: &#123; x: e.clientX, y: e.clientY &#125;,</span><br><span class="line">      context: <span class="keyword">this</span>.computerContext,</span><br><span class="line">      area: &#123;</span><br><span class="line">        width: <span class="keyword">this</span>.globalWidth,</span><br><span class="line">        height: <span class="keyword">this</span>.globalHeight</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    boom.<span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">this</span>.booms.push(boom)</span><br><span class="line">    <span class="keyword">this</span>.running || <span class="keyword">this</span>.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handlePageHide() &#123;</span><br><span class="line">    <span class="keyword">this</span>.booms = []</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="keyword">this</span>.renderCanvas.style</span><br><span class="line">    style.position = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    style.top = style.left = <span class="number">0</span></span><br><span class="line">    style.zIndex = <span class="string">&#x27;999999999999999999999999999999999999999999&#x27;</span></span><br><span class="line">    style.pointerEvents = <span class="string">&#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line">    style.width = <span class="keyword">this</span>.renderCanvas.width = <span class="keyword">this</span>.computerCanvas.width = <span class="keyword">this</span>.globalWidth</span><br><span class="line">    style.height = <span class="keyword">this</span>.renderCanvas.height = <span class="keyword">this</span>.computerCanvas.height = <span class="keyword">this</span>.globalHeight</span><br><span class="line"></span><br><span class="line">    document.body.append(<span class="keyword">this</span>.renderCanvas)</span><br><span class="line"></span><br><span class="line">    window.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="keyword">this</span>.handleMouseDown.bind(<span class="keyword">this</span>))</span><br><span class="line">    window.addEventListener(<span class="string">&#x27;pagehide&#x27;</span>, <span class="keyword">this</span>.handlePageHide.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.booms.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.running = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(<span class="keyword">this</span>.run.bind(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.computerContext.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.globalWidth, <span class="keyword">this</span>.globalHeight)</span><br><span class="line">    <span class="keyword">this</span>.renderContext.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.globalWidth, <span class="keyword">this</span>.globalHeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.booms.forEach((boom, index) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (boom.stop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.booms.splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      boom.move()</span><br><span class="line">      boom.draw()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.renderContext.drawImage(<span class="keyword">this</span>.computerCanvas, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.globalWidth, <span class="keyword">this</span>.globalHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cursorSpecialEffects = new CursorSpecialEffects()</span><br><span class="line">cursorSpecialEffects.<span class="keyword">init</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>在themes\next\layout的layout.njk下添加<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/fire.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="自定义回到顶部"><a href="#自定义回到顶部" class="headerlink" title="自定义回到顶部"></a>自定义回到顶部</h3><p>在source\images目录下放入自定义scroll.png，然后在source_data\styles.styl增加</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义回到顶部样式</span></span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;  <span class="comment">//图片素材宽度</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">900px</span>;  <span class="comment">//图片素材高度</span></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">900px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: unset;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">5s</span> ease-in-out;</span><br><span class="line">  <span class="attribute">background</span>: url(<span class="string">&quot;/images/scroll.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐藏箭头图标</span></span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? calc( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>关于本站</tag>
      </tags>
  </entry>
  <entry>
    <title>胡言乱语</title>
    <url>/2020/08/01/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>
    <div id="aplayer-ocNaMvaR" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="442016694" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>
<p>しつこくあの人に話しかけて、馬鹿みたいにあの人のすべてを気にして、でも知ってる。</p>
<a id="more"></a>
<p>あの人は君のメールをもらった時に、「この人うざい」ってしか思わないょ。</p>
<p>もう君が私のことをすきになるのを期待していない、そろそろ君の世界から行かなきゃ。</p>
<p>君を失うよりは、君が他の人のものになるほうが怖い。</p>
<p>空いてる席にはいずれ誰かが座ることは分かるけど、それでも涙が我慢できない、結局私は出られないんだ。</p>
<p>あなたにメッセージを送るたびに冒険をして、一日の気分の良い悪いを賭けた。</p>
<p>君が好きというのは、多分心の中ではもう千回諦めたけど。</p>
<p>君が一度だけ振り向いてくれるなら、君の愛する希望が改めてもえること。</p>
<p>人はいつも夜で、忘れられないのを思い出す。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
